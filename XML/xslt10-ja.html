<!DOCTYPE html>

<html lang="ja">

<head>
	<meta charset="utf-8" />
	<meta name="Description" content="XSLT 1.0 仕様の日本語訳" />
	<meta name="Keywords" content="XSLT,XML,仕様,訳" />


	<title title="XSL Transformations (XSLT)">XSL 変換 (XSLT) 1.0</title>
<!-- 
<link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/W3C-REC" />
-->

<style >

body {
  padding: 2em;
  margin: 0;
  font-family: sans-serif;
  color: black;
  background-color: white;
}

p.copyright { font-size: small }

h1, h2, h3, h4, h5, h6 {
	text-align: left;
	color: #005A9C;
	font-style: sans-family;
}
h1 { font-size: 170%;}
h2 { font-size: 140%;}
h3 { font-size: 120%;}
h4 { font-size: 110%;}
h5 { font-size: 105%;}
h6 { font-size: 100%;}


blockquote {
	background-color:#EFE;
	border: inset  2px;
	padding: 1em;
}
blockquote > p {
	margin:0;
}

pre {
	margin-left: 2em;
	background-color:#FFE;
	font-family: monospace;
}

pre.element-syntax {
	border: solid thin;
	padding-left: 1em;
}

code {
	font-family: monospace;
	color: #731;
	font-weight: bolder;
}

table.scrap {
	padding: 1em;
	background-color:#FFE;
}
table.scrap td {
	vertical-align:top;
}
table.scrap td:first-child {
	text-align:left;
	padding-right: 1em;
}
table.scrap td:first-child + td + td {
	padding-right: 1em;
	padding-left: 1em;
}


/* errata
	background-color:#DFF;
 */
.errata, ins {
	color:#011;
}
del, del.errata {
	color:gray;
}

/* translation annotations */
.trans-note {
	color:#131;
	background-color:#DFD;
}

.trans-meta {
	border: double #BB3333 6px; padding:0.5em 1em;
	margin-bottom: 1em;
}

/* source view */

#sample-source-style,
p > span:lang(en) {
	background-color:#EEF;
	display:block;
}

body.hide_source p > span:lang(en),
body.show_at p > span:lang(en) {
	display: none;
}
body.show_at p:hover > span:lang(en) {
	display: block;
}


section, aside, footer, header, nav, hgroup {
	display:block;
}

section {
	border-left:solid #DDD 1px;
	padding-left: 3px;
}


nav ul {
	list-style-type: none;
}

dfn {
	font-weight: bold;
}

</style>

<script >

function switch_view(mode){
	document.body.className = mode;
}

// 原文表示開閉
function toggle_source(event){
	var target = event.target || window.event.srcElement;
	while(target){
		var tag = target.tagName;
		if(!tag) return;
		if(target.getAttribute('lang') === 'en') return;
		if(tag.toUpperCase() === 'P') {
			var en = target.lastElementChild;
			if(en.getAttribute('lang') !== 'en') return;
			en.style.display = en.style.display ? '' : 'block';
			return;
		}
		target = target.parentNode;
	}
};

</script>

   </head>

<body
	onload="document.getElementById('show_source').checked = true;" 
	ondblclick="toggle_source(event)">


<aside class="trans-meta" >
<h2 style="">XSL Transformations (XSLT) 1.0 仕様 日本語訳</h2>
<p>
この文書は、<a href="http://www.w3.org/">W3C</a> が作成し、勧告として公開された <a href="http://www.w3.org/TR/xslt">XSL Transformations (XSLT) Version 1.0</a> を日本語に翻訳したものです。
</p>
<ul>
    <li><strong >この翻訳には翻訳上の誤りがあるかもしれませんし、正確性は保証されません。</strong></li>
    <li>XPath 1.0 仕様書の公式の文書は英語版であり、この日本語版は公式のものではありません。</li>
    <li>この翻訳は二次著作物にあたり、原著作権は<a href="#copyright-notice">原著作物に帰するもの</a>です。</li>
</ul>
この訳には原文仕様に対する公式な修正も統合されています：
<a href="#about-translation" >その他, この翻訳に関する詳細</a>
</aside>

<div style="background-color:#DFD; border:solid 1px;">
<a href="#contents" >目次へ飛ぶ</a>&nbsp;&nbsp;
<span >原文表示：
	<label >
		<input type="radio" id="show_source" name="source_view" tabindex="0" checked="checked" 
			onchange="switch_view('show_source')" />
		常に表示
	</label>
	<label >
		<input type="radio" id="hide_source" name="source_view" tabindex="0" 
			onchange="switch_view('hide_source')" />
		常に隠す（本文ダブルクリックで開閉）
	</label>
</span>
</div>



<header class="head">
<a href="http://www.w3.org/">
W3C Home
<!-- <img src="http://www.w3.org/Icons/WWW/w3c_home" alt="W3C" height="48" width="72"/> -->
</a>

<h1 title="XSL Transformations (XSLT) Version 1.0">XSL 変換 (XSLT) 1.0</h1>

<h2 title="W3C Recommendation 16 November 1999">W3C 勧告 1999年 11 月 16 日付</h2>

<dl>
<dt title="This version:">この版：</dt>
<dd>
<a href="http://www.w3.org/TR/1999/REC-xslt-19991116">http://www.w3.org/TR/1999/REC-xslt-19991116</a>
<span title="(available in XML or HTML)">（
<a href="http://www.w3.org/TR/1999/REC-xslt-19991116.xml">XML 版</a>
<a href="http://www.w3.org/TR/1999/REC-xslt-19991116.html">HTML 版</a>
）</span>
</dd>
<dt title="Latest version:">最新版：</dt>
<dd>
<a href="http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</a>
</dd>
<dt title="Previous versions:">以前の版</dt>
<dd>
	<ul>
<li><a href="http://www.w3.org/TR/1999/PR-xslt-19991008">http://www.w3.org/TR/1999/PR-xslt-19991008</a></li>
<li><a href="http://www.w3.org/1999/08/WD-xslt-19990813">http://www.w3.org/1999/08/WD-xslt-19990813</a></li>
<li><a href="http://www.w3.org/1999/07/WD-xslt-19990709">http://www.w3.org/1999/07/WD-xslt-19990709</a></li>
<li><a href="http://www.w3.org/TR/1999/WD-xslt-19990421">http://www.w3.org/TR/1999/WD-xslt-19990421</a></li>
<li><a href="http://www.w3.org/TR/1998/WD-xsl-19981216">http://www.w3.org/TR/1998/WD-xsl-19981216</a></li>
<li><a href="http://www.w3.org/TR/1998/WD-xsl-19980818">http://www.w3.org/TR/1998/WD-xsl-19980818</a></li>
	</ul>
</dd>
<dt title="Editor:">編集：</dt>
<dd>James Clark <a href="mailto:jjc@jclark.com">&lt;jjc@jclark.com&gt;</a>
</dd>
</dl>

<small lang="en" class="copyright">
<a href="http://www.w3.org/Consortium/Legal/ipr-notice.html#Copyright">Copyright</a>
© 1999
<a href="http://www.w3.org">W3C</a>
<sup>®</sup> (
<a href="http://www.lcs.mit.edu">MIT</a>,
<a href="http://www.inria.fr/">INRIA</a>,
<a href="http://www.keio.ac.jp/">Keio</a>
), All Rights Reserved. W3C
<a href="http://www.w3.org/Consortium/Legal/ipr-notice.html#Legal_Disclaimer">liability</a>,
<a href="http://www.w3.org/Consortium/Legal/ipr-notice.html#W3C_Trademarks">trademark</a>,
<a href="http://www.w3.org/Consortium/Legal/copyright-documents.html">document use</a>
and
<a href="http://www.w3.org/Consortium/Legal/copyright-software.html">software licensing</a>
rules apply.
</small>

</header>

<hr />

<div >

<h2 id="abstract" title="Abstract">要約</h2>

      <p>
この仕様は XSLT の構文と意味内容を定義する。
XSLT とは、 XML 文書を別の XML 文書に変換するための言語である。
<span lang="en">
This specification defines the syntax and semantics of XSLT, which is a language for transforming XML documents into other XML documents.</span>
      </p>
      <p>
XSLT は、 XML 用のスタイルシート言語 XSL の一部として利用するために設計されている。
XSL には XSLT の他に、フォーマットを指定するための XML 語彙も含まれる。
XSLT は XML 文書に対し、フォーマット語彙を利用する別の XML 文書へどのように変換するかを記述する。
XSL はこの XSLT の機能を利用して XML 文書のスタイル付けを指定する。
<span lang="en">
XSLT is designed for use as part of XSL, which is a stylesheet language for XML.
In addition to XSLT, XSL includes an XML vocabulary for specifying formatting.
XSL specifies the styling of an XML document by using XSLT to describe how the document is transformed into another XML document that uses the formatting vocabulary.</span>
      </p>
      <p>
XSLT は XSL から独立に利用できるようにも設計されている。
しかしながら、 XSLT は 完全に汎用的な XML 変換用言語としての利用が意図されたものではない。
むしろ設計の主眼は XSL の一部として XSLT を利用する際に必要となる変換処理を行う所に置かれている。
<span lang="en">
XSLT is also designed to be used independently of XSL.
However, XSLT is not intended as a completely general-purpose XML transformation language.
Rather it is designed primarily for the kinds of transformations that are needed when XSLT is used as part of XSL.</span>
      </p>
</div>

<div>

<h2 id="status" title="Status of this document">この文書の位置付け</h2>
      <p>
この文書は、 W3C メンバおよび他の関係団体から審査された上で、 W3C 
<a href="http://www.w3.org/Consortium/Process/#RecsW3C">勧告</a>
として担当の責任者が承認したものである。
今後変更される可能性はなく、他の文書において参照文献として利用したり、他の文書から正式な参照文献として引用することができる。
勧告の策定にあたって W3C が担う役割は、この仕様を広く普及させることにある。
これによりウェブの機能性と相互運用性を向上させられるようになる。
<span lang="en">
This document has been reviewed by W3C Members and other interested parties and has been endorsed by the Director as a W3C Recommendation.
It is a stable document and may be used as reference material or cited as a normative reference from other documents.
W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment.
This enhances the functionality and interoperability of the Web.</span>
      </p>
      <p>
この仕様に関する正誤表は
<a href="http://www.w3.org/1999/11/REC-xslt-19991116-errata">http://www.w3.org/1999/11/REC-xslt-19991116-errata</a>
から参照できる。
<span class="trans-note">【当訳にはこのページ更新日までの修正が取り込まれています】</span>
<span lang="en">
The list of known errors in this specification is available at http://www.w3.org/1999/11/REC-xslt-19991116-errata.</span>
      </p>
      <p>
この仕様に関するコメントの宛先は
<a href="mailto:xsl-editors@w3.org">xsl-editors@w3.org</a>
である。
なお、コメントの
<a href="http://lists.w3.org/Archives/Public/xsl-editors">archives</a>
も利用できる。
XSL Transformations を含む XSL に関する公開討論は、
<a href="http://www.mulberrytech.com/xsl/xsl-list/index.html">XSL-List</a>
メーリングリストで行われている。
<span lang="en">
Comments on this specification may be sent to xsl-editors@w3.org; archives of the comments are available.
Public discussion of XSL, including XSL Transformations, takes place on the XSL-List mailing list.</span>
      </p>
      <p>
英語版のみがこの仕様の正式なバージョンになる。
翻訳版を
<a href="http://www.w3.org/Style/XSL/translations.html">http://www.w3.org/Style/XSL/translations.html</a>
から参照できる。
<span lang="en">
The English version of this specification is the only normative version.
However, for translations of this document, see http://www.w3.org/Style/XSL/translations.html.</span>
      </p>
      <p>
W3C 勧告の一覧、およびその他の技術文書は
<a href="http://www.w3.org/TR">http://www.w3.org/TR</a>.
から入手できる。
<span lang="en">
A list of current W3C Recommendations and other technical documents can be found at http://www.w3.org/TR.</span>
      </p>
      <p>
この仕様は
<a href="http://www.w3.org/Style/Activity">W3C Style activity</a>
の一環として作成されたものである。
<span lang="en">
This specification has been produced as part of the W3C Style activity.</span>
      </p>

</div>

<nav >

<h2 id="contents" title="Table of contents">目次</h2>
<ul>
   <li title="Introduction">
1 <a href="#section-Introduction">概要</a></li>
   <li title="Stylesheet Structure">
2 <a href="#section-Stylesheet-Structure">スタイルシートの構造</a>
      <ul>
         <li title="XSLT Namespace">
2.1 <a href="#xslt-namespace">XSLT 名前空間</a></li>
         <li title="Stylesheet Element">
2.2 <a href="#stylesheet-element">スタイルシートの要素</a></li>
         <li title="Literal Result Element as Stylesheet">
2.3 <a href="#result-element-stylesheet">スタイルシートとしてのリテラル結果要素</a></li>
         <li title="Qualified Names">
2.4 <a href="#qname">修飾名</a></li>
         <li title="Forwards-Compatible Processing">
2.5 <a href="#forwards">前方互換処理</a></li>
         <li title="Combining Stylesheets">
2.6 <a href="#section-Combining-Stylesheets">スタイルシートの結合</a>
            <ul>
               <li title="Stylesheet Inclusion">
2.6.1 <a href="#include">スタイルシートのインクルード</a></li>
               <li title="Stylesheet Import">
2.6.2 <a href="#import">スタイルシートのインポート</a></li>
            </ul>
         </li>
         <li title="Embedding Stylesheets">
2.7 <a href="#section-Embedding-Stylesheets">スタイルシートの埋め込み</a></li>
      </ul>
   </li>
   <li title="Data Model">
3 <a href="#data-model">データモデル</a>
      <ul>
         <li title="Root Node Children">
3.1 <a href="#root-node-children">ルートノードの子</a></li>
         <li title="Base URI">
3.2 <a href="#base-uri">基底 URI</a></li>
         <li title="Unparsed Entities">
3.3 <a href="#unparsed-entities">解析対象外実体</a></li>
         <li title="Whitespace Stripping">
3.4 <a href="#strip">空白の削除</a></li>
         <li title="">
3.5 <a href="#3-5">3.5</a></li>
      </ul>
   </li>
   <li title="Expressions">
4 <a href="#section-Expressions">式</a></li>
   <li title="Template Rules">
5 <a href="#rules">テンプレートルール</a>
      <ul>
         <li title="Processing Model">
5.1 <a href="#section-Processing-Model">処理モデル</a></li>
         <li title="Patterns">
5.2 <a href="#patterns">パターン</a></li>
         <li title="Defining Template Rules">
5.3 <a href="#section-Defining-Template-Rules">テンプレートルールの定義</a></li>
         <li title="Applying Template Rules">
5.4 <a href="#section-Applying-Template-Rules">テンプレートルールの適用</a></li>
         <li title="Conflict Resolution for Template Rules">
5.5 <a href="#conflict">テンプレートルールの競合解決</a></li>
         <li title="Overriding Template Rules">
5.6 <a href="#apply-imports">テンプレートルールの上書き</a></li>
         <li title="Modes">
5.7 <a href="#modes">モード</a></li>
         <li title="Built-in Template Rules">
5.8 <a href="#built-in-rule">組み込みテンプレートルール</a></li>
      </ul>
   </li>
   <li title="Named Templates">
6 <a href="#named-templates">名前付きテンプレート</a></li>
   <li title="Creating the Result Tree">
7 <a href="#section-Creating-the-Result-Tree">結果ツリーの生成</a>
      <ul>
         <li title="Creating Elements and Attributes">
7.1 <a href="#section-Creating-Elements-and-Attributes">要素と属性の生成</a>
            <ul>
               <li title="Literal Result Elements">
7.1.1 <a href="#literal-result-element">リテラル結果要素</a></li>
               <li title="Creating Elements with xsl:element">
7.1.2 <a href="#section-Creating-Elements-with-xsl:element"><code>xsl:element</code> による要素の生成</a></li>
               <li title="Creating Attributes with xsl:attribute">
7.1.3 <a href="#creating-attributes"><code>xsl:attribute</code> による属性の生成</a></li>
               <li title="Named Attribute Sets">
7.1.4 <a href="#attribute-sets">名前付き属性集合</a></li>
            </ul>
         </li>
         <li title="Creating Text">
7.2 <a href="#section-Creating-Text">テキストの生成</a></li>
         <li title="Creating Processing Instructions">
7.3 <a href="#section-Creating-Processing-Instructions">処理命令の生成</a></li>
         <li title="Creating Comments">
7.4 <a href="#section-Creating-Comments">コメントの生成</a></li>
         <li title="Copying">
7.5 <a href="#copying">複製</a></li>
         <li title="Computing Generated Text">
7.6 <a href="#section-Computing-Generated-Text">テキストの動的生成</a>
            <ul>
               <li title="Generating Text with xsl:value-of">
7.6.1 <a href="#value-of"><code>xsl:value-of</code> によるテキストの生成</a></li>
               <li title="Attribute Value Templates">
7.6.2 <a href="#attribute-value-templates">属性値テンプレート</a></li>
            </ul>
         </li>
         <li title="Numbering">
7.7 <a href="#number">番号付け</a>
            <ul>
               <li title="Number to String Conversion Attributes">
7.7.1 <a href="#convert">数値から文字列への変換の属性</a></li>
            </ul>
         </li>
      </ul>
   </li>
   <li title="Repetition">
8 <a href="#for-each">繰り返し</a></li>
   <li title="Conditional Processing">
9 <a href="#section-Conditional-Processing">条件処理</a>
      <ul>
         <li title="Conditional Processing with xsl:if">
9.1 <a href="#section-Conditional-Processing-with-xsl:if"><code>xsl:if</code> による条件処理</a></li>
         <li title="Conditional Processing with xsl:choose">
9.2 <a href="#section-Conditional-Processing-with-xsl:choose"><code>xsl:choose</code> による条件処理</a></li>
      </ul>
   </li>
   <li title="Sorting">
10 <a href="#sorting">ソート処理</a></li>
   <li title="Variables and Parameters">
11 <a href="#variables">変数とパラメタ</a>
      <ul>
         <li title="Result Tree Fragments">
11.1 <a href="#section-Result-Tree-Fragments">結果ツリー素片</a></li>
         <li title="Values of Variables and Parameters">
11.2 <a href="#variable-values">変数とパラメタの値</a></li>
         <li title="Using Values of Variables and Parameters with xsl:copy-of">
11.3 <a href="#copy-of"><code >xsl:copy-of</code> における変数とパラメタの値の利用</a></li>
         <li title="Top-level Variables and Parameters">
11.4 <a href="#top-level-variables">トップレベルの変数とパラメタ</a></li>
         <li title="Variables and Parameters within Templates">
11.5 <a href="#local-variables">テンプレート内部の変数とパラメタ</a></li>
         <li title="Passing Parameters to Templates">
11.6 <a href="#section-Passing-Parameters-to-Templates">テンプレートへのパラメタの引き渡し</a></li>
      </ul>
   </li>
   <li title="Additional Functions">
12 <a href="#add-func">追加の関数</a>
      <ul>
         <li title="Multiple Source Documents">
12.1 <a href="#document">複数のソース文書</a></li>
         <li title="Keys">
12.2 <a href="#key">キー</a></li>
         <li title="Number Formatting">
12.3 <a href="#format-number">数値のフォーマット化</a></li>
         <li title="Miscellaneous Additional Functions">
12.4 <a href="#misc-func">その他の追加の関数</a></li>
      </ul>
   </li>
   <li title="Messages">
13 <a href="#message">メッセージ</a></li>
   <li title="Extensions">
14 <a href="#extension">拡張</a>
      <ul>
         <li title="Extension Elements">
14.1 <a href="#extension-element">拡張要素</a></li>
         <li title="Extension Functions">
14.2 <a href="#section-Extension-Functions">拡張関数</a></li>
      </ul>
   </li>
   <li title="Fallback">
15 <a href="#fallback">フォールバック</a></li>
   <li title="Output">
16 <a href="#output">出力</a>
      <ul>
         <li title="XML Output Method">
16.1 <a href="#section-XML-Output-Method">XML 出力メソッド</a></li>
         <li title="HTML Output Method">
16.2 <a href="#section-HTML-Output-Method">HTML 出力メソッド</a></li>
         <li title="Text Output Method">
16.3 <a href="#section-Text-Output-Method">テキスト出力メソッド</a></li>
         <li title="Disabling Output Escaping">
16.4 <a href="#disable-output-escaping">出力エスケープの無効化</a></li>
      </ul>
   </li>
   <li title="Conformance">
17 <a href="#conformance">適合性</a></li>
   <li title="Notation">
18 <a href="#notation">表記法</a></li>
</ul>

<h3 title="Appendices">付録</h3>
<ul>
   <li title="References">
A <a href="#section-References">参照文献</a>
      <ul>
         <li title="Normative References">
A.1 <a href="#section-Normative-References">正式な参照文献</a></li>
         <li title="Other References">
A.2 <a href="#section-Other-References">その他の参照文献</a></li>
      </ul>
   </li>
   <li title="Element Syntax Summary">
B <a href="#element-syntax-summary">要素構文要約</a></li>
   <li title="DTD Fragment for XSLT Stylesheets">
C <a href="#dtd">XSLT スタイルシート用 DTD 素片</a>（規定外）</li>
   <li title="Examples">
D <a href="#section-Examples">例</a>（規定外）
      <ul>
         <li title="Document Example">
D.1 <a href="#section-Document-Example">文書例</a></li>
         <li title="Data Example">
D.2 <a href="#data-example">データ例</a></li>
      </ul>
   </li>
   <li title="Acknowledgements">
E <a href="#section-Acknowledgements">謝辞</a>（規定外）</li>
   <li title="Changes from Proposed Recommendation">
F <a href="#section-Changes-from-Proposed-Recommendation">勧告案からの変更点</a>（規定外）</li>
   <li title="Features under Consideration for Future Versions of XSLT">
G <a href="#section-Features-under-Consideration-for-Future-Versions-of-XSLT">XSLT の将来版に検討中の機能</a>（規定外）</li>
</ul>

</nav>

<hr/>

<section>

<h2 id="section-Introduction" title="1 Introduction">1 概要</h2>
      <p>
この仕様は XSLT 言語の構文と意味内容を定義する。
XSLT 言語による変換は XML 名前空間勧告
<a href="#XMLNAMES">[XML Names]</a>
<ins class="errata">または
<a href="#XMLNames11">[XML Names 1.1]</a></ins>
に適合する整形式の XML 文書
<a href="#XML">[XML]</a>
<ins class="errata">または
<a href="#XML11">[XML 1.1]</a></ins>
として表記される。
その内容は XSLT で定義される要素と XSLT で定義されない要素のいずれも含み得る。

<ins class="errata">
便宜上、通常は XML 1.0 と XML Names 1.0 への参照が用いられる。
従って、 IRI もサポートされているが, URI 参照の方が用いられる。
一部の場合では XML 1.0 と XML 1.1 の定義は完全に一致し得る。
</ins><!-- E39 -->

XSLT で定義される要素は、特定の XML 名前空間への所属により他から区別される（
<a href="#xslt-namespace">[ <b id="dt-xslt-namespace">2.1 XSLT 名前空間</b> ]</a>
を見よ）。
この仕様では、この特定の XML 名前空間を <dfn>XSLT 名前空間</dfn>と呼ぶ。
すなわち、この仕様は XSLT 名前空間の構文と意味内容を定義するものである。

<span lang="en">
This specification defines the syntax and semantics of the XSLT language.
A transformation in the XSLT language is expressed as a well-formed XML document [XML]<ins class="errata"> or [XML 1.1]</ins> conforming to the Namespaces in XML Recommendation [XML Names]<ins class="errata"> or [XML Names 1.1]</ins>, which may include both elements that are defined by XSLT and elements that are not defined by XSLT.

<ins class="errata">For convenience, XML 1.0 and XML Names 1.0 references are usually used.
Thus, URI references are also used though IRI may also be supported.
In some cases, the XML 1.0 and XML 1.1 definitions may be exactly the same.</ins><!-- E39 -->

XSLT-defined elements are distinguished by belonging to a specific XML namespace (see [2.1 XSLT Namespace]), which is referred to in this specification as the XSLT namespace.
Thus this specification is a definition of the syntax and semantics of the XSLT namespace.</span>

      </p>
      <p>
XSLT が表現する変換は、ソースツリーから結果ツリーへの変換を行う処理規則で記述される。
変換はパターンとテンプレートとの関連付けにより得られる。
ソースツリー内の要素がパターンと照合され、パターンに関連付けられたテンプレートがインスタンス化されて結果ツリーの部品を生成する。
結果ツリーはソースツリーから独立であり、その構造はソースツリーの構造からまったく別物にもなり得る。
結果ツリーの構築においては、ソースツリーの要素をふるいにかけたり, 要素の順序を変更したり, 任意の構造を追加することが可能である。 
<span lang="en">
A transformation expressed in XSLT describes rules for transforming a source tree into a result tree.
The transformation is achieved by associating patterns with templates.
A pattern is matched against elements in the source tree.
A template is instantiated to create part of the result tree.
The result tree is separate from the source tree.
The structure of the result tree can be completely different from the structure of the source tree.
In constructing the result tree, elements from the source tree can be filtered and reordered, and arbitrary structure can be added.</span>
      </p>
      <p>
XSLT が表現する変換をスタイルシートと呼ぶ。
その理由は、 XSLT が XSL のフォーマット語彙への変換に利用される局面においては、この変換がスタイルシートとして機能するからである。

<span lang="en">
A transformation expressed in XSLT is called a stylesheet.
This is because, in the case when XSLT is transforming into the XSL formatting vocabulary, the transformation functions as a stylesheet.</span>
      </p>
      <p>
この文書では XSLT スタイルシートを XML 文書に関連付ける方法は規定しない。
XSL プロセッサには
<a href="#XMLSTYLE">[XML Stylesheet]</a>
で述べられる仕組みのサポートが推奨される。
その仕組みまたは他の仕組みにより、１つの XML 文書に複数の XSLT スタイルシートが（一定の順序により）同時に適用される場合、それらを順にインポートした１個のスタイルシートが適用されたときと同じ結果が得られるべきである（
<a href="#import">[<b>2.6.2 スタイルシートのインポート</b>]</a>
を見よ）。

<span lang="en">
This document does not specify how an XSLT stylesheet is associated with an XML document.
It is recommended that XSL processors support the mechanism described in [XML Stylesheet].
When this or any other mechanism yields a sequence of more than one XSLT stylesheet to be applied simultaneously to a XML document, then the effect should be the same as applying a single stylesheet that imports each member of the sequence in order (see [2.6.2 Stylesheet Import]).</span>
      </p>
      <p>
スタイルシートはテンプレートルールの集合を含む。
テンプレートルールは２つの部分からなる。
一つはソースツリーのノードと照合されるパターンであり, もう一つは結果ツリーの一部を構築するためにインスタンス化されるテンプレートである。
この構成により、１個のスタイルシートを類似するソースツリー構造を持つ多様な文書に適用できるようになる。

<span lang="en">
A stylesheet contains a set of template rules.
A template rule has two parts: a pattern which is matched against nodes in the source tree and a template which can be instantiated to form part of the result tree.
This allows a stylesheet to be applicable to a wide class of documents that have similar source tree structures.</span>
      </p>
      <p>
テンプレートはソースの特定の要素に対してインスタンス化され、結果ツリーの一部を生成する。
テンプレートはリテラルの結果要素構造を指定する要素も含み得る。
テンプレートは結果ツリーの素片を生成するための命令を与える XSLT 名前空間の要素も含み得る。
各命令は、テンプレートのインスタンス化に際し、命令の実行により生成される結果ツリー素片に置換される。
命令はソースの子孫要素を選択して処理することも可能である。
子孫要素の処理においては、適用可能なテンプレートルールが検索され、そのテンプレートのインスタンス化により、結果ツリー素片が生成される。
ソースツリーの要素は、命令の実行により選択されなければ処理されないことに注意すべきである。
結果ツリーは、ルートノードに適用し得るテンプレートルールの検索とそのテンプレートのインスタンス化により構築される。
<span lang="en">
A template is instantiated for a particular source element to create part of the result tree.
A template can contain elements that specify literal result element structure.
A template can also contain elements from the XSLT namespace that are instructions for creating result tree fragments.
When a template is instantiated, each instruction is executed and replaced by the result tree fragment that it creates.
Instructions can select and process descendant source elements.
Processing a descendant element creates a result tree fragment by finding the applicable template rule and instantiating its template.
Note that elements are only processed when they have been selected by the execution of an instruction.
The result tree is constructed by finding the template rule for the root node and instantiating its template.</span>
      </p>
      <p>
テンプレートルールの検索に際し、対象の要素に合致するパターンを持つテンプレートルールが複数見つかる場合がある。
このような場合でも、適用されるテンプレートルールは一つだけになる。
どのテンプレートルールを適用するかの決定方法については
<a href="#conflict">[<b>5.5 テンプレートルールの競合解決</b>]</a>
にて述べる。

<span lang="en">
In the process of finding the applicable template rule, more than one template rule may have a pattern that matches a given element.
However, only one template rule will be applied.
The method for deciding which template rule to apply is described in [5.5 Conflict Resolution for Template Rules].</span>
      </p>
      <p>
テンプレートは１個だけでも強力な処理機能を備えている。
望むだけ複雑な構造の生成, ソースツリー内の任意の場所からの文字列値の取得, ソースツリー内の要素の出現回数に応じた繰り返し構造の生成なども可能である。
結果ツリーの構造がソースツリーの構造から独立しているような単純な変換であれば、スタイルシートを完全な結果ツリーが得られるテンプレートとして機能する１個のテンプレートのみから構成することも大抵は可能である。
データを表現する XML 文書に対する変換の多くはこの種のものになる（
<a href="#data-example">[<b>D.2 データ例</b>]</a>
を見よ）。
XSLT では、このようなスタイルシートのための簡略構文も認められている（
<a href="#result-element-stylesheet">[<b>2.3 スタイルシートとしてのリテラル結果要素</b>]</a>
を見よ）。

<span lang="en">
A single template by itself has considerable power: it can create structures of arbitrary complexity; it can pull string values out of arbitrary locations in the source tree; it can generate structures that are repeated according to the occurrence of elements in the source tree.
For simple transformations where the structure of the result tree is independent of the structure of the source tree, a stylesheet can often consist of only a single template, which functions as a template for the complete result tree.
Transformations on XML documents that represent data are often of this kind (see [D.2 Data Example]).
XSLT allows a simplified syntax for such stylesheets (see [2.3 Literal Result Element as Stylesheet]).</span>
      </p>
      <p>
テンプレートのインスタンス化においては、常に <dfn id="dt-current-node">現在のノード</dfn> と <dfn id="dt-current-node-list">現在のノードリスト</dfn> が対象になる。
現在のノードは、常に現在のノードリストのメンバである。
XSLT の操作の多くは、現在のノードと関連する。
現在のノードリストや現在のノードを変更する命令は数種類しか存在しない（
<a href="#rules">[<b>5 テンプレートルール</b>]</a>
および
<a href="#for-each">[<b>8 繰り返し</b>]</a>
を見よ）。
これらの命令のいずれかのインスタンス化においては、現在のノードリストは新しいノードのリストに変更され、新しいリストの各メンバが順に現在のノードになる。
命令のインスタンス化が完了すると、現在のノードと現在のノードリストの内容は 命令がインスタンス化される前の状態に戻る。

<span lang="en">
When a template is instantiated, it is always instantiated with respect to a current node and a current node list.
The current node is always a member of the current node list.
Many operations in XSLT are relative to the current node.
Only a few instructions change the current node list or the current node (see [5 Template Rules] and [8 Repetition]); during the instantiation of one of these instructions, the current node list changes to a new list of nodes and each member of this new list becomes the current node in turn; after the instantiation of the instruction is complete, the current node and current node list revert to what they were before the instruction was instantiated.</span>
      </p>
      <p>
XSLT は
<a href="#XPATH">[XPath]</a>
で定義される式言語を利用して 処理対象要素の選択, 条件分岐処理, テキストの生成 を行う。
<span lang="en">
XSLT makes use of the expression language defined by [XPath] for selecting elements for processing, for conditional processing and for generating text.</span>
      </p>
      <p>
XSLT は言語の拡張用に２つの「フック」を備えている。
一つはテンプレートで用いる命令要素の集合を拡張するフックであり、もう一つは XPath 式で用いる関数の集合を拡張するフックである。
これらのフックはいずれも XML 名前空間を基にする。
このバージョンの XSLT では、フックの実装についての仕組みは定義しない。
<a href="#extension">[<b>14 拡張</b>]</a>
を見よ。
<span lang="en">
XSLT provides two "hooks" for extending the language, one hook for extending the set of instruction elements used in templates and one hook for extending the set of functions used in XPath expressions.
These hooks are both based on XML namespaces.
This version of XSLT does not define a mechanism for implementing the hooks.
See [14 Extensions].</span>
      </p>


      <blockquote>
<p>
<b>注記：</b>
XSL 作業グループは、この仕様の将来版または別個の仕様において、この仕組みを定義することを企図している。

<span lang="en">
NOTE:The XSL WG intends to define such a mechanism in a future version of this specification or in a separate specification.</span>
</p>
      </blockquote>
      <p>
<a href="#notation">[<b>18 表記法</b>]</a>
にて、 XSLT で定義する要素の構文の記述に用いられる, 要素構文の要約表記法を述べる。
<span lang="en">
The element syntax summary notation used to describe the syntax of XSLT-defined elements is described in [18 Notation].</span>
      </p>
      <p>
XSLT スタイルシートの MIME メディア型には <code>text/xml</code> と <code>application/xml</code>
<a href="#RFC2376">[RFC2376]</a>
が用いられるべきである。
将来的には XSLT スタイルシート固有のメディア型が明示的に登録され得る。
そのときは登録されたメディア型も利用できることになる。
<span lang="en">
The MIME media types text/xml and application/xml[RFC2376] should be used for XSLT stylesheets.
It is possible that a media type will be registered specifically for XSLT stylesheets; if and when it is, that media type may also be used.</span>
      </p>

</section>
<section>

<h2 id="section-Stylesheet-Structure" title="2 Stylesheet Structure">2 スタイルシートの構造</h2>

	<section>
<h3 id="xslt-namespace" title="2.1 XSLT Namespace">2.1 XSLT 名前空間</h3>
      <p>
XSLT 名前空間の URI は <code>http://www.w3.org/1999/XSL/Transform</code> である。

<span lang="en">
The XSLT namespace has the URI http://www.w3.org/1999/XSL/Transform.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
URI 内の <code>1999</code> は W3C がこの URI を割り当てた年度を示している。
この数字は利用する XSLT のバージョンを指示するものではない。
バージョンは属性により指定される（
<a href="#stylesheet-element">[<b>2.2 スタイルシートの要素</b>]</a>,
<a href="#result-element-stylesheet">[<b>2.3 スタイルシートとしてのリテラル結果要素</b>]</a> 
を見よ）。

<span lang="en">
NOTE:The 1999 in the URI indicates the year in which the URI was allocated by the W3C.
It does not indicate the version of XSLT being used, which is specified by attributes (see [2.2 Stylesheet Element] and [2.3 Literal Result Element as Stylesheet]).</span>
</p>
      </blockquote>
      <p>
XSLT プロセッサは XML 名前空間の要素と属性の認識に際し, XML 名前空間の仕組み
<a href="#XMLNAMES">[XML Names]</a>
を利用しなければならない。
XSLT 名前空間の要素はスタイルシート内でのみ認識され、ソース文書内では認識されない。
XSLT で定義する要素の全一覧は
<a href="#element-syntax-summary">[<b>B 要素の構文の要約</b>]</a>
で指定される。
ベンダは要素や属性を追加して XSLT 名前空間を拡張してはならない。
拡張を行う場所は XSLT 名前空間ではなく、別の名前空間内でなければならない。
命令用要素を追加する際に利用する名前空間は
<a href="#extension-element">[<b>14.1 拡張要素</b>]</a>
で規定する拡張要素の仕組みにより識別できなければならない。

<span lang="en">
XSLT processors must use the XML namespaces mechanism [XML Names] to recognize elements and attributes from this namespace.
Elements from the XSLT namespace are recognized only in the stylesheet <ins class="errata">and </ins><!-- E34 -->not in the source document.
The complete list of XSLT-defined elements is specified in [B Element Syntax Summary].
Vendors must not extend the XSLT namespace with additional elements or attributes.
Instead, any extension must be in a separate namespace.
Any namespace that is used for additional instruction elements must be identified by means of the extension element mechanism specified in [14.1 Extension Elements].</span>
      </p>
      <p>
この仕様においては XSLT 名前空間の要素を指す接頭辞に <code>xsl:</code> を用いることにする。
しかしながら, XSLT スタイルシートにおいては、名前空間宣言により XSLT 名前空間の URI に結びつけられているならば, どのような接頭辞が用いられてもよい。

<span lang="en">
This specification uses a prefix of xsl: for referring to elements in the XSLT namespace.
However, XSLT stylesheets are free to use any prefix, provided that there is a namespace declaration that binds the prefix to the URI of the XSLT namespace.</span>
      </p>
      <p>
XSLT 名前空間に属する要素は、 XSLT 名前空間に属さない任意の属性を, その
<a href="xpath10-ja.html#dt-expanded-name">展開名 (expanded-name)</a>
の名前空間 URI が null でない限り, 持つことができる。
ただし、このような属性の存在から XSLT 要素やこの文書で定義する関数のふるまいが変更されてはならない。
従って, XSLT プロセッサはこのような属性をいつでも無視してよく、その名前空間 URI を認識できない場合は, エラーを生成せずにこれらの属性を無視しなければならない。
このような属性は、例えば 一意的な識別子, 最適化のヒント, 添付情報 などを供し得る。
<span lang="en">
An element from the XSLT namespace may have any attribute not from the XSLT namespace, provided that the expanded-name of the attribute has a non-null namespace URI.
The presence of such attributes must not change the behavior of XSLT elements and functions defined in this document.
Thus, an XSLT processor is always free to ignore such attributes, and must ignore such attributes without giving an error if it does not recognize the namespace URI.
Such attributes can provide, for example, unique identifiers, optimization hints, or documentation.</span>
      </p>
      <p>
XSLT 名前空間の要素に、この文書で要素に定義する属性以外の, 展開名の名前空間 URI が null になる属性（名前に接頭辞が無い属性）が含まれる場合、エラーとする。
<span lang="en">
It is an error for an element from the XSLT namespace to have attributes with expanded-names that have null namespace URIs (i.e. attributes with unprefixed names) other than attributes defined for the element in this document.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
XSLT の要素名, 属性名, 関数名 に関する表記慣行は、小文字のみ, 単語はハイフン区切り, 略語の利用は XML や HTML などの関連言語の構文内ですでに現れている場合のみ、とされている。
<span lang="en">
NOTE:The conventions used for the names of XSLT elements, attributes and functions are that names are all lower-case, use hyphens to separate words, and use abbreviations only if they already appear in the syntax of a related language such as XML or HTML.</span>
</p>
      </blockquote>

	</section>
	<section>

<h3 id="stylesheet-element" title="2.2 Stylesheet Element">2.2 スタイルシート要素</h3>
      <pre class="element-syntax" id="element-stylesheet">
&lt;xsl:stylesheet
  id = <var>id</var> 
  extension-element-prefixes = <var>tokens</var> 
  exclude-result-prefixes = <var>tokens</var>
         <b>version</b> = <var>number</var>&gt;
  &lt;!-- 内容：(<a href="#element-import">xsl:import</a>*, <var>top-level-elements</var>) --&gt;
&lt;/xsl:stylesheet&gt;</pre>
      <pre class="element-syntax" id="element-transform">
&lt;xsl:transform
  id = <var>id</var> 
  extension-element-prefixes = <var>tokens</var> 
  exclude-result-prefixes = <var>tokens</var>
         <b>version</b> = <var>number</var>&gt;
  &lt;!-- 内容：(<a href="#element-import">xsl:import</a>*, <var>top-level-elements</var>) --&gt;
&lt;/xsl:transform&gt;</pre>
      <p>
スタイルシートは XML 文書内の <code>xsl:stylesheet</code> 要素で表現される。

<code>xsl:transform</code> も <code>xsl:stylesheet</code> の同義語として許容される。

<span lang="en">
A stylesheet is represented by an xsl:stylesheet element in an XML document.
xsl:transform is allowed as a synonym for xsl:stylesheet.</span>
      </p>
      <p>
<code>xsl:stylesheet</code> 要素には、スタイルシートが要求する XSLT のバージョンを指示する <code>version</code> 属性が与えられていなければならない。
このバージョンの XSLT においては、属性値は <code>1.0</code> とすべきである。
この値が <code>1.0</code> 以外の場合、前方互換処理モードが有効になる （
<a href="#forwards">[<b>2.5 前方互換処理</b>]</a>
を見よ）。

<span lang="en">
An xsl:stylesheet element must have a version attribute, indicating the version of XSLT that the stylesheet requires.
For this version of XSLT, the value should be 1.0.
When the value is not equal to 1.0, forwards-compatible processing mode is enabled (see [2.5 Forwards-Compatible Processing]).</span>
      </p>
      <p>
<code>xsl:stylesheet</code> 要素は、次の型の要素を含み得る。

<span lang="en">
The xsl:stylesheet element may contain the following types of elements:</span>
      </p>
      <ul>
         <li><code>xsl:import</code></li>
         <li><code>xsl:include</code></li>
         <li><code>xsl:strip-space</code></li>
         <li><code>xsl:preserve-space</code></li>
         <li><code>xsl:output</code></li>
         <li><code>xsl:key</code></li>
         <li><code>xsl:decimal-format</code></li>
         <li><code>xsl:namespace-alias</code></li>
         <li><code>xsl:attribute-set</code></li>
         <li><code>xsl:variable</code></li>
         <li><code>xsl:param</code></li>
         <li><code>xsl:template</code></li>
      </ul>
      <p>
<code>xsl:stylesheet</code> 要素の子として現れる要素は <dfn id="dt-top-level">トップレベル</dfn> （ top-level ）要素と呼ばれる。

<span lang="en">
An element occurring as a child of an xsl:stylesheet element is called a top-level element.</span>
      </p>
      <p>
次の例にスタイルシートの構造を示す。
省略記号（ <code>...</code> ）は、属性値あるいは内容が省略されていることを表す。
この例では、利用可能な要素型をそれぞれ１個ずつ記述しているが、スタイルシートはこれらの要素それぞれについて、０個以上, いくつでも含み得る。
<span lang="en">
This example shows the structure of a stylesheet.
Ellipses (...) indicate where attribute values or content have been omitted.
Although this example shows one of each type of allowed element, stylesheets may contain zero or more of each of these elements.</span>
      </p>
      <pre>
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:import href="..."/&gt;

  &lt;xsl:include href="..."/&gt;

  &lt;xsl:strip-space elements="..."/&gt;
  
  &lt;xsl:preserve-space elements="..."/&gt;

  &lt;xsl:output method="..."/&gt;

  &lt;xsl:key name="..." match="..." use="..."/&gt;

  &lt;xsl:decimal-format name="..."/&gt;

  &lt;xsl:namespace-alias stylesheet-prefix="..." result-prefix="..."/&gt;

  &lt;xsl:attribute-set name="..."&gt;...&lt;/xsl:attribute-set&gt;

  &lt;xsl:variable name="..."&gt;...&lt;/xsl:variable&gt;

  &lt;xsl:param name="..."&gt;...&lt;/xsl:param&gt;

  &lt;xsl:template match="..."&gt;...&lt;/xsl:template&gt;

  &lt;xsl:template name="..."&gt;...&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
      <p>
<code>xsl:stylesheet</code> 要素の子の出現順序は、<code>xsl:import</code> 要素とエラー回復を除いて重要ではない。
スタイルシート作成者は要素を好みに合わせて自由に並べられる。
また、スタイルシート生成ツールも要素の出現順序の制御機能を提供する必要はない。

<span lang="en">
The order in which the children of the xsl:stylesheet element occur is not significant except for xsl:import elements and for error recovery.
Users are free to order the elements as they prefer, and stylesheet creation tools need not provide control over the order in which the elements occur.</span>
      </p>
      <p>
加えて, <code>xsl:stylesheet</code> 要素には、 XSLT 名前空間に属さない任意の要素も, その展開名が非 null の名前空間 URI を持つならば, 含められる。
このようなトップレベル要素が存在しても、この文書で定義された XSLT 要素と関数のふるまいが変更されてはならない。
例えば、競合解決のために異なるルールを利用する目的でトップレベル要素に <code>xsl:apply-templates</code> を指定することは許されない。
従って, XSLT プロセッサは、このようなトップレベル要素をいつでも無視してよく, その名前空間 URI を認識できない場合は、エラーを生成せずにこれらのトップレベル要素を無視しなければならない。
これらの要素は 例えば以下に挙げるデータを提供し得る。
<span lang="en">
In addition, the xsl:stylesheet element may contain any element not from the XSLT namespace, provided that the expanded-name of the element has a non-null namespace URI.
The presence of such top-level elements must not change the behavior of XSLT elements and functions defined in this document; for example, it would not be permitted for such a top-level element to specify that xsl:apply-templates was to use different rules to resolve conflicts.
Thus, an XSLT processor is always free to ignore such top-level elements, and must ignore a top-level element without giving an error if it does not recognize the namespace URI.
Such elements can provide, for example,</span>
      </p>
      <ul>
         <li>
            <p>
拡張要素や拡張関数が利用する情報（
<a href="#extension">[<b>14 拡張</b>]</a>
を見よ）
<span lang="en">
information used by extension elements or extension functions (see [14 Extensions]),</span>
            </p>
         </li>
         <li>
            <p>
結果ツリーの処理に関する情報
<span lang="en">
information about what to do with the result tree,</span>
            </p>
         </li>
         <li>
            <p>
ソースツリーの取得方法に関する情報
<span lang="en">
information about how to obtain the source tree,</span>
            </p>
         </li>
         <li>
            <p>
スタイルシートに関するメタデータ
<span lang="en">
metadata about the stylesheet,</span>
            </p>
         </li>
         <li>
            <p>
スタイルシートのための構造化された添付文書
<span lang="en">
structured documentation for the stylesheet.</span>
            </p>
         </li>
      </ul>

	</section>
	<section>

<h3 id="result-element-stylesheet" title="2.3 Literal Result Element as Stylesheet">2.3 スタイルシートとしてのリテラル結果要素</h3>
      <p>
ルートノード用のテンプレート１個だけから構成されるスタイルシートのために、簡略化された構文が用意されている。
このスタイルシートは、リテラル結果要素のみから構成されていてもよい （
<a href="#literal-result-element">[<b>7.1.1 リテラル結果要素</b>]</a>
を見よ）。
<!-- □ -->
このようなスタイルシートは、そのリテラル結果要素を含む、照合パターンが <code>/</code> のテンプレートルール１個だけからなる <code>xsl:stylesheet</code> 要素を含むスタイルシートと等価になる。
例を示す：
<span lang="en">
A simplified syntax is allowed for stylesheets that consist of only a single template for the root node.
The stylesheet may consist of just a literal result element (see [7.1.1 Literal Result Elements]).
Such a stylesheet is equivalent to a stylesheet with an xsl:stylesheet element containing a template rule containing the literal result element; the template rule has a match pattern of /.
For example</span>
      </p>
      <pre>&lt;html xsl:version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns="http://www.w3.org/TR/xhtml1/strict"&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

      <p>
これは次と同じ意味になる。
<span lang="en">
has the same meaning as</span>
      </p>

      <pre>&lt;xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns="http://www.w3.org/TR/xhtml1/strict"&gt;
&lt;xsl:template match="/"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre>


      <p>
スタイルシートの文書要素になるリテラル結果要素には、スタイルシートに要求される XSLT のバージョンを指示する <code>xsl:version</code> 属性が指定されなければならない。
このバージョンの XSLT では、属性値は <code>1.0</code> にすべきである。
この値は
<a href="xpath10-ja.html#NT-Number">Number</a>
でなければならない。
他のリテラル結果要素にも <code>xsl:version</code> 属性を指定できる。
<code>xsl:version</code> 属性の値が <code>1.0</code> 以外の場合、前方互換 (forwards-compatible) 処理モードが有効になる（
<a href="#forwards">[<b>2.5 前方互換処理</b>]</a>
を見よ）。
<span lang="en">
A literal result element that is the document element of a stylesheet must have an xsl:version attribute, which indicates the version of XSLT that the stylesheet requires.
For this version of XSLT, the value should be 1.0; the value must be a Number.
Other literal result elements may also have an xsl:version attribute.
When the xsl:version attribute is not equal to 1.0, forwards-compatible processing mode is enabled (see [2.5 Forwards-Compatible Processing]).</span>
      </p>
      <p>
スタイルシートとして用いるリテラル結果要素に許される内容は、リテラル結果要素をスタイルシート内で用いる場合と同様である。
従って、スタイルシートとして用いるリテラル結果要素の内容に
<a href="#dt-top-level">トップレベル</a>
要素を含めることはできない。
<span lang="en">
The allowed content of a literal result element when used as a stylesheet is no different from when it occurs within a stylesheet.
Thus, a literal result element used as a stylesheet cannot contain top-level elements.</span>
      </p>
      <p>
システム側が XML 文書を XSLT スタイルシートとして XSLT プロセッサに渡して処理させる必要があるかどうかを知る方法が XML 文書自体を調査するより無い状況もある。
簡略構文を用いた場合、この処理はより難しくなる。
<span lang="en">
In some situations, the only way that a system can recognize that an XML document needs to be processed by an XSLT processor as an XSLT stylesheet is by examining the XML document itself.
Using the simplified syntax makes this harder.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
例えば、別の XML 言語（ AXL とする）が、ある XML 文書に対し AXL プロセッサに処理させる必要がある AXL 文書であることを指示するために文書要素上に <code>axl:version</code> を与えている可能性がある。
同じ文書に <code>axl:version</code> 属性と <code>xsl:version</code> 属性の両者が含まれている場合、その文書を XSLT プロセッサと AXL プロセッサのどちらに処理させるべきか自明でなくなる。
<span lang="en">
NOTE:For example, another XML language (AXL) might also use an axl:version on the document element to indicate that an XML document was an AXL document that required processing by an AXL processor; if a document had both an axl:version attribute and an xsl:version attribute, it would be unclear whether the document should be processed by an XSLT processor or an AXL processor.</span>
</p>
      </blockquote>
      <p>
そのため、このような状況で利用され得る XSLT スタイルシートに簡略構文を用いるべきではない。
このような状況は、例えば XSLT スタイルシートが <code>text/xml</code> または <code>application/xml</code> の MIME メディア型を伴うメッセージとして、 MIME メディア型に基づいてメッセージの処理方法を決定する受信者側へ送信される際に生じる。
<span lang="en">
Therefore, the simplified syntax should not be used for XSLT stylesheets that may be used in such a situation.
This situation can, for example, arise when an XSLT stylesheet is transmitted as a message with a MIME media type of text/xml or application/xml to a recipient that will use the MIME media type to determine how the message is processed.</span>
      </p>

	</section>
	<section>

<h3 id="qname" title="2.4 Qualified Names">2.4 修飾名</h3>
      <p>
内部 XSLT オブジェクトの名前：特に、名前付きテンプレート（
<a href="#named-templates">[<b>6 名前付きテンプレート</b>]</a>
を見よ）, モード（
<a href="#modes">[<b>5.7 モード</b>]</a>
を見よ）, 属性集合（
<a href="#attribute-sets">[<b>7.1.4 名前付き属性の集合</b>]</a>
を見よ）, キー（
<a href="#key">[<b>12.2 キー</b>]</a>
を見よ）, 十進フォーマット（
<a href="#format-number">[<b>12.3 数値のフォーマット</b>]</a>
を見よ）, 変数, パラメタ（
<a href="#variables">[<b>11 変数とパラメタ</b>]</a>
）の名前は、
<a href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a>
<span class="trans-note">【"<b >Q</b>ualified <b >Name</b>" - 修飾名】</span>
により指定される。
名前に接頭辞がある場合、接頭辞はその名前が現れた属性に対し有効な名前空間宣言を用いて URI 参照に展開される。
名前の局所部と URI 参照（ null もあり得る）から構成される
<a href="xpath10-ja.html#dt-expanded-name">展開名</a>
（ expanded-name ）が、オブジェクトの名前として用いられる。
既定の名前空間は、接頭辞のない名前に<em>用いられない</em>。
<span lang="en">
The name of an internal XSLT object, specifically a named template (see [6 Named Templates]), a mode (see [5.7 Modes]), an attribute set (see [7.1.4 Named Attribute Sets]), a key (see [12.2 Keys]), a decimal-format (see [12.3 Number Formatting]), a variable or a parameter (see [11 Variables and Parameters]) is specified as a QName.
If it has a prefix, then the prefix is expanded into a URI reference using the namespace declarations in effect on the attribute in which the name occurs.
The expanded-name consisting of the local part of the name and the possibly null URI reference is used as the name of the object.
The default namespace is not used for unprefixed names.</span>
      </p>

	</section>
	<section>

<h3 id="forwards" title="2.5 Forwards-Compatible Processing">2.5 前方互換処理</h3>
      <p>
<code>xsl:stylesheet</code> 要素の <code>version</code> 属性の値が <code>1.0</code> 以外の場合、それ自身とその属性、およびすべての子孫とその属性に対し前方互換処理モードが有効になる。
<!-- 
<del class="errata">要素は次のいずれかの場合に該当するとき、自身とその属性、および子孫とそれらの属性に対し前方互換処理モードを有効にする：(1) <code>version</code> 属性の値が <code>1.0</code> 以外の <code>xsl:stylesheet</code> 要素のとき
, (2) リテラル結果要素であって <code>xsl:version</code> 属性を持ち、その値が <code>1.0</code> 以外の要素のとき, (3) リテラル結果要素で <code>xsl:version</code> 属性を持たず、簡略構文（
<a href="#result-element-stylesheet">[<b>2.3 スタイルシートとしてのリテラル結果要素</b>]</a>
を見よ）を利用するスタイルシートの文書要素のとき, である。</del>
 --><!-- E33 -->
ただし、リテラル結果要素が <code>xsl:version</code> 属性を持ち、その値が <code>1.0</code> の場合、それ自身とその属性、およびすべての子孫とその属性に対する前方互換処理モードは無効になる。
<span lang="en">
An element enables forwards-compatible mode for itself, its attributes, its descendants and their attributes if either it is an xsl:stylesheet element whose version attribute is not equal to 1.0
<del class="errata">, or it is a literal result element that has an xsl:version attribute whose value is not equal to 1.0, or it is a literal result element that does not have an xsl:version attribute and that is the document element of a stylesheet using the simplified syntax (see [2.3 Literal Result Element as Stylesheet])</del><!-- E33 -->.
A literal result element that has an xsl:version attribute whose value is equal to 1.0 disables forwards-compatible mode for itself, its attributes, its descendants and their attributes.</span>
      </p>
      <p>
前方互換処理モードによる要素の処理においては：
<span lang="en">
If an element is processed in forwards-compatible mode, then:</span>
      </p>
      <ul>
         <li>
            <p>
処理対象が
<a href="#dt-top-level">トップレベル</a>
要素で、 XSLT 1.0 においてトップレベル要素として利用できない要素に対しては、その要素は内容も含めて無視されなければならない。
<span lang="en">
if it is a top-level element and XSLT 1.0 does not allow such elements as top-level elements, then the element must be ignored along with its content;</span>
            </p>
         </li>
         <li>
            <p>
処理対象がテンプレート内の要素で、 XSLT 1.0 においてテンプレート内に現れてはならない要素に対しては、要素のインスタンス化を行わないのならエラーを通知してはならない。
要素のインスタンス化を行う場合、
<a href="#fallback">[<b>15 フォールバック</b>]</a>
で述べる手順により要素のフォールバック（代替）が実行されなければならない。
<span lang="en">
if it is an element in a template and XSLT 1.0 does not allow such elements to occur in templates, then if the element is not instantiated, an error must not be signaled, and if the element is instantiated, the XSLT must perform fallback for the element as specified in [15 Fallback];</span>
            </p>
         </li>
         <li>
            <p>
処理対象の要素が XSLT 1.0 で許容されない属性を持つ場合、または XSLT 1.0 では許容されない値をとるオプションの属性を持つ場合、その属性は無視されなければならない。
<span lang="en">
if the element has an attribute that XSLT 1.0 does not allow the element to have or if the element has an optional attribute with a value that the XSLT 1.0 does not allow the attribute to have, then the attribute must be ignored.</span>
            </p>
         </li>
      </ul>
      <p>
従って, 次のスタイルシートには, この仕様で定義していない XSLT 名前空間の要素が含まれているが、 XSLT 1.0 プロセッサは、このスタイルシートをエラーを生じさせずに処理できなければならない。
<span lang="en">
Thus, any XSLT 1.0 processor must be able to process the following stylesheet without error, although the stylesheet includes elements from the XSLT namespace that are not defined in this specification:</span>
      </p>
      <pre>&lt;xsl:stylesheet version="1.1"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="system-property('xsl:version') &gt;= 1.1"&gt;
        &lt;xsl:exciting-new-1.1-feature/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;html&gt;
        &lt;head&gt;
          &lt;title&gt;XSLT 1.1 required&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;p&gt;Sorry, this stylesheet requires XSLT 1.1.&lt;/p&gt;
        &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre>
      <blockquote>
<p>
<b>注記：</b>
スタイルシートが、 1.0 より後のバージョンの XSLT に導入されたトップレベル要素に決定的に依存するような場合、そのスタイルシートに <code>terminate="yes"</code> を伴う <code>xsl:message</code> 要素を用いることにより（
<a href="#message">[<b>13 メッセージ</b>]</a>
を見よ）, 前のバージョンの XSLT を実装する XSLT プロセッサがそのトップレベル要素を黙って無視しないようにさせられる。
例を示す：
         <span lang="en">
NOTE:If a stylesheet depends crucially on a top-level element introduced by a version of XSL<ins class="errata">T</ins><!-- E32 --> after 1.0, then the stylesheet can use an xsl:message element with terminate="yes" (see [13 Messages]) to ensure that XSLT processors implementing earlier versions of XSL<ins class="errata">T</ins><!-- E32 --> will not silently ignore the top-level element.
For example,</span>
</p>
  <pre>&lt;xsl:stylesheet version="1.5"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:important-new-1.1-declaration/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="system-property('xsl:version') &amp;lt; 1.1"&gt;
        &lt;xsl:message terminate="yes"&gt;
          &lt;xsl:text&gt;Sorry, this stylesheet requires XSLT 1.1.&lt;/xsl:text&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        ...
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  ...
&lt;/xsl:stylesheet&gt;</pre>
      </blockquote>
      <p>
前方互換モードで処理される属性に現れる
<a href="#dt-expression">式</a>
からエラーが生じた場合、 XSLT プロセッサは次のようにエラーを回復しなければならない：
<span lang="en">
If an expression occurs in an attribute that is processed in forwards-compatible mode, then an XSLT processor must recover from errors in the expression as follows:</span>
      </p>
      <ul>
         <li>
            <p>
その式が XPath の文法で許容される構文に一致しない場合、その式が実際に評価されない限り, エラーを通知してはならない。
<span lang="en">
if the expression does not match the syntax allowed by the XPath grammar, then an error must not be signaled unless the expression is actually evaluated;</span>
            </p>
         </li>
         <li>
            <p>
その式が XSLT ライブラリに属さない接頭辞のない名前の関数を呼び出す場合、その関数が実際に呼び出されない限り, エラーを通知してはならない。
<span lang="en">
if the expression calls a function with an unprefixed name that is not part of the XSLT library, then an error must not be signaled unless the function is actually called;</span>
            </p>
         </li>
         <li>
            <p>
その式による関数呼び出しにおいて引数の個数または引数の型が XSLT で許容されないものだった場合、その関数が実際に呼び出されない限り, エラーを通知してはならない。
<span lang="en">
if the expression calls a function with a number of arguments that XSLT does not allow or with arguments of types that XSLT does not allow, then an error must not be signaled unless the function is actually called.</span>
            </p>
         </li>
      </ul>

	</section>
	<section>

<h3 id="section-Combining-Stylesheets" title="2.6 Combining Stylesheets">2.6 スタイルシートの結合</h3>
      <p>
XSLT には、スタイルシートを結合する２種類の仕組みがある。
<span lang="en">
XSLT provides two mechanisms to combine stylesheets:</span>
      </p>
      <ul>
         <li>
<p>
結合されるスタイルシートの意味内容を変更せずに、スタイルシートの結合を可能にするインクルードの仕組み。
<span lang="en">
an inclusion mechanism that allows stylesheets to be combined without changing the semantics of the stylesheets being combined, and</span>
</p>
</li>
         <li>
<p>
スタイルシート間で相互の上書きを可能にするインポートの仕組み。
<span lang="en">
an import mechanism that allows stylesheets to override each other.</span>
</p>
</li>
      </ul>

		<section>

<h4 id="include" title="2.6.1 Stylesheet Inclusion">2.6.1 スタイルシートのインクルード</h4>
      <pre class="element-syntax" id="element-include">
&lt;!-- 分類：top-level-element --&gt;
&lt;xsl:include
  <b>href</b> = <var>uri-reference</var> /&gt;</pre>
      <p>
<code>xsl:include</code> 要素を用いることにより XSLT スタイルシートに別の XSLT スタイルシートを取り込むことができる。
<code>xsl:include</code> 要素はインクルードするスタイルシートへの URI 参照を値にとる <code>href</code> 属性を持つ。
相対 URI は <code>xsl:include</code> 要素の基底 URIを基準に解決される（
<a href="#base-uri">[<b>3.2 基底 URI</b>]</a>
を見よ）。
<span lang="en">
An XSLT stylesheet may include another XSLT stylesheet using an xsl:include element.
The xsl:include element has an href attribute whose value is a URI reference identifying the stylesheet to be included.
A relative URI is resolved relative to the base URI of the xsl:include element (see [3.2 Base URI]).</span>
      </p>
      <p>
<code>xsl:include</code> 要素は
<a href="#dt-top-level">トップレベル</a>
要素としてのみ利用できる。
<span lang="en">
The xsl:include element is only allowed as a top-level element.</span>
      </p>
      <p>
このインクルード処理は XML のツリーレベルで働く。
<code>href</code> 属性の値から位置が特定されたリソースは、 XML 文書として構文解析され、インクルードする側の <code>xsl:include</code> 要素は, その XML 文書の <code>xsl:stylesheet</code> 要素の子たちに置換される。
テンプレートルールや定義が取り込まれても、この処理のされ方には影響しない。
<span lang="en">
The inclusion works at the XML tree level.
The resource located by the href attribute value is parsed as an XML document, and the children of the xsl:stylesheet element in this document replace the xsl:include element in the including document.
The fact that template rules or definitions are included does not affect the way they are processed.</span>
      </p>
      <p>
インクルードされるスタイルシートに
<a href="#result-element-stylesheet">[<b>2.3 スタイルシートとしてのリテラル結果要素</b>]</a>
で述べた簡略構文が用いられていてもよい。
この場合、等価な <code>xsl:stylesheet</code> 要素として扱われる。
<span lang="en">
The included stylesheet may use the simplified syntax described in [2.3 Literal Result Element as Stylesheet].
The included stylesheet is treated the same as the equivalent xsl:stylesheet element.</span>
      </p>
      <p>
スタイルシートが自身を直接的に, または間接的にインクルードしている場合、エラーとする。
<span lang="en">
It is an error if a stylesheet directly or indirectly includes itself.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
同じスタイルシートが複数回インクルードされる場合、定義の重複によりエラーが生じる可能性がある。
インクルードが間接的だった場合、このような重複は見分け難くなる。
例えば、２つのスタイルシート <var>B</var>, <var>C</var> が同じスタイルシート <var>A</var> をインクルードしているとき、スタイルシート <var>D</var> が <var>B</var>, <var>C</var> の両方をインクルードすると、 <var>A</var> が <var>D</var> から間接的に二重にインクルードされることになる。

この場合、 <var>B</var>, <var>C</var>, <var>D</var> のいずれも独立にスタイルシートとして利用されている状況であれば、 <var>A</var> のインクルードを除くすべての <var>B</var> の内容を別のスタイルシート <var>B'</var> に分離し、 <var>B</var> については <var>B'</var> と <var>A</var> をインクルードする形に変更し、 <var>C</var> についても同様に <var>C'</var> に分離し、 <var>D</var> が <var>A</var>, <var>B'</var>, <var>C'</var> をインクルードする形に変更することで、エラーを回避できる。
<span lang="en">
NOTE:Including a stylesheet multiple times can cause errors because of duplicate definitions.
Such multiple inclusions are less obvious when they are indirect.
For example, if stylesheet B includes stylesheet A, stylesheet C includes stylesheet A, and stylesheet D includes both stylesheet B and stylesheet C, then A will be included indirectly by D twice.
If all of B, C and D are used as independent stylesheets, then the error can be avoided by separating everything in B other than the inclusion of A into a separate stylesheet B' and changing B to contain just inclusions of B' and A, similarly for C, and then changing D to include A, B', C'.</span>
</p>
      </blockquote>

		</section>
		<section>

<h4 id="import" title="2.6.2 Stylesheet Import">2.6.2 スタイルシートのインポート</h4>
      <pre class="element-syntax" id="element-import">
&lt;xsl:import
  <b>href</b> = <var>uri-reference</var> /&gt;</pre>
      <p>
<code>xsl:import</code> 要素を用いて別の XSLT スタイルシートを XSLT スタイルシートにインポートすることができる。
スタイルシートのインポートはスタイルシートのインクルード（
<a href="#include">[<b>2.6.1 スタイルシートのインクルード</b>]</a>
を見よ）と似ているが、インポートする側のスタイルシートに含まれる定義とテンプレートルールが、インポートされる側のスタイルシートに含まれる定義とテンプレートルールより優先される点が異なる。
下でより詳細に述べる。

<code>xsl:import</code> 要素はインポートするスタイルシートへの URI 参照を値にとる <code>href</code> 属性を持つ。
相対 URI は <code>xsl:import</code> 要素の基底 URIを基準に解決される（
<a href="#base-uri">[<b>3.2 基底 URI</b>]</a>
を見よ）。
<span lang="en">
An XSLT stylesheet may import another XSLT stylesheet using an xsl:import element.
Importing a stylesheet is the same as including it (see [2.6.1 Stylesheet Inclusion]) except that definitions and template rules in the importing stylesheet take precedence over template rules and definitions in the imported stylesheet; this is described in more detail below.
The xsl:import element has an href attribute whose value is a URI reference identifying the stylesheet to be imported.
A relative URI is resolved relative to the base URI of the xsl:import element (see [3.2 Base URI]).</span>
      </p>
      <p>
<code>xsl:import</code> 要素は
<a href="#dt-top-level">トップレベル</a>
要素としてのみ利用できる。
<code>xsl:import</code> 要素は、 <code>xsl:include</code> 要素も含め、 <code>xsl:stylesheet</code> 要素のすべての子よりも前に置かれなければならない。
<code>xsl:include</code> でスタイルシートをインクルードした場合、インクルードされる文書内の <code>xsl:import</code> 要素はすべて、インクルードする側の文書内に既存のすべての <code>xsl:import</code> 要素の後方に移動される。
<!-- □ -->
<span lang="en">
The xsl:import element is only allowed as a top-level element.
The xsl:import element children must precede all other element children of an xsl:stylesheet element, including any xsl:include element children.
When xsl:include is used to include a stylesheet, any xsl:import elements in the included document are moved up in the including document to after any existing xsl:import elements in the including document.</span>
      </p>
      <p>
例えば：
<span lang="en">
For example,</span>
      </p>
      <pre>
&lt;xsl:stylesheet version="1.0"
          xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="article.xsl"/&gt;
  &lt;xsl:import href="bigfont.xsl"/&gt;
  &lt;xsl:attribute-set name="note-style"&gt;
    &lt;xsl:attribute name="font-style"&gt;italic&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;
&lt;/xsl:stylesheet&gt;</pre>
      <p>
 <dfn id="dt-import-precedence">インポート優先順位</dfn> は次の様にして決定される：まず、 <code>xsl:import</code> 要素を含むスタイルシートの処理に出現したすべての <code>xsl:stylesheet</code> 要素が、１個の <dfn id="dt-import-tree">インポートツリー</dfn> をなすものとして扱われる。
インポートツリーにおいては、各 <code>xsl:stylesheet</code> 要素が、それに含まれる <code>xsl:import</code> 要素ごとに１個のインポートを子に持つものとする。
ここで <code>xsl:include</code> 要素はすべて、このインポートツリーの構築前に解決される。
インポートツリー内の <code>xsl:stylesheet</code> 要素 A が、インポートツリーの後順走査（ postorder - すなわち、ツリーの親はその子より後に訪れられる）において、別の <code>xsl:stylesheet</code> 要素 B よりも先に訪れられるならば、 A は B より優先順位が低いものと定義する。
インポートにおけるそれぞれの定義とテンプレートルールの優先順位は、それらを含む <code>xsl:stylesheet</code> 要素の順位により決定されるものとする。
<span lang="en">
The xsl:stylesheet elements encountered during processing of a stylesheet that contains xsl:import elements are treated as forming an import tree.
In the import tree, each xsl:stylesheet element has one import child for each xsl:import element that it contains.
Any xsl:include elements are resolved before constructing the import tree.
An xsl:stylesheet element in the import tree is defined to have lower import precedence than another xsl:stylesheet element in the import tree if it would be visited before that xsl:stylesheet element in a post-order traversal of the import tree (i.e.
a traversal of the import tree in which an xsl:stylesheet element is visited after its import children).
Each definition and template rule has import precedence determined by the xsl:stylesheet element that contains it.</span>
      </p>
      <p>
次のような場合を想定する：
<span lang="en">
For example, suppose</span>
      </p>
      <ul>
         <li>
            <p>
スタイルシート <var>A</var> がスタイルシート <var>B</var> と <var>C</var> をこの順序でインポートし、
<span lang="en">
stylesheet A imports stylesheets B and C in that order;</span>
            </p>
         </li>
         <li>
            <p>
スタイルシート <var>B</var> がスタイルシート <var>D</var> をインポートし、
<span lang="en">
stylesheet B imports stylesheet D;</span>
            </p>
         </li>
         <li>
            <p>
スタイルシート <var>C</var> がスタイルシート <var>E</var> をインポートする。
<span lang="en">
stylesheet C imports stylesheet E.</span>
            </p>
         </li>
      </ul>
      <p>
この場合、インポート優先順位は、低い側から <var>D</var>, <var>B</var>, <var>E</var>, <var>C</var>, <var>A</var> になる。
<span lang="en">
Then the order of import precedence (lowest first) is D, B, E, C, A.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
<code>xsl:import</code> 要素は、すべての定義とテンプレートより前に現れなくてはならないため、 <code>xsl:import</code> 要素に遭遇した時点でインポートされるスタイルシートを処理する実装は、インポート優先順位が低い方から先に、定義とテンプレートに遭遇することになる。
<span lang="en">
NOTE:Since xsl:import elements are required to occur before any definitions or template rules, an implementation that processes imported stylesheets at the point at which it encounters the xsl:import element will encounter definitions and template rules in increasing order of import precedence.</span>
</p>
      </blockquote>
      <p>
一般に、インポート優先順位が高い定義やテンプレートルールがインポート優先順位の低い定義やテンプレートルールよりも優先される。
より詳細は各種定義と各種テンプレートルールの項で定義される。
<span lang="en">
In general, a definition or template rule with higher import precedence takes precedence over a definition or template rule with lower import precedence.
This is defined in detail for each kind of definition and for template rules.</span>
      </p>
      <p>
スタイルシートが自身を直接的に, または間接的にインポートしている場合、エラーとする。
他の場合、同じ URI のスタイルシートが複数の場所からインポートされても特別に扱われない。
<a href="#dt-import-tree">インポートツリー</a>
は、スタイルシートがインポートされた場所ごとに, 別々の <code>xsl:stylesheet</code> を持つ。
<span lang="en">
It is an error if a stylesheet directly or indirectly imports itself.
Apart from this, the case where a stylesheet with a particular URI is imported in multiple places is not treated specially.
The import tree will have a separate xsl:stylesheet for each place that it is imported.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
<code>xsl:apply-imports</code> が用いられた場合（
<a href="#apply-imports">[<b>5.6 テンプレートルールの上書き</b>]</a>
を見よ）、そのふるまいは、スタイルシートが
<a href="#dt-import-precedence">インポート優先順位</a>
が最高になる場所<em>のみ</em>からインポートされた場合のふるまいと異なり得る。
<span lang="en">
NOTE:If xsl:apply-imports is used (see [5.6 Overriding Template Rules]), the behavior may be different from the behavior if the stylesheet had been imported only at the place with the highest import precedence.</span>
</p>
      </blockquote>

		</section>
	</section>
	<section>

<h3 id="section-Embedding-Stylesheets" title="2.7 Embedding Stylesheets">2.7 スタイルシートの埋め込み</h3>
      <p>
通常, XSLT スタイルシートは、 <code>xsl:stylesheet</code> 要素を文書要素として持つ完全な XML 文書である。
しかしながら、他のリソースに XSLT スタイルシートを埋め込むこともできる。
スタイルシートの埋め込みには次の２つの形式がある：
<span lang="en">
Normally an XSLT stylesheet is a complete XML document with the xsl:stylesheet element as the document element.
However, an XSLT stylesheet may also be embedded in another resource.
Two forms of embedding are possible:</span>
      </p>
      <ul>
         <li>
<p>
XSLT スタイルシートが XML 以外のリソースにテキストのままの状態で埋め込まれる形式。
または、
<span lang="en">
the XSLT stylesheet may be textually embedded in a non-XML resource, or</span>
</p></li>
         <li>
<p>
<code>xsl:stylesheet</code> 要素が、文書要素以外の形で XML 文書内に現れる形式。
<span lang="en">
the <code>xsl:stylesheet</code> element may occur in an XML document other than as the document element.</span>
</p></li>
      </ul>
      <p>
２つ目の形式による埋め込みを容易にするため、 <code>xsl:stylesheet</code> 要素には、一意的な識別子を指定する ID 型の属性が許容されている。
<span lang="en">
To facilitate the second form of embedding, the xsl:stylesheet element is allowed to have an ID attribute that specifies a unique identifier.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
このような ID 型の属性を XPath の
<b><a href="xpath10-ja.html#function-id">id</a></b>
関数と伴に利用できるようにするためには、この属性が ID 型として DTD 内で実際に宣言されていなければならない。
<span lang="en">
NOTE:In order for such an attribute to be used with the XPath id function, it must actually be declared in the DTD as being an ID.</span>
</p>
      </blockquote>
      <p>
下に、文書に独自のスタイルシートを含められるようにする処理命令 <code>xml-stylesheet</code>
<a href="#XMLSTYLE">[XML Stylesheet]</a>
の用例を示す。
URI 参照には <code>xsl:stylesheet</code> 要素の位置を特定する素片識別子が付加された相対 URI が用いられる。
<span lang="en">
The following example shows how the xml-stylesheet processing instruction [XML Stylesheet] can be used to allow a document to contain its own stylesheet.
The URI reference uses a relative URI with a fragment identifier to locate the xsl:stylesheet element:</span>
      </p>
      <pre>&lt;?xml-stylesheet type="text/xml" href="#style1"?&gt;
&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
&lt;head&gt;
&lt;xsl:stylesheet id="style1"
        version="1.0"
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
&lt;xsl:import href="doc.xsl"/&gt;
&lt;xsl:template match="id('foo')"&gt;
  &lt;fo:block font-weight="bold"&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="xsl:stylesheet"&gt;
  &lt;!-- ignore --&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;para id="foo"&gt;
...
&lt;/para&gt;
&lt;/body&gt;
&lt;/doc&gt;</pre>
      <blockquote>
<p>
<b>注記：</b>
文書に文書自身を適用対象にするスタイルシートを埋め込む場合、またはそのようなスタイルシートからインクルードあるいはインポートされ得るスタイルシートには、通常, <code>xsl:stylesheet</code> 要素が無視されるようなテンプレートルールを含めておく必要がある。
<span lang="en">
NOTE:A stylesheet that is embedded in the document to which it is to be applied or that may be included or imported into a<!--E31 n --> stylesheet that is so embedded typically needs to contain a template rule that specifies that xsl:stylesheet elements are to be ignored.</span>
</p>
      </blockquote>

	</section>
</section>
<section>

<h2 id="data-model" title="3 Data Model">3 データモデル</h2>
      <p>
XSLT で利用されるデータモデルは、
<a href="xpath10-ja.html#data-model">XPath</a>
で利用されるデータモデルと同じデータモデルに, この節で述べるデータモデルを追加したものになる。
XSLT は、ソース文書, 結果文書, スタイルシート文書 に対し、同一のデータモデルを用いて処理を行う。
同じツリーを持つ２つの XML 文書は XSLT からは同等に扱われることになる。
<span lang="en">
The data model used by XSLT is the same as that used by XPath with the additions described in this section.
XSLT operates on source, result and stylesheet documents using the same data model.
Any two XML documents that have the same tree will be treated the same by XSLT.</span>
      </p>
      <p>
スタイルシート内の処理命令とコメントは無視される：処理命令ノードとコメントノードのいずれもスタイルシートを表現するツリー内に含まれなかったかのように扱われる。
<span lang="en">
Processing instructions and comments in the stylesheet are ignored: the stylesheet is treated as if neither processing instruction nodes nor comment nodes were included in the tree that represents the stylesheet.</span>
      </p>

	<section>

<h3 id="root-node-children" title="3.1 Root Node Children">3.1 ルートノードの子</h3>
      <p>
ルートノードの子に関する通常時の制約は、結果ツリーにおいては緩和される。
結果ツリーは、要素ノードに可能な任意のノードの並びを子として持ち得る。
特に、結果ツリーには任意の子テキストノードや任意個数の子要素ノードを含められる。
XML 出力メソッド（
<a href="#output">[<b>16 出力</b>]</a>
を見よ）を用いて書き出される場合、結果ツリーが整形式 XML 文書にならない可能性もあるが、その場合でも, 結果ツリーは常に整形式の外部一般解析対象実体になる。
<span lang="en">
The normal restrictions on the children of the root node are relaxed for the result tree.
The result tree may have any sequence of nodes as children that would be possible for an element node.
In particular, it may have text node children, and any number of element node children.
When written out using the XML output method (see [16 Output]), it is possible that a result tree will not be a well-formed XML document; however, it will always be a well-formed external general parsed entity.</span>
      </p>
      <p>
整形式 XML 文書の構文解析により生成される, ソースツリーのルートノードは、子テキストノードを持たず, 子要素を１個だけ持つ という通常時の制約を自動的に満たす。
DOM の利用など、ソースツリーが他の方法から生成される場合、結果ツリーの場合と同様に, ソースツリーに対しても通常時の制約が緩和される。
<span lang="en">
When the source tree is created by parsing a well-formed XML document, the root node of the source tree will automatically satisfy the normal restrictions of having no text node children and exactly one element child.
When the source tree is created in some other way, for example by using the DOM, the usual restrictions are relaxed for the source tree as for the result tree.</span>
      </p>

	</section>
	<section>

<h3 id="base-uri" title="3.2 Base URI">3.2 基底 URI</h3>
      <p>
各ノードには基底 URI と呼ばれる URI が結びつけられる。
基底 URI は属性値の相対 URI を絶対 URI に解決するために利用される。
要素または処理命令が外部実体に現れた場合、その要素や処理命令の基底 URI は、その外部実体の URI になる。
他の場合、文書の基底 URI が基底 URI になる。
文書ノードの基底 URI は文書実体の URI になる。
テキストノード, コメントノード, 属性ノード, 名前空間ノードの基底 URI は、各ノードの親の基底 URI になる。
<span lang="en">
Every node also has an associated URI called its base URI, which is used for resolving attribute values that represent relative URIs into absolute URIs.
If an element or processing instruction occurs in an external entity, the base URI of that element or processing instruction is the URI of the external entity; otherwise, the base URI is the base URI of the document.
The base URI of the document node is the URI of the document entity.
The base URI for a text node, a comment node, an attribute node or a namespace node is the base URI of the parent of the node.</span>
      </p>

	</section>
	<section>

<h3 id="unparsed-entities" title="3.3 Unparsed Entities">3.3 解析対象外実体</h3>
      <p>
ルートノードは、文書の DTD で宣言された解析対象外実体のそれぞれを URI に対応付ける情報を持つ。
URI は実体宣言内で指定されたシステム識別子および公開識別子から生成される。
XSLT プロセッサは、システム識別子に指定された URI の代わりに、公開識別子を用いて実体の URI を生成してもよい。
XSLT プロセッサは、 URI 生成に公開識別子を利用しない場合、システム識別子を利用しなければならない。
システム識別子が相対 URI だった場合、実体宣言を含むリソースの URI を基底 URI
<a href="#RFC2396">[RFC2396]</a>
として、相対 URI を絶対 URI に解決しなければならない。
<span lang="en">
The root node has a mapping that gives the URI for each unparsed entity declared in the document's DTD.
The URI is generated from the system identifier and public identifier specified in the entity declaration.
The XSLT processor may use the public identifier to generate a URI for the entity instead of the URI specified in the system identifier.
If the XSLT processor does not use the public identifier to generate the URI, it must use the system identifier; if the system identifier is a relative URI, it must be resolved into an absolute URI using the URI of the resource containing the entity declaration as the base URI [RFC2396].</span>
      </p>

	</section>
	<section>

<h3 id="strip" title="3.4 Whitespace Stripping">3.4 空白の削除</h3>
      <p>
ソース文書やスタイルシート文書のツリーが構築された後、 XSLT により他の処理が行われる前に、一部のテキストノードは削除される。
削除され得るテキストノードは空白文字のみからなるものに限られる。
削除されるテキストノードはツリーから取り除かれる。
削除処理においては、空白が保持されなければならない要素名の集合（以下、「空白保持要素名の集合」）が入力に与えられる。
削除処理はスタイルシートとソース文書の両方に適用されるが、空白保持要素名の集合は、スタイルシートとソース文書のそれぞれについて別々に決定される。
<span lang="en">
After the tree for a source document or stylesheet document has been constructed, but before it is otherwise processed by XSLT, some text nodes are stripped.
A text node is never stripped unless it contains only whitespace characters.
Stripping the text node removes the text node from the tree.
The stripping process takes as input a set of element names for which whitespace must be preserved.
The stripping process is applied to both stylesheets and source documents, but the set of whitespace-preserving element names is determined differently for stylesheets and for source documents.</span>
      </p>
      <p>
下記のいずれかに該当するテキストノードのみが保持される。
<span lang="en">
A text node is preserved if any of the following apply:</span>
      </p>
      <ul>
         <li>
            <p>
テキストノードの親の要素名が、空白保持要素名の集合に含まれる。
<span lang="en">
The element name of the parent of the text node is in the set of whitespace-preserving element names.</span>
            </p>
         </li>
         <li>
            <p>
テキストノードに空白以外の文字が１個以上含まれている。
XML における空白文字は #x20, #x9, #xD, #xA である。
<span lang="en">
The text node contains at least one non-whitespace character.
As in XML, a whitespace character is #x20, #x9, #xD or #xA.</span>
            </p>
         </li>
         <li>
            <p>
テキストノードの先祖要素の中で <code>xml:space</code> 属性が与えられたものがあり、それらのうち最も近い先祖の <code>xml:space</code> 属性の値が <code>preserve</code> である。
<span lang="en">
An ancestor element of the text node has an xml:space attribute with a value of preserve, and no closer ancestor element has xml:space with a value of default.</span>
            </p>
         </li>
      </ul>
      <p>
これら以外のテキストノードは削除される。
<span lang="en">
Otherwise, the text node is stripped.</span>
      </p>
      <p>
<code>xml:space</code> 属性はツリーから削除されない。
<span lang="en">
The xml:space attributes are not stripped from the tree.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
これにより、リテラル結果要素に指定された <code>xml:space</code> 属性は結果にも含まれることになる。
<span lang="en">
NOTE:This implies that if an xml:space attribute is specified on a literal result element, it will be included in the result.</span>
</p>
      </blockquote>
      <p>
スタイルシートに対する空白保持要素名の集合は <code>xsl:text</code> のみからなる。
<span lang="en">
For stylesheets, the set of whitespace-preserving element names consists of just xsl:text.</span>
      </p>
      <pre class="element-syntax" id="element-strip-space">
&lt;!-- 分類：top-level-element --&gt;
&lt;xsl:strip-space
  <b>elements</b> = <var>tokens</var> /&gt;</pre>
      <pre class="element-syntax" id="element-preserve-space">
&lt;!-- 分類：top-level-element --&gt;
&lt;xsl:preserve-space
  <b>elements</b> = <var>tokens</var> /&gt;</pre>
      <p>
ソース文書に対する空白保持要素名の集合は
<a href="#dt-top-level">トップレベル</a>
要素の <code>xsl:strip-space</code> と <code>xsl:preserve-space</code> により指定される。

<!-- 
<del class="errata">これらの要素はそれぞれ、空白区切りの
<a href="xpath10-ja.html#NT-NameTest">NameTest</a>
のリストを値にとる <code>elements</code> 属性を持つ。
初期状態ではすべての要素名が空白保持要素名の集合に含まれる。
<code>xsl:strip-space</code> 要素内のいずれかの
<a href="xpath10-ja.html#NT-NameTest">NameTest</a>
に合致する要素名は、空白保持要素名の集合から取り除かれる。
<code>xsl:preserve-space</code> 要素内のいずれかの
<a href="xpath10-ja.html#NT-NameTest">NameTest</a>
に合致する要素名は、空白保持要素名の集合に追加される。
要素は
<a href="xpath10-ja.html#NT-NameTest">NameTest</a>
が
<a href="xpath10-ja.html#node-tests">XPath のノードテスト</a>
により真と評価される場合、そのときに限り
<a href="xpath10-ja.html#NT-NameTest">NameTest</a>
に合致するものとする。
<code>xsl:strip-space</code> 要素と <code>xsl:preserve-space</code> 要素との間で照合の結果が競合する場合、テンプレートルール競合時と同じ方法で解決される（
<a href="#conflict">[<b>5.5 テンプレートルールの競合解決</b>]</a>
を見よ）。
従って、特定の要素名に対して適用可能な照合結果は次のようにして決定される。
</del>
 -->

<ins class="errata">
要素名が空白保持要素名の集合に入るかどうかは
<code>xsl:strip-space</code> 要素または <code>xsl:preserve-space</code> 要素の中で「最適に合致」するものから定まる：
合致するものが存在しない, または <code>xsl:preserve-space</code> 要素の中で最適に合致するときに限り、要素名は空白保持要素名の集合に入るものとする。
これらの <code>xsl:strip-space</code> 要素と <code>xsl:preserve-space</code> 要素はそれぞれ、空白区切りの
<a href="xpath10-ja.html#NT-NameTest">NameTest</a>
のリストを値にとる <code>elements</code> 属性を持つ。
要素名はいずれかの
<a href="xpath10-ja.html#NT-NameTest">NameTest</a>
に合致するときに限り、 <code>xsl:strip-space</code> または <code>xsl:preserve-space</code> 要素に合致するものとする。
要素は
<a href="xpath10-ja.html#node-tests">XPath のノードテスト</a>
により
<a href="xpath10-ja.html#NT-NameTest">NameTest</a>
が真と評価されるときに限り、
<a href="xpath10-ja.html#NT-NameTest">NameTest</a>
に合致するものとする。
複数の <code>xsl:strip-space</code> や <code>xsl:preserve-space</code> 要素に合致する場合、最適な合致は
<a href="xpath10-ja.html#NT-NameTest">NameTest</a>
に最適に合致するものから決定されるものとする。
この決定はテンプレートルールの場合と同じ方法で解決される：
</ins><!-- E30 -->
<span lang="en">
For source documents, the set of whitespace-preserving element names is specified by xsl:strip-space and xsl:preserve-spacetop-level elements.

<del class="errata">These elements each have an elements attribute whose value is a whitespace-separated list of NameTests.
Initially, the set of whitespace-preserving element names contains all element names.
If an element name matches a NameTest in an xsl:strip-space element, then it is removed from the set of whitespace-preserving element names.
If an element name matches a NameTest in an xsl:preserve-space element, then it is added to the set of whitespace-preserving element names.
An element matches a NameTest if and only if the NameTest would be true for the element as an XPath node test.
Conflicts between matches to xsl:strip-space and xsl:preserve-space elements are resolved the same way as conflicts between template rules (see [5.5 Conflict Resolution for Template Rules]).
Thus, the applicable match for a particular element name is determined as follows:</del>

<ins class="errata">
Whether an element name is included in the set of whitespace-preserving names is determined by the best match amongst xsl:strip-space or xsl:preserve-space elements: it is included if and only if there is no match or the best match is an xsl:preserve-space element.
These  The xsl:strip-space and xsl:preserve-space elements each have an elements attribute whose value is a whitespace-separated list of NameTests; an element name matches an xsl:strip-space or xsl:preserve-space  element if it matches one of the NameTests.
An element matches a NameTest if and only if the NameTest would be true for the element as an XPath node test.
When more than one xsl:strip-space and xsl:preserve-space element matches, the best matching element is determined by the best matching NameTest.
This is determined in the same way as with template rules:
</ins><!-- E30 -->
</span>
      </p>

      <ul>
         <li>
            <p>
まず、他の合致より
<a href="#dt-import-precedence">インポート優先順位</a>
が低い合致は無視される。
<span lang="en">
First, any match with lower import precedence than another match is ignored.</span>
            </p>
         </li>
         <li>
            <p>
次に、合致<!-- 
<del class="errata">
に用いられた
<a href="xpath10-ja.html#NT-NameTest">NameTest</a>
</del> -->の
<a href="#dt-default-priority">既定の優先度</a>
が、他の合致<!-- 
<del class="errata">
に用いられた
<a href="xpath10-ja.html#NT-NameTest">NameTest</a>
</del> --><!-- E30 -->の
<a href="#dt-default-priority">既定の優先度</a>
より低いものは無視される。
<span lang="en">
Next, any match 
<del class="errata">with a NameTest </del>
that has a lower default priority than the default priority 
<del class="errata">of the NameTest </del><!-- E30 -->
of another match is ignored.</span>
            </p>
         </li>
      </ul>
      <p>
この判定後にも複数の合致が残る場合、エラーとする。
XSLT プロセッサはエラーを通知してもよい。
エラーを通知しない場合、判定後に残った合致からスタイルシートの最後方に現れるものを選択し, エラーから回復しなければならない。
<span lang="en">
It is an error if this leaves more than one match.
An XSLT processor may signal the error; if it does not signal the error, it must recover by choosing, from amongst the matches that are left, the one that occurs last in the stylesheet.</span>
      </p>

	</section>
	<section>

<div class="errata"><!-- E38 -->
<h3 id="3-5" title="3.5">3.5</h3>

<p>
データモデルは（
<a href="http://www.w3.org/TR/1999/REC-xslt-19991116#XML">[XML]</a>
と
<a href="http://www.w3.org/TR/1999/REC-xslt-19991116#XMLNAMES">[XML Names]</a>
に適合する） XML 1.0 文書または（
<a href="#XML11">[XML 1.1]</a>
と
<a href="#XMLNames11">[XML Names 1.1]</a>
に適合する）XML 1.1 文書のいずれも表現し得るものであり、この２つに対する区別は付けない。
従って、原理的には XSLT 1.0 はこれらの XML バージョンのいずれにも利用できる。
唯一、相違が生じ得るのは変換の本質から離れた部分からになる：
テキストの XML からデータモデルを作成する際（構文解析）、あるいはデータモデルからテキストの XML を生成する際（直列化）。
<span lang="en">
The data model is capable of representing either an XML 1.0 document (conforming to [XML]  and [XML Names]) or an XML 1.1 document (conforming to [XML 1.1] and [XML Names 1.1]), and it makes no distinction between the two.
In principle, therefore, XSLT 1.0 can be used with either of these XML versions; the only differences arise outside the boundary of the transformation proper, either while creating the data model from textual XML (parsing), or while producing textual XML from the data model (serialization).</span>
</p>

<p>
データモデルの構築はこの仕様の範囲外であり、 XSLT 1.0 においては XSLT プロセッサに対し、 XML 1.0 文書か XML 1.1 文書のいずれか, または両方からの入力に対する受容に関し、公式的な要件は課せられない。
この仕様は XML 1.0 と XML 1.1 文書の出力能力を定める（
<a href="#output">16 出力</a>
を見よ）。
これについても, XSLT プロセッサに対し、いずれの XML のバージョンをサポートするかについての要件は課せられない。
<span lang="en">
Construction of the data model is outside the scope of this specification, so XSLT 1.0 places no formal requirements on an XSLT processor to accept input from either XML 1.0 documents or XML 1.1 documents or both.
This specification defines capability to output XML 1.0 or XML 1.1 documents (16 Output).
There is again no formal requirement on an XSLT processor to support either or both of these XML versions.
</span>
</p>

<p>
元の文書が XML 1.0 か XML 1.1 かに関わらず、データモデルは同じなので、 XSLT 処理の意味内容は元の文書に利用される XML のバージョンには依存しない。
原則的に、一つの変換に用いられる入出力文書すべてが同じバージョンの XML に適合しなければならない理由は存在しない。
<span lang="en">
Because the data model is the same whether the original document was XML 1.0 or XML 1.1, the semantics of XSLT processing do not depend on the version of XML used by the original document.
There is no reason in principle why all the input and output documents used in a single transformation must conform to the same version of XML.
</span>
</p>

</div>

	</section>
</section>
<section>

<h2 id="section-Expressions" title="4 Expressions">4 式</h2>
      <p>
XSLT は、 XPath
<a href="#XPATH">[XPath]</a>
で定義される式言語を利用する。
XSLT では、以下の例も含め, 様々な用途に式を利用する。
<span lang="en">
XSLT uses the expression language defined by XPath [XPath].
Expressions are used in XSLT for a variety of purposes including:</span>
      </p>

      <ul>
         <li>
<p>
処理対象ノードの選択
<span lang="en">
selecting nodes for processing;</span>
</p>
</li>
         <li>
<p>
ノードを別々の方法で処理するための条件の指定
<span lang="en">
specifying conditions for different ways of processing a node;</span>
</p>
</li>
         <li>
<p>
結果ツリー内に挿入するテキストの生成
<span lang="en">
generating text to be inserted in the result tree.</span>
</p>
</li>
      </ul>
      <p>
 <dfn id="dt-expression">式</dfn> は、 XPath の生成規則
<a href="xpath10-ja.html#NT-Expr">Expr</a>
に合致しなければならない。
<span lang="en">
An expression must match the XPath production Expr.</span>
      </p>
      <p>
式は、 XSLT で定義する要素の一部の属性に与える値として, あるいは
<a href="#dt-attribute-value-template">属性値テンプレート</a>
の中で波括弧（ {} ）で括られた中に生じ得る。
<span lang="en">
Expressions occur as the value of certain attributes on XSLT-defined elements and within curly braces in attribute value templates.</span>
      </p>
      <p>
XSLT では, 最も外側の式（すなわち、他の式の一部でない式）の文脈（ context ）は次のように取得される：
<span lang="en">
In XSLT, an outermost expression (i.e. an expression that is not part of another expression) gets its context as follows:</span>
      </p>
      <ul>
         <li>
            <p>
<a href="#dt-current-node">現在のノード</a>
が文脈ノードになる。
               <span lang="en">
the context node comes from the current node</span>
            </p>
         </li>
         <li>
            <p>
<a href="#dt-current-node-list">現在のノードリスト</a>
に含まれる
<a href="#dt-current-node">現在のノード</a>
の位置が文脈位置になる。
最初の位置は 1 になる。
<span lang="en">
the context position comes from the position of the current node in the current node list; the first position is 1</span>
            </p>
         </li>
         <li>
            <p>
<a href="#dt-current-node-list">現在のノードリスト</a>
のサイズが文脈サイズになる。
               <span lang="en">
the context size comes from the size of the current node list</span>
            </p>
         </li>
         <li>
            <p>
変数束縛は、式が現れる属性を持つ要素のスコープに入るものからなる（
<a href="#variables">[<b>11 変数とパラメタ</b>]</a>
を見よ）。
<!-- □ -->
<span lang="en">
the variable bindings are the bindings in scope on the element which has the attribute in which the expression occurs (see [11 Variables and Parameters])</span>
            </p>
         </li>
         <li>
            <p>
名前空間宣言の集合は、式が現れる属性を持つ要素のスコープに入るもの（要素に有効な名前空間宣言）と同じになる。
この集合には XML 名前空間勧告
<a href="#XMLNAMES">[XML Names]</a>
から要求される暗黙の接頭辞 <code>xml</code> の宣言も含まれる。
既定の名前空間（ <code>xmlns</code> で宣言されたもの）はこの集合に属さない。
<span lang="en">
the set of namespace declarations are those in scope on the element which has the attribute in which the expression occurs; this includes the implicit declaration of the prefix xml required by the the XML Namespaces Recommendation [XML Names]; the default namespace (as declared by xmlns) is not part of this set</span>
            </p>
         </li>
         <li>
            <p>
関数ライブラリは、コア関数ライブラリ, 追加の関数（
<a href="#add-func">[<b>12 追加の関数</b>]</a>
を見よ）, 拡張関数（
<a href="#extension">[<b>14 拡張</b>]</a>
を見よ）から構成される。
これら以外の関数呼び出しを含む式はエラーとする。
<span lang="en">
the function library consists of the core function library together with the additional functions defined in [12 Additional Functions] and extension functions as described in [14 Extensions]; it is an error for an expression to include a call to any other function</span>
            </p>
         </li>
      </ul>

</section>
<section>

<h2 id="rules" title="5 Template Rules">5 テンプレートルール</h2>

	<section>

<h3 id="section-Processing-Model" title="5.1 Processing Model">5.1 処理モデル</h3>
      <p>
結果ツリー素片を生成するため、ソースノードのリストが処理される。
結果ツリーは、ルートノードのみを含むリストの処理から構築される。
ソースノードのリストは、リスト内の各ノードを順に処理して生成された結果を, ツリー構造に追加していく形で処理される。
それぞれのノードの処理は、すべてのテンプレートルールからそのノードに合致するパターンを持つものを検索し, その中から最適なテンプレートルールを選択する所から始められる。
選択されたルールのテンプレートは、ノードを
<a href="#dt-current-node">現在のノード</a>
に, ソースノードのリストを
<a href="#dt-current-node-list">現在のノードリスト</a>
に設定して、インスタンス化が行われる。
通常、テンプレートには処理の対象になる追加のソースノードのリストを選択する命令が含まれている。
この 合致照合, インスタンス化, 選択の処理行程 が、処理対象として新たに選択されるソースノードがついえるまで再帰的に続けられる。
<!-- □ -->
<span lang="en">
A list of source nodes is processed to create a result tree fragment.
The result tree is constructed by processing a list containing just the root node.
A list of source nodes is processed by appending the result tree structure created by processing each of the members of the list in order.
A node is processed by finding all the template rules with patterns that match the node, and choosing the best amongst them; the chosen rule's template is then instantiated with the node as the current node and with the list of source nodes as the current node list.
A template typically contains instructions that select an additional list of source nodes for processing.
The process of matching, instantiation and selection is continued recursively until no new source nodes are selected for processing.</span>
      </p>
      <p>
この処理モデルによる結果と同じ処理結果が得られるならば、実装はどのようにソース文書を処理してもよい。
<span lang="en">
Implementations are free to process the source document in any way that produces the same result as if it were processed using this processing model.</span>
      </p>

	</section>
	<section>

<h3 id="patterns" title="5.2 Patterns">5.2 パターン</h3>
      <p>
テンプレートルールは、 <dfn id="dt-pattern">パターン</dfn> を用いて適用先のノードを選別する。
パターンは、テンプレートルールのみならず, 番号付け （
<a href="#number">[<b>7.7 番号付け</b>]</a>
を見よ）やキー宣言（
<a href="#key">[<b>12.2 キー</b>]</a>
を見よ）にも利用される。
パターンはノードに対する条件の集合を指定する。
その条件すべてを満たすノードがそのパターンに合致するノードであり, 満たさないノードがそのパターンに合致しないノードとなる。
パターンの構文は、式の構文のサブセットである。
特に, 一定の制約を満たすロケーションパスは、パターンとしても利用できる。
パターンとしても利用可能な式は、常に, 評価結果がノード集合型のオブジェクトになる。
ノードがパターンに合致するのは、何らかの可能な文脈の下でパターンを式として評価した結果のノード集合に そのノードが属するときである。
可能な文脈とは、その文脈ノードが照合対象のノードそのものか, またはその先祖ノードの一つになるものを指す。
<span lang="en">
Template rules identify the nodes to which they apply by using a pattern.
As well as being used in template rules, patterns are used for numbering (see [7.7 Numbering]) and for declaring keys (see [12.2 Keys]).
A pattern specifies a set of conditions on a node.
A node that satisfies the conditions matches the pattern; a node that does not satisfy the conditions does not match the pattern.
The syntax for patterns is a subset of the syntax for expressions.
In particular, location paths that meet certain restrictions can be used as patterns.
An expression that is also a pattern always evaluates to an object of type node-set.
A node matches a pattern if the node is a member of the result of evaluating the pattern as an expression with respect to some possible context; the possible contexts are those whose context node is the node being matched or one of its ancestors.</span>
      </p>
      <p>
以下にパターンの例を示す。
<span lang="en">
Here are some examples of patterns:</span>
      </p>
      <ul>
         <li>
            <p>
<code>para</code> はすべての <code>para</code> 要素に合致する。
<span lang="en">
para matches any para element</span>
            </p>
         </li>
         <li>
            <p>
<code>*</code> は、すべての要素に合致する。
<span lang="en">
* matches any element</span>
            </p>
         </li>
         <li>
            <p>
<code>chapter|appendix</code> は、すべての <code>chapter</code> 要素と, すべての <code>appendix</code> 要素に合致する。
<span lang="en">
chapter|appendix matches any chapter element and any appendix element</span>
            </p>
         </li>
         <li>
            <p>
<code>olist/item</code> は、親が <code>olist</code> 要素になる, すべての <code>item</code> 要素に合致する。
<span lang="en">
olist/item matches any item element with an olist parent</span>
            </p>
         </li>
         <li>
            <p>
<code>appendix//para</code> は、先祖要素に <code>appendix</code> を持つ, すべての <code>para</code> 要素に合致する。
<span lang="en">
appendix//para matches any para element with an appendix ancestor element</span>
            </p>
         </li>
         <li>
            <p>
<code>/</code> は、ルートノードに合致する。
<span lang="en">
/ matches the root node</span>
            </p>
         </li>
         <li>
            <p>
<code>text()</code> は、すべてのテキストノードに合致する。
<span lang="en">
text() matches any text node</span>
            </p>
         </li>
         <li>
            <p>
<code>processing-instruction()</code> は、すべての処理命令に合致する。
<span lang="en">
processing-instruction() matches any processing instruction</span>
            </p>
         </li>
         <li>
            <p>
<code>node()</code> は、属性ノードとルートノードを除く, すべてのノードに合致する。
<span lang="en">
node() matches any node other than an attribute node and the root node</span>
            </p>
         </li>
         <li>
            <p>
<code>id("W11")</code> は、一意 ID として <code>W11</code> を持つ要素に合致する。
               <span lang="en">
id("W11") matches the element with unique ID W11</span>
            </p>
         </li>
         <li>
            <p>
<code>para[1]</code> は、 <code>para</code> 要素であって, 親に対し最初の <code>para</code> 子要素になるような, すべての要素に合致する。
<span class="trans-note">【同胞の <code>para</code> 要素の中で最初のもの】</span>
<span lang="en">
para[1] matches any para element that is the first para child element of its parent</span>
            </p>
         </li>
         <li>
            <p>
<code>*[position()=1 and self::para]</code> は、要素であって, 親に対し最初の子要素になるような, すべての <code>para</code> 要素に合致する。
<span class="trans-note">【同胞の要素の中で最初のものになる <code>para</code> 要素】</span>
<span lang="en">
*[position()=1 and self::para] matches any para element that is the first child element of its parent</span>
            </p>
         </li>
         <li>
            <p>
<code>para[last()=1]</code> は、 <code>para</code> 要素であって, 親に対して唯一の <code>para</code> 子要素になるような, すべての要素に合致する。
<span class="trans-note">【同胞の <code>para</code> 要素が自身のみになるもの】</span>
<span lang="en">
para[last()=1] matches any para element that is the only para child element of its parent</span>
            </p>
         </li>
         <li>
            <p>
<code>items/item[position()&gt;1]</code> は、 <code>items</code> 要素を親に持つ <code>item</code> 要素であって, 親に対し最初の <code>item</code> 子要素にはならないような, すべての要素に合致する。
<span lang="en">
items/item[position()&gt;1] matches any item element that has a<ins class="errata">n</ins><!-- E29 --> items parent and that is not the first item child of its parent</span>
            </p>
         </li>
         <li>
            <p>
<code>item[position() mod 2 = 1]</code> は、 <code>item</code> 要素であって, 親に対し奇数番目の <code>item</code> 子要素になるような, すべての要素に合致する。
<span class="trans-note">【同胞の <code>item</code> 要素の中で奇数番目のもの】</span>
<span lang="en">
item[position() mod 2 = 1] would be true for any item element that is an odd-numbered item child of its parent.</span>
            </p>
         </li>
         <li>
            <p>
<code>div[@class="appendix"]//p</code> は、値 <code>appendix</code> の <code>class</code> 属性を持つ <code>div</code> 要素を先祖に持つような, すべての <code>p</code> 要素に合致する。
               <span lang="en">
div[@class="appendix"]//p matches any p element with a div ancestor element that has a class attribute with value appendix</span>
            </p>
         </li>
         <li>
            <p>
<code>@class</code> は、すべての <code>class</code> 属性に合致する（ <code>class</code> 属性を持つ要素のことでは<em>ない</em>）。
<span lang="en">
@class matches any class attribute (not any element that has a class attribute)</span>
            </p>
         </li>
         <li>
            <p>
<code>@*</code> は、すべての属性に合致する。
<span lang="en">
@* matches any attribute</span>
            </p>
         </li>
      </ul>
      <p>
パターンは
<a href="#NT-Pattern">Pattern</a>
の構文に一致しなければならない。
<a href="#NT-Pattern">Pattern</a>
は、 <code>|</code> 区切りのロケーションパスパターンの集合である。
ロケーションパスパターンとは、すべてのステップに <code>child</code> 軸または <code>attribute</code> 軸のみを利用するロケーションパスである。
パターンでは <code>descendant-or-self</code> 軸を利用してはならないが、演算子 <code>/</code> と同様に演算子 <code>//</code> を利用してもよい。
ロケーションパスパターンは、リテラル引数による
<b><a href="xpath10-ja.html#function-id">id</a></b>
関数や
<b><a href="#function-key">key</a></b>
関数の呼び出しからも始められる。
パターンの述語には、ロケーションパスの述語と同じく、任意の式を利用できる。
<span lang="en">
A pattern must match the grammar for Pattern.
A Pattern is a set of location path patterns separated by |.
A location path pattern is a location path whose steps all use only the child or attribute axes.
Although patterns must not use the descendant-or-self axis, patterns may use the // operator as well as the / operator.
Location path patterns can also start with an id or key function call with a literal argument.
Predicates in a pattern can use arbitrary expressions just like predicates in a location path.</span>
      </p>


      <table class="scrap">
<caption title="Patterns">パターン</caption>
         <tbody>
            <tr>
               <td id="NT-Pattern">[1]</td>
               <td>Pattern</td>
               <td>::=</td>
               <td>
<a href="#NT-LocationPathPattern">LocationPathPattern</a><br />
| <a href="#NT-Pattern">Pattern</a> '|' <a href="#NT-LocationPathPattern">LocationPathPattern</a>
               </td>
               <td/>
            </tr>
            <tr>
               <td id="NT-LocationPathPattern">[2]</td>
               <td>LocationPathPattern</td>
               <td>::=</td>
               <td>
'/' <a href="#NT-RelativePathPattern">RelativePathPattern</a>?<br />
| <a href="#NT-IdKeyPattern">IdKeyPattern</a> (('/' | '//') <a href="#NT-RelativePathPattern">RelativePathPattern</a>)?<br />
| '//'? <a href="#NT-RelativePathPattern">RelativePathPattern</a>
               </td>
               <td/>
            </tr>
            <tr>
               <td id="NT-IdKeyPattern">[3]</td>
               <td>IdKeyPattern</td>
               <td>::=</td>
               <td>
'id' '(' <a href="xpath10-ja.html#NT-Literal">Literal</a> ')'<br />
| 'key' '(' <a href="xpath10-ja.html#NT-Literal">Literal</a> ',' <a href="xpath10-ja.html#NT-Literal">Literal</a> ')'
               </td>
               <td></td>
            </tr>
            <tr>
               <td id="NT-RelativePathPattern">[4]</td>
               <td>RelativePathPattern</td>
               <td>::=</td>
               <td>
<a href="#NT-StepPattern">StepPattern</a><br />
| <a href="#NT-RelativePathPattern">RelativePathPattern</a> '/' <a href="#NT-StepPattern">StepPattern</a><br />
| <a href="#NT-RelativePathPattern">RelativePathPattern</a> '//' <a href="#NT-StepPattern">StepPattern</a><br />
               </td>
               <td/>
            </tr>
            <tr>
               <td id="NT-StepPattern">[5]</td>
               <td>StepPattern</td>
               <td>::=</td>
               <td>
<a href="#NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</a>
<a href="xpath10-ja.html#NT-NodeTest">NodeTest</a>
<a href="xpath10-ja.html#NT-Predicate">Predicate</a>*
</td>
               <td/>
            </tr>
            <tr>
               <td id="NT-ChildOrAttributeAxisSpecifier">[6]</td>
               <td>ChildOrAttributeAxisSpecifier</td>
               <td>::=</td>
               <td>
<a href="xpath10-ja.html#NT-AbbreviatedAxisSpecifier">AbbreviatedAxisSpecifier</a><br />
| ('child' | 'attribute') '::'
               </td>
               <td/>
            </tr>
         </tbody>
      </table>
      <p>
パターンがノードに合致するとは、ある「可能な」文脈の下でパターンが式として評価された結果のノード集合にノードが属するとき、と定義される。
ノードが照合される際の可能な文脈とは、文脈ノードが照合対象のノードまたはそのノードの先祖であり, かつ 文脈ノードリストがその文脈ノードのみからなる文脈とする。
<span lang="en">
A pattern is defined to match a node if and only if there is possible context such that when the pattern is evaluated as an expression with that context, the node is a member of the resulting node-set.
When a node is being matched, the possible contexts have a context node that is the node being matched or any ancestor of that node, and a context node list containing just the context node.</span>
      </p>
      <p>
例えば <code>p</code> がすべての <code>p</code> 要素に合致するのは、どの <code>p</code> であれ, <code>p</code> 要素の親を文脈ノードとして式 <code>p</code> を評価したとき、結果のノード集合に <code>p</code> 要素が含まれるからである。
<span lang="en">
For example, p matches any p element, because for any p if the expression p is evaluated with the parent of the p element as context the resulting node-set will contain that p element as one of its members.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
このことは、 <code>p</code> 要素が文書要素であっても, 文書のルートが文書要素の親になるので成立する。
<span lang="en">
NOTE:This matches even a p element that is the document element, since the document root is the parent of the document element.</span>
</p>
      </blockquote>
      <p>
パターンの意味内容は式の評価に基づいて間接的に指定されるが、パターンの意味は式の評価の視点で考えなくとも直接的に容易に理解できる。
パターンにおいて <code>|</code> は選択肢を示す。
１個以上の <code>|</code> で区切られた選択肢を持つパターンは、選択肢のいずれかが合致するとき, パターンとして合致する。
パターンが <code>/</code> または <code>//</code> で区切られた一連の
<a href="#NT-StepPattern">StepPattern</a>
で構成されている場合、パターンの照合は右から左へ順に行われる。
パターンが合致するのは、右端の
<a href="#NT-StepPattern">StepPattern</a>
が合致し, 残りのパターンにも合致する「適切な」要素が存在するときになる。
区切りが <code>/</code> の場合、親のみが適切な要素になる。
区切りが <code>//</code> の場合、すべての先祖が適切な要素になる。
child 軸を利用する
<a href="#NT-StepPattern">StepPattern</a>
がノードに合致するのは、ノードに対する
<a href="xpath10-ja.html#NT-NodeTest">NodeTest</a>
が真であり, かつ そのノードが属性ノードでないときになる。
attribute 軸を利用する
<a href="#NT-StepPattern">StepPattern</a>
がノードに合致するのは、ノードに対する
<a href="xpath10-ja.html#NT-NodeTest">NodeTest</a>
が真であり, かつ そのノードが属性ノードのときになる。
述語 <code>[]</code> がある場合、照合されるノードが属性ノードでないならば, そのノードを文脈ノードとし、その同胞ノードのうち
<a href="xpath10-ja.html#NT-NodeTest">NodeTest</a>
に合致するものを文脈ノードリストとして,
<a href="#NT-StepPattern">StepPattern</a>
の最初の
<a href="xpath10-ja.html#NT-PredicateExpr">PredicateExpr</a>
が評価される。
照合されるノードが属性ノードの場合の文脈ノードリストは、
<a href="xpath10-ja.html#NT-NodeTest">NodeTest</a>
に合致する同胞属性（同じ親を持つ属性）のうち,
<a href="xpath10-ja.html#NT-NodeTest">NodeTest</a>
に合致するものからなるとする。
<span lang="en">
Although the semantics of patterns are specified indirectly in terms of expression evaluation, it is easy to understand the meaning of a pattern directly without thinking in terms of expression evaluation.
In a pattern, | indicates alternatives; a pattern with one or more | separated alternatives matches if any one of the alternative matches.
A pattern that consists of a sequence of StepPatterns separated by / or // is matched from right to left.
The pattern only matches if the rightmost StepPattern matches and a suitable element matches the rest of the pattern; if the separator is / then only the parent is a suitable element; if the separator is //, then any ancestor is a suitable element.
A StepPattern that uses the child axis matches if the NodeTest is true for the node and the node is not an attribute node.
A StepPattern that uses the attribute axis matches if the NodeTest is true for the node and the node is an attribute node.
When [] is present, then the first PredicateExpr in a StepPattern is evaluated with the node being matched as the context node and the siblings of the context node that match the NodeTest as the context node list, unless the node being matched is an attribute node, in which case the context node list is all the attributes that have the same parent as the attribute being matched and that match the NameTest.</span>
      </p>
      <p>
例えば
<span lang="en">
For example</span>
      </p>
      <pre>appendix//ulist/item[position()=1]</pre>
      <p>
は、次に挙げる条件がすべて真となる場合にのみ、ノードに合致する。
<span lang="en">
matches a node if and only if all of the following are true:</span>
      </p>
      <ul>
         <li>
            <p>
<a href="xpath10-ja.html#NT-NodeTest">NodeTest</a>
<code>item</code> がそのノードに対して真であり, そのノードが属性ではない。
すなわち、ノードが <code>item</code> 要素である。
<span lang="en">
the NodeTest item is true for the node and the node is not an attribute; in other words the node is an item element</span>
            </p>
         </li>
         <li>
            <p>
そのノードを文脈ノードとし, そのノードの同胞の <code>item</code> 要素を文脈ノードリストとして
<a href="xpath10-ja.html#NT-PredicateExpr">PredicateExpr</a>
 <code>position()=1</code> を評価したときに真になる。
<span lang="en">
evaluating the PredicateExpr position()=1 with the node as context node and the siblings of the node that are item elements as the context node list yields true</span>
            </p>
         </li>
         <li>
            <p>
そのノードが <code>appendix//ulist</code> に合致する親を持つ。
これは、その親が先祖要素に <code>appendix</code> を持つ <code>ulist</code> 要素のとき真になる。
<span lang="en">
the node has a parent that matches appendix//ulist; this will be true if the parent is a ulist element that has an appendix ancestor element.</span>
            </p>
         </li>
      </ul>

	</section>
	<section>

<h3 id="section-Defining-Template-Rules" title="5.3 Defining Template Rules">5.3 テンプレートルールの定義</h3>
      <pre class="element-syntax" id="element-template">
&lt;!-- 分類：top-level-element --&gt;
&lt;xsl:template
  match = <var>pattern</var> 
  name = <var>qname</var> 
  priority = <var>number</var> 
  mode = <var>qname</var>&gt;
  &lt;!-- 内容：(<a href="#element-param">xsl:param</a>*, <var>template</var>) --&gt;
&lt;/xsl:template&gt;</pre>
      <p>
テンプレートルールは、<code>xsl:template</code> 要素を用いて指定される。
<code>match</code> 属性がソースノードやルールの適用先ノードを選別する
<a href="#NT-Pattern">Pattern</a>
を与える。
<code>match</code> 属性は <code>xsl:template</code> 要素が <code>name</code> 属性を持つ場合を除き, 必須になる（
<a href="#named-templates">[<b>6 名前付きテンプレート</b>]</a>
を見よ）。
<code>match</code> 属性の値が
<a href="xpath10-ja.html#NT-VariableReference">VariableReference</a>
を含む場合、エラーとする。
<code>xsl:template</code> 要素の内容が、テンプレートルールが適用されるときにインスタンス化されるテンプレートである。
<span lang="en">
A template rule is specified with the xsl:template element.
The match attribute is a Pattern that identifies the source node or nodes to which the rule applies.
The match attribute is required unless the xsl:template element has a name attribute (see [6 Named Templates]).
It is an error for the value of the match attribute to contain a VariableReference.
The content of the xsl:template element is the template that is instantiated when the template rule is applied.</span>
      </p>
      <p>
例えば XML 文書が次を含むとする：
<span lang="en">
For example, an XML document might contain:</span>
      </p>
      <pre>This is an &lt;emph&gt;important&lt;/emph&gt; point.</pre>
      <p>
次のテンプレートルールは、上の <code>emph</code> 要素に合致し, <code>font-weight</code> プロパティが <code>bold</code> のフォーマッティングオブジェクト <code>fo:inline-sequence</code> を生成する。
<span lang="en">
The following template rule matches emph elements and produces a fo:inline-sequence formatting object with a font-weight property of bold.</span>
      </p>
      <pre>&lt;xsl:template match="emph"&gt;
  &lt;fo:inline-sequence font-weight="bold"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:inline-sequence&gt;
&lt;/xsl:template&gt;</pre>
      <blockquote>
<p>
<b>注記：</b>
この仕様の記述例では、接頭辞 <code>fo:</code> を
<a href="#XSL">[XSL]</a>
が定めるフォーマット化オブジェクトの名前空間 <code>http://www.w3.org/1999/XSL/Format</code> に利用する。
<span lang="en">
NOTE:Examples in this document use the fo: prefix for the namespace http://www.w3.org/1999/XSL/Format, which is the namespace of the formatting objects defined in [XSL].</span>
</p>
      </blockquote>
      <p>
次節で述べるように <code>xsl:apply-templates</code> 要素はソース要素の子を再帰的に処理する。
<span lang="en">
As described next, the xsl:apply-templates element recursively processes the children of the source element.</span>
      </p>

	</section>
	<section>

<h3 id="section-Applying-Template-Rules" title="5.4 Applying Template Rules">5.4 テンプレートルールの適用</h3>
      <pre class="element-syntax" id="element-apply-templates">
&lt;!-- 分類：instruction --&gt;
&lt;xsl:apply-templates
  select = <var>node-set-expression</var> 
  mode = <var>qname</var>&gt;
  &lt;!-- 内容：(<a href="#element-sort">xsl:sort</a> | <a href="#element-with-param">xsl:with-param</a>)* --&gt;
&lt;/xsl:apply-templates&gt;</pre>
      <p>
次の例は <code>chapter</code> 要素に対し fo:block を生成し、次にその <code>chapter</code> 要素の直下の子を処理する。
<span lang="en">
This example creates a block for a chapter element and then processes its immediate children.</span>
      </p>
      <pre>&lt;xsl:template match="chapter"&gt;
  &lt;fo:block&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>
      <p>
<code>xsl:apply-templates</code> 命令は、 <code>select</code> 属性が与えられていなければ, テキストノードを含む現在のノードのすべての子ノードを処理する。
ただし、
<a href="#strip">[<b>3.4 空白の削除</b>]</a>
に則って削除されるテキストノードは処理しない。
空白保持要素名の集合に含まれない要素に対しては、要素の内容に含まれるすべての空白がテキストとして処理される。
従って, 子要素に挟まれる空白も、
<b><a href="xpath10-ja.html#function-position">position</a></b>
関数から子要素の位置を決定する際にカウントされる。
<span lang="en">
In the absence of a select attribute, the xsl:apply-templates instruction processes all of the children of the current node, including text nodes.
However, text nodes that have been stripped as specified in [3.4 Whitespace Stripping] will not be processed.
If stripping of whitespace nodes has not been enabled for an element, then all whitespace in the content of the element will be processed as text, and thus whitespace between child elements will count in determining the position of a child element as returned by the position function.</span>
      </p>
      <p>
<code>select</code> 属性を利用すると、すべての子を処理する代わりに, 式により選別したノードだけを処理できる。
<code>select</code> 属性の値は
<a href="#dt-expression">式</a>
である。
式の評価結果はノード集合でなければならない。
選択されたノード集合は、ソート（
<a href="#sorting">[<b>10 ソート</b>]</a>
を見よ）が指定されていなければ, 文書順に処理される。
次の例は <code>author-group</code> の子の <code>author</code> すべてを処理する。
<span lang="en">
A select attribute can be used to process nodes selected by an expression instead of processing all children.
The value of the select attribute is an expression.
The expression must evaluate to a node-set.
The selected set of nodes is processed in document order, unless a sorting specification is present (see [10 Sorting]).
The following example processes all of the author children of the author-group:</span>
      </p>
      <pre>&lt;xsl:template match="author-group"&gt;
  &lt;fo:inline-sequence&gt;
    &lt;xsl:apply-templates select="author"/&gt;
  &lt;/fo:inline-sequence&gt;
&lt;/xsl:template&gt;</pre>
      <p>
次の例は、 <code>author-group</code> の子の <code>author</code> すべてに対し、その子の <code>given-name</code> すべてを処理する。
<span lang="en">
The following example processes all of the given-names of the authors that are children of author-group:</span>
      </p>
      <pre>&lt;xsl:template match="author-group"&gt;
  &lt;fo:inline-sequence&gt;
    &lt;xsl:apply-templates select="author/given-name"/&gt;
  &lt;/fo:inline-sequence&gt;
&lt;/xsl:template&gt;</pre>
      <p>
次の例は、<code>book</code> 要素のすべての子孫 <code>heading</code> 要素を処理する。
<span lang="en">
This example processes all of the heading descendant elements of the book element.</span>
      </p>
      <pre>&lt;xsl:template match="book"&gt;
  &lt;fo:block&gt;
    &lt;xsl:apply-templates select=".//heading"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>
      <p>
現在のノードの子孫でない要素も処理できる。
次の例では <code>department</code> 要素が子要素 <code>group</code> および子孫要素 <code>employee</code> を持つものと仮定する。
「従業員」（ employee ）の「部署」（ department ）を見つけ、次に <code>department</code> の子の <code>group</code> を処理する。
<span lang="en">
It is also possible to process elements that are not descendants of the current node.
This example assumes that a department element has group children and employee descendants.
It finds an employee's department and then processes the group children of the department.</span>
      </p>
      <pre>&lt;xsl:template match="employee"&gt;
  &lt;fo:block&gt;
    Employee &lt;xsl:apply-templates select="name"/&gt; belongs to group
    &lt;xsl:apply-templates select="ancestor::department/group"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>
      <p>
複数の <code>xsl:apply-templates</code> 要素を一つのテンプレート内で利用すると、簡単な再順序付けも行える。
次の例は、２つの HTML テーブルを作成する。
最初のテーブルには「国内販売高」（ domestic sales ）, 次のテーブルには「海外販売高」（ foreign sales ）のデータを挿入する。
<span lang="en">
Multiple xsl:apply-templates elements can be used within a single template to do simple reordering.
The following example creates two HTML tables.
The first table is filled with domestic sales while the second table is filled with foreign sales.</span>
      </p>
      <pre>&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/domestic"/&gt;
  &lt;/table&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/foreign"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;</pre>
      <blockquote>
<p>
<b>注記：</b>
一方が他方の子孫になっているような２つの子孫が合致することもあり得る。
この場合も特別には扱われず、両者とも通常どおり処理される。
例えば次のソース文書：
<span lang="en">
NOTE: It is possible for there to be two matching descendants where one is a descendant of the other.
This case is not treated specially: both descendants will be processed as usual.
For example, given a source document
</span>
</p>
  <pre>&lt;doc&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/doc&gt;</pre>

<p>
に対し、ルール：
<span lang="en">
the rule </span>
</p>
  <pre>&lt;xsl:template match="doc"&gt;
  &lt;xsl:apply-templates select=".//div"/&gt;
&lt;/xsl:template&gt;</pre>

<p>
は、外側の <code>div</code> 要素と内側の <code>div</code> 要素の両方を処理する。
<span lang="en">
will process both the outer div and inner div elements.
</span>
</p>
      </blockquote>
      <blockquote>
<p>
<b>注記：</b>
通常、 <code>xsl:apply-templates</code> は現在のノードの子孫のノードのみを処理する目的に利用される。
そのような利用では、無限処理ループ（無限再帰）は生じない。
<code>xsl:apply-templates</code> を現在のノードの子孫でない要素の処理に利用した場合、終端のない処理ループが生じ得る。
例えば

<span lang="en">
NOTE:Typically, xsl:apply-templates is used to process only nodes that are descendants of the current node.
Such use of xsl:apply-templates cannot result in non-terminating processing loops.
However, when xsl:apply-templates is used to process elements that are not descendants of the current node, the possibility arises of non-terminating loops.
For example, </span>
</p>
  <pre style="color: red">&lt;xsl:template match="foo"&gt;
  &lt;xsl:apply-templates select="."/&gt;
&lt;/xsl:template&gt;</pre>

<p>
実装側がこのようなループを検知できる場合もあるが、検知できない無限ループに陥る可能性もある。
これは、サービスの安全性を侵すリスクになり得る。
<span lang="en">
Implementations may be able to detect such loops in some cases, but the possibility exists that a stylesheet may enter a non-terminating loop that an implementation is unable to detect.
This may present a denial of service security risk.</span>
</p>
      </blockquote>

	</section>
	<section>

<h3 id="conflict" title="5.5 Conflict Resolution for Template Rules">5.5 テンプレートルールの競合解決</h3>
      <p>
１個のソースノードが、複数のテンプレートに合致することがある。
利用されるテンプレートルールは以下の手順で決定される：
<span lang="en">
It is possible for a source node to match more than one template rule.
The template rule to be used is determined as follows:</span>
      </p>
      <ol>
         <li>
            <p>
最初に、合致するテンプレートルールの中で
<a href="#dt-import-precedence">インポート優先順位</a>
が最高でないものはすべて候補から外す。
<span lang="en">
First, all matching template rules that have lower import precedence than the matching template rule or rules with the highest import precedence are eliminated from consideration.</span>
            </p>
         </li>
         <li>
            <p>
次に、合致したテンプレートルールのうち、優先度（ priority ）が最高でないものをすべて候補から外す。
テンプレートルールの優先度は、テンプレートルールの <code>priority</code> 属性で指定される。
優先度の値は実数であり（負も許容される）、オプションの先頭の負符号（ <code>-</code> ）に
<a href="xpath10-ja.html#NT-Number">Number</a>
が後続する生成規則に合致しなければならない。
 <dfn id="dt-default-priority">既定の優先度</dfn> は、次のように計算される。
<span lang="en">
Next, all matching template rules that have lower priority than the matching template rule or rules with the highest priority are eliminated from consideration.
The priority of a template rule is specified by the priority attribute on the template rule.
The value of this must be a real number (positive or negative), matching the production Number with an optional leading minus sign (-).
The default priority is computed as follows:</span>
            </p>
            <ul>
               <li>
<p>
パターンに <code>|</code> で区切られた複数の候補が含まれる場合、そのテンプレートは、候補それぞれに１個のテンプレートが存在するテンプレートの集合と同様に扱われる。
<span lang="en">
If the pattern contains multiple alternatives separated by |, then it is treated equivalently to a set of template rules, one for each alternative.</span>
                  </p>
               </li>
               <li>
<p>
パターンが
<a href="#NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</a>
から始まる
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
形式の場合, または
<a href="#NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</a>
から始まる
<code>processing-instruction (</code> <a href="xpath10-ja.html#NT-Literal">Literal</a> <code>)</code>
形式の場合、優先度は 0 。
<span lang="en">
If the pattern has the form of a QName preceded by a ChildOrAttributeAxisSpecifier or has the form processing-instruction(Literal) preceded by a ChildOrAttributeAxisSpecifier, then the priority is 0.</span>
                  </p>
               </li>
               <li>
                  <p>
パターンが
<a href="#NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</a>
から始まる
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-NCName">NCName</a>
<code>:*</code> 形式の場合、優先度は -0.25 。
<span lang="en">
If the pattern has the form NCName:* preceded by a ChildOrAttributeAxisSpecifier, then the priority is -0.25.</span>
                  </p>
               </li>
               <li>
                  <p>
上記以外の, パターンが
<a href="#NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</a>
から始まる
<a href="xpath10-ja.html#NT-NodeTest">NodeTest</a>
のみからなる場合、優先度は -0.5 。
<span lang="en">
Otherwise, if the pattern consists of just a NodeTest preceded by a ChildOrAttributeAxisSpecifier, then the priority is -0.5.</span>
                  </p>
               </li>
               <li>
                  <p>
他の場合、優先度は 0.5 。
<span lang="en">
Otherwise, the priority is 0.5.</span>
                  </p>
               </li>
            </ul>
            <p>
したがって、最もありふれたパターン（特定の型と特定の展開名を持つノードを選択するパターン）の優先度は 0 になる。
より条件が緩いパターン（特定の型と、特定の名前空間 URI を展開名に持つノードを選択するパターン）の優先度は -0.25 になる。
さらに条件が緩いパターン（単に特定の型を持つノードを選択するパターン）の優先度は -0.5 になる。
最もありふれたパターンより条件が厳しいパターンの優先度は 0.5 になる。
<span lang="en">
Thus, the most common kind of pattern (a pattern that tests for a node with a particular type and a particular expanded-name) has priority 0.
The next less specific kind of pattern (a pattern that tests for a node with a particular type and an expanded-name with a particular namespace URI) has priority -0.25.
Patterns less specific than this (patterns that just tests for nodes with particular types) have priority -0.5.
Patterns more specific than the most common kind of pattern have priority 0.5.</span>
            </p>
         </li>
      </ol>
      <p>
この手続き後も, 合致するテンプレートルールが複数残る場合、エラーとする。
XSLT プロセッサは、エラーを通知してもよい。
エラーを通知しない場合、残ったテンプレートルールからスタイルシートの最後方に現れるものを選択し、エラーから回復しなければならない。
<span lang="en">
It is an error if this leaves more than one matching template rule.
An XSLT processor may signal the error; if it does not signal the error, it must recover by choosing, from amongst the matching template rules that are left, the one that occurs last in the stylesheet.</span>
      </p>

	</section>
	<section>

<h3 id="apply-imports" title="5.6 Overriding Template Rules">5.6 テンプレートルールの上書き</h3>
      <pre class="element-syntax" id="element-apply-imports">
&lt;!-- 分類：instruction --&gt;
&lt;xsl:apply-imports /&gt;</pre>
      <p>
テンプレートルールが, インポートしたスタイルシートのテンプレートルールを上書き（
<a href="#conflict">[<b>5.5 テンプレートの競合解決</b>]</a>
を見よ）していても、 <code>xsl:apply-imports</code> 要素を用いて上書きされたテンプレートルールを呼び出すことができる。
<span lang="en">
A template rule that is being used to override a template rule in an imported stylesheet (see [5.5 Conflict Resolution for Template Rules]) can use the xsl:apply-imports element to invoke the overridden template rule.</span>
      </p>
      <p>
スタイルシート処理中は常に、 <dfn id="dt-current-template-rule">現在のテンプレートルール</dfn> が存在する。
パターンの照合によりテンプレートルールが選択されると、ルール内のテンプレートをインスタンス化している間は, そのテンプレートルールが現在のテンプレートルールになる。
ただし, <code>xsl:for-each</code> 要素のインスタンス化においては、 <code>xsl:for-each</code> 要素の内容をインスタンス化している間は, 現在のテンプレートルールは null になる。
<span lang="en">
At any point in the processing of a stylesheet, there is a current template rule.
Whenever a template rule is chosen by matching a pattern, the template rule becomes the current template rule for the instantiation of the rule's template.
When an xsl:for-each element is instantiated, the current template rule becomes null for the instantiation of the content of the xsl:for-each element.</span>
      </p>
      <p>
<code>xsl:apply-imports</code> は、現在のテンプレートルールが属するスタイルシート要素にインポートされたテンプレートルールのみを用いて, 現在のノードを処理する。
ノードは現在のテンプレートルールの<a href="#modes" >モード</a>で処理される。
現在のテンプレートルールが null のときに, <code>xsl:apply-imports</code> がインスタンス化された場合、エラーとする。
<span lang="en">
xsl:apply-imports processes the current node using only template rules that were imported into the stylesheet element containing the current template rule; the node is processed in the current template rule's mode.
It is an error if xsl:apply-imports is instantiated when the current template rule is null.</span>
      </p>
      <p>
例えば、スタイルシート <code>doc.xsl</code> に <code>example</code> 要素用のテンプレートルールが含まれていたとする：
<span lang="en">
For example, suppose the stylesheet doc.xsl contains a template rule for example elements:</span>
      </p>
      <pre>&lt;xsl:template match="example"&gt;
  &lt;pre&gt;&lt;xsl:apply-templates/&gt;&lt;/pre&gt;
&lt;/xsl:template&gt;</pre>
      <p>
<code>doc.xsl</code> をインポートする他のスタイルシートは、次のように <code>example</code> 要素の扱いを変更できる：
<span lang="en">
Another stylesheet could import doc.xsl and modify the treatment of example elements as follows:</span>
      </p>
      <pre>&lt;xsl:import href="doc.xsl"/&gt;

&lt;xsl:template match="example"&gt;
  &lt;div style="border: solid red"&gt;
     &lt;xsl:apply-imports/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;</pre>
      <p>
この組み合わせにより、 <code>example</code> 要素は次の形に変換される：
<span lang="en">
The combined effect would be to transform an example into an element of the form:</span>
      </p>
      <pre>&lt;div style="border: solid red"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;</pre>

	</section>
	<section>

<h3 id="modes" title="5.7 Modes">5.7 モード</h3>
      <p>
モードを利用すれば、要素を複数回処理させつつ, 毎回異なる結果が得られるようになる。
<span lang="en">
Modes allow an element to be processed multiple times, each time producing a different result.</span>
      </p>
      <p>
<code>xsl:template</code> と <code>xsl:apply-templates</code> は、オプションで <code>mode</code> 属性を利用できる。
<code>mode</code> 属性の値は
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
であり、
<a href="#qname">[<b>2.4 修飾名</b>]</a>
に則って展開される。
<code>xsl:template</code> が <code>match</code> 属性を持たない場合、 <code>mode</code> 属性も持ってはならない。
<code>mode</code> 属性が与えられている <code>xsl:apply-templates</code> 要素は、同じ <code>mode</code> 属性値を持つ <code>xsl:template</code> 要素のテンプレートルールのみを適用する。
<code>mode</code> 属性が与えられていない <code>xsl:apply-templates</code> 要素は、 <code>mode</code> 属性を持たない <code>xsl:template</code> 要素のテンプレートルールのみを適用する。
<span lang="en">
Both xsl:template and xsl:apply-templates have an optional mode attribute.
The value of the mode attribute is a QName, which is expanded as described in [2.4 Qualified Names].
If xsl:template does not have a match attribute, it must not have a mode attribute.
If an xsl:apply-templates element has a mode attribute, then it applies only to those template rules from xsl:template elements that have a mode attribute with the same value;
if an xsl:apply-templates element does not have a mode attribute, then it applies only to those template rules from xsl:template elements that do not have a mode attribute.</span>
      </p>

	</section>
	<section>

<h3 id="built-in-rule" title="5.8 Built-in Template Rules">5.8 組み込みテンプレートルール</h3>
      <p>
合致するパターンを持つテンプレートルールがスタイルシートの中に明示的に与えられていなくても、再帰的な処理の継続を可能にする暗黙の組み込みテンプレートルールがある。
このテンプレートルールは、要素ノードとルートノードの両方に適用される。
組み込みテンプレートルールと等価の記述を次に示す：
<span lang="en">
There is a built-in template rule to allow recursive processing to continue in the absence of a successful pattern match by an explicit template rule in the stylesheet.
This template rule applies to both element nodes and the root node.
The following shows the equivalent of the built-in template rule:</span>
      </p>
      <pre>&lt;xsl:template match="*|/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre>
      <p>
それぞれのモードにも、スタイルシートの中に合致するパターンを持つテンプレートルールが明示的に与えられていなくても、同じモードによる再帰的な処理の継続を可能にする暗黙の組み込みテンプレートルールがある。
このテンプレートルールは、要素ノードとルートノードの両方に適用される。
モード <code><var>m</var></code> の組み込みテンプレートルールと等価の記述を次に示す：
<span lang="en">
There is also a built-in template rule for each mode, which allows recursive processing to continue in the same mode in the absence of a successful pattern match by an explicit template rule in the stylesheet.
This template rule applies to both element nodes and the root node.
The following shows the equivalent of the built-in template rule for mode m.</span>
      </p>
      <pre>&lt;xsl:template match="*|/" mode="<var>m</var>"&gt;
  &lt;xsl:apply-templates mode="<var>m</var>"/&gt;
&lt;/xsl:template&gt;</pre>
      <p>
テキストノードと属性ノードについても、テキストを複製する暗黙の組み込みテンプレートルールが存在する：
<span lang="en">
There is also a built-in template rule for text and attribute nodes that copies text through:</span>
      </p>
      <pre>&lt;xsl:template match="text()|@*"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;</pre>
      <p>
処理命令およびコメントに対する組み込みテンプレートルールは、何も実行しない。
<span lang="en">
The built-in template rule for processing instructions and comments is to do nothing.</span>
      </p>
      <pre>&lt;xsl:template match="processing-instruction()|comment()"/&gt;</pre>
      <p>
名前空間ノードに対する組み込みテンプレートルールも、何も実行しない。
名前空間ノードに合致し得るパターンは存在しないため、名前空間ノードに適用されるテンプレートルールは組み込みのものだけになる。
<span lang="en">
The built-in template rule for namespace nodes is also to do nothing.
There is no pattern that can match a namespace node; so, the built-in template rule is the only template rule that is applied for namespace nodes.</span>
      </p>
      <p>
組み込みテンプレートルールは、スタイルシートの前に暗黙的にインポートされたかのように扱われるため、
<a href="#dt-import-precedence">インポート優先順位</a>
は他のすべてのテンプレートルールよりも低くなる。
従って, スタイルシート作成者は、テンプレートルールを明示的に与えることにより, 組み込みテンプレートルールを上書きできる。
<span lang="en">
The built-in template rules are treated as if they were imported implicitly before the stylesheet and so have lower import precedence than all other template rules.
Thus, the author can override a built-in template rule by including an explicit template rule.</span>
      </p>

	</section>
</section>
<section>

<h2 id="named-templates" title="6 Named Templates">6 名前付きテンプレート</h2>
      <pre class="element-syntax" id="element-call-template">
&lt;!-- 分類：instruction --&gt;
&lt;xsl:call-template
  <b>name</b> = <var>qname</var>&gt;
  &lt;!-- 内容：<a href="#element-with-param">xsl:with-param</a>* --&gt;
&lt;/xsl:call-template&gt;</pre>
      <p>
テンプレートは、名前で呼び出すこともできる。
<code>name</code> 属性が与えられた <code>xsl:template</code> 要素は、名前付きテンプレートになる。
<code>name</code> 属性の値は
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
であり、
<a href="#qname">[<b>2.4 修飾名</b>]</a>
に則って展開される。
<code>name</code> 属性を持つ <code>xsl:template</code> 要素に <code>match</code> 属性を指定してもよいが、そうする必要はない。
<code>xsl:call-template</code> 要素が、テンプレートを名前で呼び出す。従って、呼び出すテンプレートを識別する <code>name</code> 属性を持たなければならない。
<code>xsl:apply-templates</code> と異なり、 <code>xsl:call-template</code> は現在のノードや現在のノードリストを変更しない。
<span lang="en">
Templates can be invoked by name.
An xsl:template element with a name attribute specifies a named template.
The value of the name attribute is a QName, which is expanded as described in [2.4 Qualified Names].
If an xsl:template element has a name attribute, it may, but need not, also have a match attribute.
An xsl:call-template element invokes a template by name; it has a required name attribute that identifies the template to be invoked.
Unlike xsl:apply-templates, xsl:call-template does not change the current node or the current node list.</span>
      </p>
      <p>
<code>xsl:template</code> 要素の <code>match</code> 属性, <code>mode</code> 属性, <code>priority</code> 属性は、 <code>xsl:call-template</code> 要素からのテンプレートの呼び出しに影響しない。
同様に, <code>xsl:template</code> 要素の <code>name</code> 属性も、 <code>xsl:apply-templates</code> 要素からのテンプレートの呼び出しに影響しない。
<span lang="en">
The match, mode and priority attributes on an xsl:template element do not affect whether the template is invoked by an xsl:call-template element.
Similarly, the name attribute on an xsl:template element does not affect whether the template is invoked by an xsl:apply-templates element.</span>
      </p>
      <p>
スタイルシートに、同じ名前の, 同じ
<a href="#dt-import-precedence">インポート優先順位</a>
のテンプレートが複数含まれる場合、エラーとする。
<span lang="en">
It is an error if a stylesheet contains more than one template with the same name and same import precedence.</span>
      </p>

</section>
<section>

<h2 id="section-Creating-the-Result-Tree" title="7 Creating the Result Tree">7 結果ツリーの生成</h2>
      <p>
この節では、結果ツリーに直接ノードを生成する命令について述べる。
<span lang="en">
This section describes instructions that directly create nodes in the result tree.</span>
      </p>

	<section>

<h3 id="section-Creating-Elements-and-Attributes" title="7.1 Creating Elements and Attributes">7.1 要素と属性の生成</h3>


		<section>

<h4 id="literal-result-element" title="7.1.1 Literal Result Elements">7.1.1 リテラル結果要素</h4>
      <p>
スタイルシート内の、 XSLT 名前空間に属さない, 拡張要素（
<a href="#extension-element">[<b>14.1 拡張要素</b>]</a>
を見よ）でもない, テンプレート内の要素は、インスタンス化の際に同一の
<a href="xpath10-ja.html#dt-expanded-name">展開名</a>
を持つ要素ノードを生成する。
この要素の内容はテンプレートであり、生成される要素ノードの内容を与えるためにインスタンス化される。
生成される要素ノードは、スタイルシートツリー内の要素ノードの属性から XSLT 名前空間に属する属性を除いた属性を持つことになる。
<span lang="en">
In a template, an element in the stylesheet that does not belong to the XSLT namespace and that is not an extension element (see [14.1 Extension Elements]) is instantiated to create an element node with the same expanded-name.
The content of the element is a template, which is instantiated to give the content of the created element node.
The created element node will have the attribute nodes that were present on the element node in the stylesheet tree, other than attributes with names in the XSLT namespace.</span>
      </p>
      <p>
生成された要素ノードは、スタイルシートツリー内の要素ノードに存在する名前空間ノードの複製も持つ。
ただし、 XSLT 名前空間 URI （ <code>http://www.w3.org/1999/XSL/Transform</code> ）,
拡張名前空間として宣言された名前空間 URI （
<a href="#extension-element">[<b>14.1 拡張要素</b>]</a>
を見よ）, および「除外指定」された名前空間 URI , を文字列値とする名前空間ノードは除外される。
名前空間を除外指定にするには、 <code>xsl:stylesheet</code> 要素の <code>exclude-result-prefixes</code> 属性, またはリテラル結果要素の <code>xsl:exclude-result-prefixes</code> 属性に名前空間接頭辞の空白区切りのリストを与える。
各接頭辞に結びつけられた名前空間 URI の名前空間が、除外指定にされる。

それらの名前空間がその属性を持つ要素のスコープに入らない場合、エラーとする。
名前空間接頭辞のリストに <code>#default</code> を含めれば、既定の名前空間（ <code>xmlns</code> で宣言されたもの）も除外指定にできる。
名前空間の除外指定は、 <code>exclude-result-prefixes</code> または <code>xsl:exclude-result-prefixes</code> 属性を持つ要素をルートとするスタイルシートの部分ツリーの中で有効になる。
ただし, <code>xsl:stylesheet</code> 要素をルートとする部分ツリーには、その <code>xsl:stylesheet</code> 要素の子によりインポートまたインクルードされたスタイルシートは含まれないものとする。

<span lang="en">
The created element node will also have a copy of the namespace nodes that were present on the element node in the stylesheet tree with the exception of any namespace node whose string-value is the XSLT namespace URI (http://www.w3.org/1999/XSL/Transform),
a namespace URI declared as an extension namespace (see [14.1 Extension Elements]),
or a namespace URI designated as an excluded namespace.

A namespace URI is designated as an excluded namespace by using an exclude-result-prefixes attribute on an xsl:stylesheet element or an xsl:exclude-result-prefixes attribute on a literal result element.
The value of both these attributes is a whitespace-separated list of namespace prefixes.
The namespace bound to each of the prefixes is designated as an excluded namespace.

It is an error if there is no namespace bound to the prefix on the element bearing the exclude-result-prefixes or xsl:exclude-result-prefixes attribute.

The default namespace (as declared by xmlns) may be designated as an excluded namespace by including #default in the list of namespace prefixes.

The designation of a namespace as an excluded namespace is effective within the subtree of the stylesheet rooted at the element bearing the exclude-result-prefixes or xsl:exclude-result-prefixes attribute; a subtree rooted at an xsl:stylesheet element does not include any stylesheets imported or included by children of that xsl:stylesheet element.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
スタイルシートで, ソースツリーの位置指定の目的のみに名前空間宣言を利用するような場合、 <code>exclude-result-prefixes</code> 属性に接頭辞を指定して, 結果ツリーに余分な名前空間宣言が生成されないようにすることができる。
<span lang="en">
NOTE:When a stylesheet uses a namespace declaration only for the purposes of addressing the source tree, specifying the prefix in the exclude-result-prefixes attribute will avoid superfluous namespace declarations in the result tree.</span>
</p>
      </blockquote>
      <p>
リテラル結果要素の属性値は、
<a href="#dt-attribute-value-template">属性値テンプレート</a>
として解釈される。
このテンプレートには、波括弧（ <code>{}</code> ）で括った式を含められる。
<span lang="en">
The value of an attribute of a literal result element is interpreted as an attribute value template: it can contain expressions contained in curly braces ({}).</span>
      </p>
      <p>
スタイルシートツリー内の名前空間 URI のうち, 結果ツリー内の名前空間 URI を指定するために利用されるものを <dfn id="dt-literal-namespace-uri">リテラル名前空間 URI</dfn> と呼ぶ。
次に挙げるものがこの URI に該当する：
<span lang="en">
A namespace URI in the stylesheet tree that is being used to specify a namespace URI in the result tree is called a literal namespace URI.
This applies to:</span>
      </p>
      <ul>
         <li>
            <p>
スタイルシートに含まれるリテラル結果要素の展開名の名前空間 URI
<span lang="en">
the namespace URI in the expanded-name of a literal result element in the stylesheet</span>
            </p>
         </li>
         <li>
            <p>
スタイルシートに含まれるリテラル結果要素に指定されている属性の展開名の名前空間 URI
<span lang="en">
the namespace URI in the expanded-name of an attribute specified on a literal result element in the stylesheet</span>
            </p>
         </li>
         <li>
            <p>
スタイルシートに含まれるリテラル結果要素の名前空間ノードの文字列値
<span lang="en">
the string-value of a namespace node on a literal result element in the stylesheet</span>
            </p>
         </li>
      </ul>
      <pre class="element-syntax" id="element-namespace-alias">
&lt;!-- 分類：top-level-element --&gt;
&lt;xsl:namespace-alias
  <b>stylesheet-prefix</b> = <var>prefix</var> | "#default"
  <b>result-prefix</b> = <var>prefix</var> | "#default" /&gt;</pre>
      <p>
<code>xsl:namespace-alias</code> 要素を利用して一つの名前空間 URI を別の名前空間 URI への <dfn id="dt-alias">エイリアス</dfn> として宣言できる。
<a href="#dt-literal-namespace-uri">リテラル名前空間 URI</a>
を, 他の名前空間 URI へのエイリアスとして宣言した場合、結果ツリー内における名前空間 URI が, リテラル名前空間 URI 自身でなく, エイリアスが指す名前空間 URI になる。
<code>xsl:namespace-alias</code> 要素は、 <code>stylesheet-prefix</code> 属性で指定される接頭辞に結びつけられた名前空間 URI が, <code>result-prefix</code> 属性で指定される接頭辞に結びつけられた名前空間 URI へのエイリアスであるものと宣言する。
すなわち, <code>stylesheet-prefix</code> 属性がスタイルシートに現れる名前空間 URI を指し、 <code>result-prefix</code> 属性が, それに対応して結果ツリーに生成される名前空間 URI を指すことになる。
接頭辞の代わりに, <code>#default</code> を用いて既定の名前空間（ <code>xmlns</code> で宣言されたもの）を指定してもよい。
一つの名前空間 URI が, 複数の異なる名前空間 URI へのエイリアスとして宣言されている場合、
<a href="#dt-import-precedence">インポート優先順位</a>
が最高のものが利用される。
そのような宣言が複数存在する場合、エラーとする。
XSLT プロセッサは、エラーを通知してもよい。
エラーを通知しない場合、それらの中からスタイルシートの最後方に現れるものを選択し, エラーから回復しなければならない。
<span lang="en">
A stylesheet can use the xsl:namespace-alias element to declare that one namespace URI is an alias for another namespace URI.
When a literal namespace URI has been declared to be an alias for another namespace URI, then the namespace URI in the result tree will be the namespace URI that the literal namespace URI is an alias for, instead of the literal namespace URI itself.
The xsl:namespace-alias element declares that the namespace URI bound to the prefix specified by the stylesheet-prefix attribute is an alias for the namespace URI bound to the prefix specified by the result-prefix attribute.
Thus, the stylesheet-prefix attribute specifies the namespace URI that will appear in the stylesheet, and the result-prefix attribute specifies the corresponding namespace URI that will appear in the result tree.
The default namespace (as declared by xmlns) may be specified by using #default instead of a prefix.
If a namespace URI is declared to be an alias for multiple different namespace URIs, then the declaration with the highest import precedence is used.
It is an error if there is more than one such declaration.
An XSLT processor may signal the error; if it does not signal the error, it must recover by choosing, from amongst the declarations with the highest import precedence, the one that occurs last in the stylesheet.</span>
      </p>
      <p>
リテラル結果要素を XSLT 名前空間 URI を利用する 要素, 属性, 名前空間ノード の生成に利用する場合、エイリアスを利用しなければならなくなる。
例えば, 次のスタイルシート：
<span lang="en">
When literal result elements are being used to create element, attribute, or namespace nodes that use the XSLT namespace URI, the stylesheet must use an alias.
For example, the stylesheet</span>
      </p>
      <pre>&lt;xsl:stylesheet
  version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fo="http://www.w3.org/1999/XSL/Format"
  xmlns:axsl="http://www.w3.org/1999/XSL/TransformAlias"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;axsl:stylesheet&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/axsl:stylesheet&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="block"&gt;
  &lt;axsl:template match="{.}"&gt;
     &lt;fo:block&gt;&lt;axsl:apply-templates/&gt;&lt;/fo:block&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
      <p>
は、次の文書から XSLT スタイルシートを生成する。
<span lang="en">
will generate an XSLT stylesheet from a document of the form:</span>
      </p>
      <pre>&lt;elements&gt;
&lt;block&gt;p&lt;/block&gt;
&lt;block&gt;h1&lt;/block&gt;
&lt;block&gt;h2&lt;/block&gt;
&lt;block&gt;h3&lt;/block&gt;
&lt;block&gt;h4&lt;/block&gt;
&lt;/elements&gt;</pre>
      <blockquote>
<p>
<b>注記：</b>
XSLT 名前空間 URI 以外の名前空間でも、エイリアスを利用しなければならない局面がある。
例えば, リテラル結果要素がデジタル署名を扱う名前空間に属する場合、汎用のセキュリティソフトウェアによる XSLT スタイルシートの誤処理を呼ぶ可能性がある。
名前空間のエイリアスを利用することにより、このような誤処理の可能性を回避できる。
<span lang="en">
NOTE:It may be necessary also to use aliases for namespaces other than the XSLT namespace URI.
For example, literal result elements belonging to a namespace dealing with digital signatures might cause XSLT stylesheets to be mishandled by general-purpose security software; using an alias for the namespace would avoid the possibility of such mishandling.</span>
</p>
      </blockquote>

		</section>
		<section>

<h4 id="section-Creating-Elements-with-xsl:element" title="Creating Elements with xsl:element">7.1.2 <code>xsl:element</code> による要素の生成</h4>
      <pre class="element-syntax" id="element-element">
&lt;!-- 分類：instruction --&gt;
&lt;xsl:element
  <b>name</b> = { <var>qname</var> }
  namespace = { <var>uri-reference</var> }
  use-attribute-sets = <var>qnames</var>&gt;
  &lt;!-- 内容：<var>template</var> --&gt;
&lt;/xsl:element&gt;</pre>
      <p>
<code>xsl:element</code> 要素を用いて、式から算出される名前の要素を生成できる。
生成される要素の
<a href="xpath10-ja.html#dt-expanded-name">展開名</a>
は、必須の <code>name</code> 属性とオプションの <code>namespace</code> 属性で指定する。
<code>xsl:element</code> 要素の内容が、生成される要素の属性および子を生成するためのテンプレートである。
<span lang="en">
The xsl:element element allows an element to be created with a computed name.
The expanded-name of the element to be created is specified by a required name attribute and an optional namespace attribute.
The content of the xsl:element element is a template for the attributes and children of the created element.</span>
      </p>
      <p>
<code>name</code> 属性は、
<a href="#dt-attribute-value-template">属性値テンプレート</a>
として処理される。
属性値テンプレートをインスタンス化した結果の文字列が、
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
でない場合はエラーとする。
XSLT プロセッサは、エラーを通知してもよい。
エラーを通知しない場合、
 <code>xsl:element</code> 要素の内容から初期属性ノードを除いた部分をインスタンス化した一連のノードを <code>xsl:element</code> 要素のインスタンス化の結果とすることにより, エラーから回復しなければならない。
<span class="trans-note">【「初期属性ノード」 - initial attribute nodes の意味内容がはっきりしないが、要するに xsl:element に与えられた属性を指すものと思われる】</span>
<code>namespace</code> 属性が与えられていない場合、
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
は <code>xsl:element</code> 要素に対し有効な名前空間宣言（既定の名前空間宣言も含む）を利用して展開名へ展開される。
<span lang="en">
The name attribute is interpreted as an attribute value template.
It is an error if the string that results from instantiating the attribute value template is not a QName.
An XSLT processor may signal the error; if it does not signal the error, then it must recover by making the <del class="errata">the</del><!-- E28 --> result of instantiating the xsl:element element be the sequence of nodes created by instantiating the content of the xsl:element element, excluding any initial attribute nodes.
If the namespace attribute is not present then the QName is expanded into an expanded-name using the namespace declarations in effect for the xsl:element element, including any default namespace declaration.</span>
      </p>
      <p>
<code>namespace</code> 属性が与えられている場合、それも
<a href="#dt-attribute-value-template">属性値テンプレート</a>
として処理される。
そのインスタンス化による結果の文字列は URI 参照になるべきであるが、 URI 参照として構文的に正しくなくても, エラーではない。
結果の文字列が空になった場合、要素の展開名の名前空間 URI は null になる。
そうでない場合、生成される要素の展開名の名前空間 URI になる。
<code>name</code> 属性により指定される
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
の局所部は、生成される要素の展開名の局所部になる。
<span lang="en">
If the namespace attribute is present, then it also is interpreted as an attribute value template.
The string that results from instantiating the attribute value template should be a URI reference.
It is not an error if the string is not a syntactically legal URI reference.
If the string is empty, then the expanded-name of the element has a null namespace URI.
Otherwise, the string is used as the namespace URI of the expanded-name of the element to be created.
The local part of the QName specified by the name attribute is used as the local part of the expanded-name of the element to be created.</span>
      </p>
      <p>
XSLT プロセッサは、生成される要素を XML として出力するために接頭辞を選択する際に, <code>name</code> 属性で指定される
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
の接頭辞を利用してもよい。
ただし、これは必須ではない。
<span lang="en">
XSLT processors may make use of the prefix of the QName specified in the name attribute when selecting the prefix used for outputting the created element as XML; however, they are not required to do so.</span>
      </p>

		</section>
		<section>

<h4 id="creating-attributes">7.1.3 <code>xsl:attribute</code> による属性の生成</h4>
      <pre class="element-syntax" id="element-attribute">
&lt;!-- 分類：instruction --&gt;
&lt;xsl:attribute
  <b>name</b> = { <var>qname</var> }
  namespace = { <var>uri-reference</var> }&gt;
  &lt;!-- 内容：<var>template</var> --&gt;
&lt;/xsl:attribute&gt;</pre>
      <p>
<code>xsl:attribute</code> 要素を用いて, スタイルシートのリテラル結果要素や <code>xsl:element</code> などの命令から生成される結果要素に属性を追加できる。
生成される属性の
<a href="xpath10-ja.html#dt-expanded-name">展開名</a>
は、必須の <code>name</code> 属性とオプションの <code>namespace</code> 属性に指定する。
<code>xsl:attribute</code> 要素がインスタンス化されると、所属する結果要素ノードに属性ノードが追加される。
<code>xsl:attribute</code> 要素の内容が、生成される属性値のテンプレートである。
<span lang="en">
The xsl:attribute element can be used to add attributes to result elements whether created by literal result elements in the stylesheet or by instructions such as xsl:element.
The expanded-name of the attribute to be created is specified by a required name attribute and an optional namespace attribute.
Instantiating an xsl:attribute element adds an attribute node to the containing result element node.
The content of the xsl:attribute element is a template for the value of the created attribute.</span>
      </p>
      <p>
<code>name</code> 属性は
<a href="#dt-attribute-value-template">属性値テンプレート</a>
として処理される。
属性値テンプレートをインスタンス化した結果の文字列が,
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
でない場合や文字列 <code>xmlns</code> になる場合、エラーとする。
XSLT プロセッサは、エラーを通知してもよい。
エラーを通知しない場合、結果ツリーに属性を追加しないことにより, エラーから回復しなければならない。
<code>namespace</code> 属性が与えられていない場合、
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
は <code>xsl:element</code> 要素に対し有効な名前空間宣言（既定の名前空間宣言を<em>除く</em>）を利用して展開名へ展開される。
<span lang="en">
The name attribute is interpreted as an attribute value template.
It is an error if the string that results from instantiating the attribute value template is not a QName or is the string xmlns.
An XSLT processor may signal the error; if it does not signal the error, it must recover by not adding the attribute to the result tree.
If the namespace attribute is not present, then the QName is expanded into an expanded-name using the namespace declarations in effect for the xsl:attribute element, not including any default namespace declaration.</span>
      </p>
      <p>
<code>namespace</code> 属性が与えられている場合、それも
<a href="#dt-attribute-value-template">属性値テンプレート</a>
として処理される。
そのインスタンス化による結果の文字列は URI 参照になるべきであるが、 URI 参照として構文的に正しくなくても, エラーではない。
結果の文字列が空になった場合、属性の展開名の名前空間 URI は null になる。
そうでない場合、生成される属性の展開名の名前空間 URI になる。
<code>name</code> 属性により指定される
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
の局所部は、生成される属性の展開名の局所部になる。
<span lang="en">
If the namespace attribute is present, then it also is interpreted as an attribute value template.
The string that results from instantiating it should be a URI reference.
It is not an error if the string is not a syntactically legal URI reference.
If the string is empty, then the expanded-name of the attribute has a null namespace URI.
Otherwise, the string is used as the namespace URI of the expanded-name of the attribute to be created.
The local part of the QName specified by the name attribute is used as the local part of the expanded-name of the attribute to be created.</span>
      </p>
      <p>
XSLT プロセッサは、生成した属性を XML として出力するために接頭辞を選択する際, <code>name</code> 属性に指定されている
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
の接頭辞を利用してもよい。
ただし、これは必須ではなく、接頭辞が <code>xmlns</code> だった場合, これを利用してはならない。
次の例は、実行してもエラーにはならないが名前空間宣言は出力されない：
<span lang="en">
XSLT processors may make use of the prefix of the QName specified in the name attribute when selecting the prefix used for outputting the created attribute as XML; however, they are not required to do so and, if the prefix is xmlns, they must not do so.
Thus, although it is not an error to do:</span>
      </p>
      <pre>&lt;xsl:attribute name="xmlns:xsl" namespace="whatever"&gt;http://www.w3.org/1999/XSL/Transform&lt;/xsl:attribute&gt;</pre>
      <p>
&#160;
<span lang="en">
it will not result in a namespace declaration being output.</span>
      </p>
      <p>
要素に属性を追加すると、その要素と展開名が同じになる既存の属性は上書きされる。
<span lang="en">
Adding an attribute to an element replaces any existing attribute of that element with the same expanded-name.</span>
      </p>
      <p>

次に挙げるものは、すべてエラーとする：
<span lang="en">
The following are all errors:</span>
      </p>
      <ul>
         <li>
            <p>
要素に子を追加した後で、その要素に属性を追加すること。
実装はエラーを通知してもよいし、属性を無視してもよい。
<span lang="en">
Adding an attribute to an element after children have been added to it; implementations may either signal the error or ignore the attribute.</span>
            </p>
         </li>
         <li>
            <p>
要素でないノードに属性を追加すること。
実装はエラーを通知してもよいし、属性を無視してもよい。
<span lang="en">
Adding an attribute to a node that is not an element; implementations may either signal the error or ignore the attribute.</span>
            </p>
         </li>
         <li>
            <p>
<code>xsl:attribute</code> 要素の内容をインスタンス化する際に、テキストノード以外のノードを生成すること。
実装はエラーを通知してもよいし、エラーの要因になったノードを<ins class="errata">その内容と伴に</ins><!-- E27 -->無視してもよい。
<span lang="en">
Creating nodes other than text nodes during the instantiation of the content of the xsl:attribute element; implementations may either signal the error or ignore the offending nodes<ins class="errata"> together with their content</ins>.<!-- E27 --></span>
            </p>
         </li>
      </ul>
      <blockquote>
<p>
<b>注記：</b>
<code>xsl:attribute</code> が改行を伴うテキストノードを含む場合、 XML の出力においては文字参照にしなければならない。
例えば：
<span lang="en">
NOTE:When an xsl:attribute contains a text node with a newline, then the XML output must contain a character reference.
For example,</span>
</p>
  <pre>&lt;xsl:attribute name="a"&gt;x
y&lt;/xsl:attribute&gt;</pre>

<p>
による出力結果は：
<span lang="en">
  will result in the output
</span>
</p>
  <pre>a="x&amp;#xA;y"</pre>

<p>
（または同等の文字参照）。
XML の出力では、次は不可：
<span lang="en">
 (or with any equivalent character reference).
The XML output cannot be</span>
</p>

  <pre>a="x
y"</pre>

<p>
これは、 XML 1.0 では, 属性値に含まれる改行文字はスペースに正規化し, 改行文字を表す文字参照は正規化しないことが要求されているためである。
データモデル内の属性値は、正規化後の属性値を表現する。
ツリー内の属性値に現れた改行が、文字参照としてではなく, 改行文字として出力された場合、 XML を再び構文解析して生成されるツリー内の属性値の改行がスペースにすり替えられる, つまり ツリーが正しく出力されなかったことになる。
<span lang="en">
This is because XML 1.0 requires newline characters in attribute values to be normalized into spaces but requires character references to newline characters not to be normalized.
The attribute values in the data model represent the attribute value after normalization.
If a newline occurring in an attribute value in the tree were output as a newline character rather than as character reference, then the attribute value in the tree created by reparsing the XML would contain a space not a newline, which would mean that the tree had not been output correctly.</span>
</p>
      </blockquote>

		</section>
		<section>

<h4 id="attribute-sets" title="7.1.4 Named Attribute Sets">7.1.4 名前付き属性集合</h4>
      <pre class="element-syntax" id="element-attribute-set">
&lt;!-- 分類：top-level-element --&gt;
&lt;xsl:attribute-set
  <b>name</b> = <var>qname</var> 
  use-attribute-sets = <var>qnames</var>&gt;
  &lt;!-- 内容：<a href="#element-attribute">xsl:attribute</a>* --&gt;
&lt;/xsl:attribute-set&gt;</pre>
      <p>
<code>xsl:attribute-set</code> 要素は、名前の付いた属性の集合を定義する。
集合の名前は <code>name</code> 属性で指定する。
<code>name</code> 属性の値は
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
であり,
<a href="#qname">[<b>2.4 修飾名</b>]</a>
に則って展開される。
<code>xsl:attribute-set</code> 要素の内容は、集合に含まれる属性を指定する０個以上の <code>xsl:attribute</code> 要素からなる。
<span lang="en">
The xsl:attribute-set element defines a named set of attributes.
The name attribute specifies the name of the attribute set.
The value of the name attribute is a QName, which is expanded as described in [2.4 Qualified Names].
The content of the xsl:attribute-set element consists of zero or more xsl:attribute elements that specify the attributes in the set.</span>
      </p>
      <p>
属性の集合は <code>xsl:element</code> 要素, <code>xsl:copy</code> 要素（
<a href="#copying">[<b>7.5 複製</b>]</a>
を見よ）, <code>xsl:attribute-set</code> 要素の <code>use-attribute-sets</code> 属性から利用される。
<code>use-attribute-sets</code> 属性の値は、空白区切りの属性集合名からなるリストである。
名前はそれぞれ
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
として指定され,
<a href="#qname">[<b>2.4 修飾名</b>]</a>
に則って展開される。
<code>use-attribute-sets</code> 属性の指定は、属性集合名のリストに含まれる各名前が指す属性集合に含まれる <code>xsl:attribute</code> 要素を, <code>use-attribute-sets</code> 属性を与えた要素の内容の先頭に, 属性集合名のリストと同じ順序で追加することと等価である。<!-- □ -->
<span class="trans-note">【集合名の順序については言及されているが個々の属性（ xsl:attribute ）の順序までは言及されていない。おそらく xsl:attribute-set の内容におけるそれらの順序に従うものと思われるが。】</span>
<code>use-attribute-sets</code> 属性を <code>xsl:attribute-set</code> 要素に利用した結果, 属性集合が直接的に, または間接的に自身を参照する場合、エラーとする。
<span lang="en">
Attribute sets are used by specifying a use-attribute-sets attribute on xsl:element, xsl:copy (see [7.5 Copying]) or xsl:attribute-set elements.
The value of the use-attribute-sets attribute is a whitespace-separated list of names of attribute sets.
Each name is specified as a QName, which is expanded as described in [2.4 Qualified Names].

Specifying a use-attribute-sets attribute is equivalent to adding xsl:attribute elements for each of the attributes in each of the named attribute sets to the beginning of the content of the element with the use-attribute-sets attribute, in the same order in which the names of the attribute sets are specified in the use-attribute-sets attribute.

It is an error if use of use-attribute-sets attributes on xsl:attribute-set elements causes an attribute set to directly or indirectly use itself.</span>
      </p>
      <p>
リテラル結果要素においても、 <code>xsl:use-attribute-sets</code> を指定して, 属性集合を利用できる。
<code>xsl:use-attribute-sets</code> 属性の値は、空白区切りの属性集合名のリストである。

<code>xsl:use-attribute-sets</code> 属性は、 <code>xsl:element</code> に <code>use-attribute-sets</code> 属性を利用する場合と同じ効果を持ち, かつ 次の追加規則を持つ：リテラル結果要素に指定されている属性は、 <code>xsl:attribute</code> 要素により指定されたかのように扱われ, その指定位置が、実際の <code>xsl:attribute</code> 要素の手前, かつ <code>xsl:use-attribute-sets</code> 属性から暗黙的に指定される <code>xsl:attribute</code> 要素の後に来るものとみなす。

従って, リテラル結果要素においては、まず, <code>xsl:use-attribute-sets</code> 属性で与えられる名前付き属性集合に含まれる属性が属性内にリストされている順序で追加され、次に, リテラル結果要素に指定されている属性が追加され、最後に, <code>xsl:attribute</code> 要素に指定されている要素が追加されることになる。
要素に対する属性の追加は、要素に存在する同名の既存の属性を上書きするため, リテラル結果要素の属性で属性集合に含まれる属性を上書きできる。
<span lang="en">
Attribute sets can also be used by specifying an xsl:use-attribute-sets attribute on a literal result element.
The value of the xsl:use-attribute-sets attribute is a whitespace-separated list of names of attribute sets.

The xsl:use-attribute-sets attribute has the same effect as the use-attribute-sets attribute on xsl:element with the additional rule that attributes specified on the literal result element itself are treated as if they were specified by xsl:attribute elements before any actual xsl:attribute elements but after any xsl:attribute elements implied by the xsl:use-attribute-sets attribute.

Thus, for a literal result element, attributes from attribute sets named in an xsl:use-attribute-sets attribute will be added first, in the order listed in the attribute; next, attributes specified on the literal result element will be added; finally, any attributes specified by xsl:attribute elements will be added.

Since adding an attribute to an element replaces any existing attribute of that element with the same name, this means that attributes specified in attribute sets can be overridden by attributes specified on the literal result element itself.</span>
      </p>
      <p>
<code>xsl:attribute-set</code> 要素に含まれる各 <code>xsl:attribute</code> 要素内のテンプレートは、属性集合が利用される度にインスタンス化される。
このインスタンス化に用いられる現在のノードと現在のノードリストは、属性集合を利用する要素（ <code>use-attribute-sets</code> 属性または <code>xsl:use-attribute-sets</code> 属性を持つ要素）のインスタンス化に利用されるものと同じである。
一方, 変数束縛については、そのスコープを決定するのは <code>xsl:attribute</code> 要素のスタイルシート内における位置であって, 属性集合を利用する要素の位置ではない（
<a href="#variables">[<b>11 変数とパラメタ</b>]</a>
を見よ） 。
故に, 参照可能な変数とパラメタは、
<a href="#dt-top-level">トップレベル</a>
の <code>xsl:variable</code> 要素と <code>xsl:param</code> 要素が宣言したものに限られる。
<span lang="en">
The template within each xsl:attribute element in an xsl:attribute-set element is instantiated each time the attribute set is used; it is instantiated using the same current node and current node list as is used for instantiating the element bearing the use-attribute-sets or xsl:use-attribute-sets attribute.

However, it is the position in the stylesheet of the xsl:attribute element rather than of the element bearing the use-attribute-sets or xsl:use-attribute-sets attribute that determines which variable bindings are visible (see [11 Variables and Parameters]); thus, only variables and parameters declared by top-levelxsl:variable and xsl:param elements are visible.</span>
      </p>
      <p>
次の例は、 <code>title-style</code> という名前の属性集合を作成してテンプレートルールから利用している：
<span lang="en">
The following example creates a named attribute set title-style and uses it in a template rule.</span>
      </p>
      <pre>&lt;xsl:template match="chapter/heading"&gt;
  &lt;fo:block quadding="start" xsl:use-attribute-sets="title-style"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:attribute-set name="title-style"&gt;
  &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;</pre>
      <p>
同一の展開名の属性集合の定義が複数存在した場合、それらの定義は併合される。
<a href="#dt-import-precedence">インポート優先順位</a>
が他より高い定義からの属性が優先される。
同じ展開名とインポート優先順位を持つ属性集合が２つ存在し, それらが同じ属性を含む場合、より
<a href="#dt-import-precedence">インポート優先順位</a>
が高い, 同じ属性を持つ定義が存在しなければ、エラーとする。
XSLT プロセッサは、エラーを通知してもよい。
エラーを通知しない場合、それらの定義のうち, スタイルシートの最後方のものを選択することにより, エラーから回復しなければならない。
属性集合の中の属性定義の位置は、属性を集合に併合する際にのみ考慮され, 属性集合の利用時には区別されない。
<ins class="errata">
<code>xsl:attribute-set</code> 要素の <code>use-attribute-sets</code> 属性内の各属性集合名に対し、その名前を持つ属性集合の定義はすべて
<code>use-attribute-sets</code> 属性が等価な一連の <code>xsl:attribute</code> 子要素に置換される<em>前に</em>併合されなければならない。

<code>xsl:attribute-set</code> 要素の <code>use-attribute-sets</code> 属性はすべて、
<code>xsl:attribute-set</code> 要素が同じ展開名の他の <code>xsl:attribute-set</code> 要素と併合される<em>前に</em>, 等価な一連の <code>xsl:attribute</code> 子要素に置換されなければならない。

同じ展開名の <code>xsl:attribute-set</code> 要素が併合される際は、 <code>use-attribute-sets</code> 属性を置換するすべての <code>xsl:attribute</code> 子要素はスタイルシートの中で子要素として元々指定されていたかの様に扱われるものとする。
</ins><!-- E26 -->

<span lang="en">
Multiple definitions of an attribute set with the same expanded-name are merged. 

An attribute from a definition that has higher import precedence takes precedence over an attribute from a definition that has lower import precedence. 

It is an error if there are two attribute sets that have the same expanded-name and equal import precedence and that both contain the same attribute, unless there is a definition of the attribute set with higher import precedence that also contains the attribute. 

An XSLT processor may signal the error; if it does not signal the error, it must recover by choosing from amongst the definitions that specify the attribute that have the highest import precedence the one that was specified last in the stylesheet. 

Where the attributes in an attribute set were specified is relevant only in merging the attributes into the attribute set; it makes no difference when the attribute set is used.


<ins class="errata">
For each attribute set name occurring in a use-attribute-sets attribute on an xsl:attribute-set  element, all definitions of an attribute set with that name must be merged before the use-attribute-sets attribute is replaced by the equivalent sequence of xsl:attribute child elements. 

Any use-attribute-sets attribute on an xsl:attribute-set element must be replaced by the equivalent sequence of xsl:attribute child elements before that xsl:attribute-set element is merged with other xsl:attribute-set elements with the same expanded-name. 

When xsl:attribute-set elements with the same expanded-name are merged, any xsl:attribute child elements added to replace a use-attribute-sets attribute are treated exactly as if they had originally been specified in the stylesheet as child elements.
</ins><!-- E26 -->
</span>
      </p>

		</section>
	</section>
	<section>

<h3 id="section-Creating-Text" title="7.2 Creating Text">7.2 テキストの生成</h3>
      <p>
テンプレートは、テキストノードも含み得る。
<a href="#strip">[<b>3.4 空白の削除</b>]</a>
に則って空白の削除後にテンプレート内に残った各テキストノードは、結果ツリーの中で同一の文字列を持つテキストノードを生成する。
結果ツリーの中で隣接するテキストノードは自動的に連結されて一つに併合される。
<span lang="en">
A template can also contain text nodes. Each text node in a template remaining after whitespace has been stripped as specified in [3.4 Whitespace Stripping] will create a text node with the same string-value in the result tree.
Adjacent text nodes in the result tree are automatically merged.</span>
      </p>
      <p>
テキストはツリーレベルで処理されることに注意。
すなわち, テンプレート内のマークアップ <code>&amp;lt;</code> は、スタイルシートツリー内では, 文字 <code>&lt;</code> を含むテキストノードで表現される。
この文字は、結果ツリー内で文字 <code>&lt;</code> を含むテキストノードを生成する。
結果ツリーが XML 文書として外部に出力されると（
<a href="#disable-output-escaping">[<b>16.4 出力エスケープの無効化</b>]</a>
で述べるように出力エスケープが無効化されていない限り）、マークアップ <code>&amp;lt;</code> （または同等の文字参照）で表現される事になる。
<span lang="en">
Note that text is processed at the tree level.
Thus, markup of &amp;lt; in a template will be represented in the stylesheet tree by a text node that includes the character &lt;.
This will create a text node in the result tree that contains a &lt; character, which will be represented by the markup &amp;lt; (or an equivalent character reference) when the result tree is externalized as an XML document (unless output escaping is disabled as described in [16.4 Disabling Output Escaping]).</span>
      </p>
      <pre class="element-syntax" id="element-text">
&lt;!-- 分類：instruction --&gt;
&lt;xsl:text
  disable-output-escaping = "yes" | "no"&gt;
  &lt;!-- 内容：#PCDATA --&gt;
&lt;/xsl:text&gt;</pre>
      <p>
リテラル文字データは <code>xsl:text</code> 要素にくるむこともできる。
このラッピングは、どの空白文字が削除されるかを変更し得るが（
<a href="#strip">[<b>3.4 空白の削除</b>]</a>
を見よ）, その後の XSLT プロセッサによる文字の扱い方には影響しない。
<span lang="en">
Literal data characters may also be wrapped in an xsl:text element.
This wrapping may change what whitespace characters are stripped (see [3.4 Whitespace Stripping]) but does not affect how the characters are handled by the XSLT processor thereafter.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
<code>xml:lang</code> 属性と <code>xml:space</code> 属性は XSLT プロセッサからは特別に扱われない。
特に：
<span lang="en">
NOTE:The xml:lang and xml:space attributes are not treated specially by XSLT.
In particular,</span>
</p>
  <ul>
            <li>
               <p>
結果ツリーに必要になるすべての <code>xml:lang</code> 属性と <code>xml:space</code> 属性に関し、それらの明示的な生成はスタイルシート作成者が責を負う。
<span lang="en">
it is the responsibility of the stylesheet author explicitly to generate any xml:lang or xml:space attributes that are needed in the result;</span>
               </p>
            </li>
            <li>
               <p>
XSLT 名前空間の要素に <code>xml:lang</code> 属性や <code>xml:space</code> 属性を指定しても、結果に <code>xml:lang</code>属性や <code>xml:space</code> 属性を生じさせることはない。
<span lang="en">
specifying an xml:lang or xml:space attribute on an element in the XSLT namespace will not cause any xml:lang or xml:space attributes to appear in the result.</span>
               </p>
            </li>
         </ul>
      </blockquote>

	</section>
	<section>

<h3 id="section-Creating-Processing-Instructions" title="7.3 Creating Processing Instructions">7.3 処理命令の生成</h3>
      <pre class="element-syntax" id="element-processing-instruction">
&lt;!-- 分類：instruction --&gt;
&lt;xsl:processing-instruction
  <b>name</b> = { <var>ncname</var> }&gt;
  &lt;!-- 内容：<var>template</var> --&gt;
&lt;/xsl:processing-instruction&gt;</pre>
      <p>
<code>xsl:processing-instruction</code> 要素のインスタンス化により、処理命令ノードが生成される。
<code>xsl:processing-instruction</code> 要素の内容は、処理命令ノードの文字列値のテンプレートである。
<code>xsl:processing-instruction</code> 要素は、処理命令ノードの名前を指定する必須の <code>name</code> 属性を持つ。
<code>name</code> 属性の値は
<a href="#dt-attribute-value-template">属性値テンプレート</a>として処理される。
<span lang="en">
The xsl:processing-instruction element is instantiated to create a processing instruction node.
The content of the xsl:processing-instruction element is a template for the string-value of the processing instruction node.
The xsl:processing-instruction element has a required name attribute that specifies the name of the processing instruction node.
The value of the name attribute is interpreted as an attribute value template.</span>
      </p>
      <p>
例えば,
<span lang="en">
For example, this</span>
      </p>
      <pre>&lt;xsl:processing-instruction name="xml-stylesheet"&gt;href="book.css" type="text/css"&lt;/xsl:processing-instruction&gt;</pre>
      <p>
は、次の処理命令を生成する。
<span lang="en">
would create the processing instruction</span>
      </p>
      <pre>&lt;?xml-stylesheet href="book.css" type="text/css"?&gt;</pre>
      <p>
<code>name</code> 属性をインスタンス化した結果の文字列が,
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-NCName">NCName</a>
かつ
<a href="http://www.w3.org/TR/REC-xml/index.html#NT-PITarget">PITarget</a>
にならない場合、エラーとする。
XSLT プロセッサは、エラーを通知してもよい。
エラーを通知しない場合、結果ツリーに処理命令を追加しないことにより, エラーから回復しなければならない。
<span lang="en">
It is an error if the string that results from instantiating the name attribute is not both an NCName and a PITarget.
An XSLT processor may signal the error; if it does not signal the error, it must recover by not adding the processing instruction to the result tree.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
これは <code>xsl:processing-instruction</code> を XML 宣言の出力に利用できないことを意味する。
この目的には、代わりに <code>xsl:output</code> 要素（
<a href="#output">[<b>16 出力</b>]</a>
を見よ）を利用すべきである。
<span lang="en">
NOTE:This means that xsl:processing-instruction cannot be used to output an XML declaration.
The xsl:output element should be used instead (see [16 Output]).</span>
</p>
      </blockquote>
      <p>
<code>xsl:processing-instruction</code> の内容がインスタンス化される際に, テキストノード以外のノードが生成された場合、エラーとする。
XSLT プロセッサは、エラーを通知してもよい。
エラーを通知しない場合、問題が生じたノードとその内容を無視して, エラーから回復しなければならない。
<span lang="en">
It is an error if instantiating the content of xsl:processing-instruction creates nodes other than text nodes.
An XSLT processor may signal the error; if it does not signal the error, it must recover by ignoring the offending nodes together with their content.</span>
      </p>
      <p>
<code>xsl:processing-instruction</code> の内容がインスタンス化された結果に文字列 <code>?&gt;</code> が含まれる場合、エラーとする。
XSLT プロセッサは、エラーを通知してもよい。
エラーを通知しない場合、 <code>&gt;</code> が直後に続く <code>?</code> すべてに後ろに１個のスペースを挿入して, エラーから回復しなければならない。
<span lang="en">
It is an error if the result of instantiating the content of the xsl:processing-instruction contains the string ?&gt;.
An XSLT processor may signal the error; if it does not signal the error, it must recover by inserting a space after any occurrence of ? that is followed by a &gt;.</span>
      </p>

	</section>
	<section>

<h3 id="section-Creating-Comments" title="7.4 Creating Comments">7.4 コメントの生成</h3>
      <pre class="element-syntax" id="element-comment">
&lt;!-- 分類：instruction --&gt;
&lt;xsl:comment&gt;
  &lt;!-- 内容：<var>template</var> --&gt;
&lt;/xsl:comment&gt;</pre>
      <p>
<code>xsl:comment</code> 要素がインスタンス化されると、結果ツリー内にコメントノードが生成される。
<code>xsl:comment</code> 要素の内容は、コメントノードの文字列値のテンプレートである。
<span lang="en">
The xsl:comment element is instantiated to create a comment node in the result tree.
The content of the xsl:comment element is a template for the string-value of the comment node.</span>
      </p>
      <p>
例えば
<span lang="en">
For example, this</span>
      </p>
      <pre>&lt;xsl:comment&gt;This file is automatically generated.
Do not edit!&lt;/xsl:comment&gt;</pre>
      <p>
は、次のコメントを生成する。
<span lang="en">
would create the comment</span>
      </p>
      <pre>&lt;!--This file is automatically generated.
Do not edit!--&gt;</pre>
      <p>
<code>xsl:comment</code> の内容がインスタンス化される際に, テキストノード以外のノードが生成された場合、エラーとする。
XSLT プロセッサは、エラーを通知してもよい。
エラーを通知しない場合、問題の生じたノードとその内容を無視して, エラーから回復しなければならない。
<span lang="en">
It is an error if instantiating the content of xsl:comment creates nodes other than text nodes.
An XSLT processor may signal the error; if it does not signal the error, it must recover by ignoring the offending nodes together with their content.</span>
      </p>
      <p>
<code>xsl:comment</code> の内容がインスタンス化された結果に 文字列 <code>--</code> が含まれていたり, 末尾に <code>-</code> がある場合、エラーとする。
XSLT プロセッサは、エラーを通知してもよい。
エラーを通知しない場合、連続する <code>-</code> の間すべて, およびコメントの末尾の <code>-</code> の直後にスペースを１個挿入して, エラーから回復しなければならない。
<span lang="en">
It is an error if the result of instantiating the content of the xsl:comment contains the string -- or ends with -.
An XSLT processor may signal the error; if it does not signal the error, it must recover by inserting a space after any occurrence of - that is followed by another - or that ends the comment.</span>
      </p>

	</section>
	<section>

<h3 id="copying" title="7.5 Copying">7.5 複製</h3>
      <pre class="element-syntax" id="element-copy">
&lt;!-- 分類：instruction --&gt;
&lt;xsl:copy
  use-attribute-sets = <var>qnames</var>&gt;
  &lt;!-- 内容：<var>template</var> --&gt;
&lt;/xsl:copy&gt;</pre>
      <p>
<code>xsl:copy</code> 要素を利用すると、現在のノードを容易に複製できる。
<code>xsl:copy</code> 要素がインスタンス化されると、現在のノードの複製が生成される。
現在のノードの名前空間ノードも自動的に複製されるが, ノードの属性と子は自動的に複製されない。
<code>xsl:copy</code> 要素の内容は、生成されるノードの属性と子を生成するテンプレートである。
この内容は、属性や子を持てるノード型（すなわち、ルートノードと要素ノード）に限ってインスタンス化される。
<span lang="en">
The xsl:copy element provides an easy way of copying the current node.
Instantiating the xsl:copy element creates a copy of the current node.
The namespace nodes of the current node are automatically copied as well, but the attributes and children of the node are not automatically copied.
The content of the xsl:copy element is a template for the attributes and children of the created node; the content is instantiated only for nodes of types that can have attributes or children (i.e. root nodes and element nodes).</span>
      </p>
      <p>
<code>xsl:copy</code> 要素は <code>use-attribute-sets</code> 属性 （
<a href="#attribute-sets">[<b>7.1.4 名前付き属性の集合</b>]</a>
を見よ） を持てる。
この属性は、要素ノードを複製するときにのみ利用される。
<span lang="en">
The xsl:copy element may have a use-attribute-sets attribute (see [7.1.4 Named Attribute Sets]).
This is used only when copying element nodes.</span>
      </p>
      <p>
結果ツリーのルートノードは暗黙的に生成されるため、ルートノードだけは特別に扱われる。
現在のノードがルートノードだった場合、 <code>xsl:copy</code> はルートノードを生成せず, 単にその内容のテンプレートを利用する。
<span lang="en">
The root node is treated specially because the root node of the result tree is created implicitly.
When the current node is the root node, xsl:copy will not create a root node, but will just use the content template.</span>
      </p>
      <p>
例えば、恒等変換は <code>xsl:copy</code> を用いて次のように記述できる：
<span lang="en">
For example, the identity transformation can be written using xsl:copy as follows:</span>
      </p>
      <pre>&lt;xsl:template match="@*|node()"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="@*|node()"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</pre>
      <p>
現在のノードが属性ノードの場合、現在のノードと同名の属性を生成するために <code>xsl:attribute</code> を利用するとエラーになるような状況においては, <code>xsl:copy</code> の利用もエラーとする（
<a href="#creating-attributes">[<b>7.1.3 <code>xsl:attribute</code></b> による属性の生成]</a>
を見よ）。
<span lang="en">
When the current node is an attribute, then if it would be an error to use xsl:attribute to create an attribute with the same name as the current node, then it is also an error to use xsl:copy (see [7.1.3 Creating Attributes with xsl:attribute]).</span>
      </p>

<p class="errata"><!-- E25 -->
<ins class="errata">
現在のノードが名前空間ノードの場合、複製により, 結果ツリーにおいてその親ノードに名前空間ノードが追加される。
その親ノードが要素でなかった場合、エラーとする。
実装は、エラーを通知してもよいし, その名前空間ノードを無視してもよい。

要素に子ノードや属性ノードを追加した後に, 名前空間ノードを追加するのは、エラーとする。
実装は、エラーを通知してもよいし, その名前空間ノードを無視してもよい。

既に同じ名前の名前空間を持っている要素に名前空間ノードを追加した場合、２つの名前空間ノードが同じ
<a href="xpath10-ja.html#dt-string-value">文字列値</a>
でない限り（この場合の重複は無視される）, エラーとする。
null 名前空間 URI を持つ要素に null 名の名前空間ノードを追加するのは、エラーとする。</ins>
<span lang="en">
<ins class="errata">
When the current node is a namespace node, then copying it adds a namespace node to the containing node in the result tree.
It is an error if this containing node is not an element; implementations may either signal the error or ignore the namespace node.
It is an error to add a namespace node to an element after children have been added to it or after attributes have been added to it; implementations may either signal an error or ignore the namespace node.
It is an error to add a namespace node to an element if the element already has a namespace node with the same name, unless both namespace nodes have the same string-value, in which case the duplicate is ignored.
It is an error to add a namespace node to an element if the namespace node has a null name and the element has a null namespace URI.</ins>
</span>
</p>

      <p>
次の例に、ソースツリーから結果ツリーへの <code>xml:lang</code> 属性の複製がいかに容易かを示す。
スタイルシートに、次の名前付きテンプレートが定義されているとする：
<span lang="en">
The following example shows how xml:lang attributes can be easily copied through from source to result.
If a stylesheet defines the following named template:</span>
      </p>
      <pre>&lt;xsl:template name="apply-templates-copy-lang"&gt;
 &lt;xsl:for-each select="@xml:lang"&gt;
   &lt;xsl:copy/&gt;
 &lt;/xsl:for-each&gt;
 &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre>
      <p>
このとき, <code>xml:lang</code> 属性の複製は、単に
<span lang="en">
then it can simply do</span>
      </p>
      <pre>&lt;xsl:call-template name="apply-templates-copy-lang"/&gt;</pre>
      <p>
と記述すればよく,
<span lang="en">
instead of</span>
      </p>
      <pre>&lt;xsl:apply-templates/&gt;</pre>
      <p>
を用いる必要はない。
<span lang="en">
when it wants to copy the xml:lang attribute.</span>
      </p>

	</section>
	<section>

<h3 id="section-Computing-Generated-Text" title="7.6 Computing Generated Text">7.6 テキストの動的生成</h3>
      <p>
テンプレート内では, <code>xsl:value-of</code> 要素を、ソースツリーからのテキストの取得や変数の値の挿入など, 演算によるテキスト生成に利用できる。
この処理は
<code>xsl:value-of</code> 要素の <code>select</code> 属性の値に指定された
<a href="#dt-expression">式</a>
を用いて行われる。
式は、リテラル結果要素の属性値においても波括弧（ <code>{}</code> ）に括って利用できる。
<span lang="en">
Within a template, the xsl:value-of element can be used to compute generated text, for example by extracting text from the source tree or by inserting the value of a variable. 

The xsl:value-of element does this with an expression that is specified as the value of the select attribute. 

Expressions can also be used inside attribute values of literal result elements by enclosing the expression in curly braces ({}).</span>
      </p>

		<section>

<h4 id="value-of">7.6.1 <code>xsl:value-of</code> によるテキストの生成</h4>
      <pre class="element-syntax" id="element-value-of">
&lt;!-- 分類：instruction --&gt;
&lt;xsl:value-of
  <b>select</b> = <var>string-expression</var> 
  disable-output-escaping = "yes" | "no" /&gt;</pre>
      <p>
<code>xsl:value-of</code> 要素がインスタンス化されると、結果ツリー内にテキストノードが生成される。
必須の <code>select</code> 属性の値は
<a href="#dt-expression">式</a>
である。
この式が評価されると、
<b><a href="xpath10-ja.html#function-string">string</a></b>
関数が呼び出されたかのように, 結果のオブジェクトが文字列に変換される。
この文字列が、生成されるテキストノードの文字列値を与える。
文字列が空になった場合、テキストノードは生成されない。
生成されるテキストノードは、隣接するすべてのテキストノードと連結され一つに併合される。
<span lang="en">
The xsl:value-of element is instantiated to create a text node in the result tree.
The required select attribute is an expression; this expression is evaluated and the resulting object is converted to a string as if by a call to the string function.
The string specifies the string-value of the created text node.
If the string is empty, no text node will be created.
The created text node will be merged with any adjacent text nodes.</span>
      </p>
      <p>
<code>xsl:copy-of</code> 要素を利用して、ノード集合を文字列に変換することなく, 結果ツリーに複製できる。
<a href="#copy-of">[<b>11.3 <code >xsl:copy-of</code> における変数とパラメタの値の利用</b> ]</a>
を見よ。
<span lang="en">
The xsl:copy-of element can be used to copy a node-set over to the result tree without converting it to a string.
See [11.3 Using Values of Variables and Parameters with xsl:copy-of].</span>
      </p>
      <p>
下の例は <code>given-name</code> 属性と <code>family-name</code> 属性を持つ <code>person</code> 要素から HTML の段落を生成する。
段落には、現在のノードの <code>given-name</code> 属性の値, １個のスペース, 現在のノードの <code>family-name</code> 属性の値 が、この順で挿入されることになる。
<span lang="en">
For example, the following creates an HTML paragraph from a person element with given-name and family-name attributes.
The paragraph will contain the value of the given-name attribute of the current node followed by a space and the value of the family-name attribute of the current node.</span>
      </p>
      <pre>&lt;xsl:template match="person"&gt;
  &lt;p&gt;
   &lt;xsl:value-of select="@given-name"/&gt;
   &lt;xsl:text&gt; &lt;/xsl:text&gt;
   &lt;xsl:value-of select="@family-name"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;</pre>
      <p>
次の例は、 <code>given-name</code> 要素と <code>family-name</code> 要素を子に持つ <code>person</code> 要素から, HTML の段落を生成する。
段落には、現在のノードの最初の <code>given-name</code> 子要素の文字列値, １個のスペース, 現在のノードの最初の <code>family-name</code> 子要素の文字列値 が、この順で挿入されることになる。
<span lang="en">
For another example, the following creates an HTML paragraph from a person element with given-name and family-name children elements.
The paragraph will contain the string-value of the first given-name child element of the current node followed by a space and the string-value of the first family-name child element of the current node.</span>
      </p>
      <pre>&lt;xsl:template match="person"&gt;
  &lt;p&gt;
   &lt;xsl:value-of select="given-name"/&gt;
   &lt;xsl:text&gt; &lt;/xsl:text&gt;
   &lt;xsl:value-of select="family-name"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;</pre>
      <p>
次の例では、各 <code>procedure</code> 要素の最初に, procedure のセキュリティレベルを含む段落を配置させる。
ここでは, 各「手続き」（ procedure ）に適用されるセキュリティレベルが <code>procedure</code> 要素またはその先祖要素の <code>security</code> 属性から決定されていて、 <code>security</code> 属性を持つ要素が複数存在する場合のセキュリティレベルは <code>procedure</code> 要素から最も近い要素から決定されるものと見なされている。
<span lang="en">
The following precedes each procedure element with a paragraph containing the security level of the procedure. 

It assumes that the security level that applies to a procedure is determined by a security attribute on the procedure element or on an ancestor element of the procedure. 

It also assumes that if more than one such element has a security attribute then the security level is determined by the element that is closest to the procedure.</span>
      </p>
      <pre>&lt;xsl:template match="procedure"&gt;
  &lt;fo:block&gt;
    &lt;xsl:value-of select="ancestor-or-self::*[@security][1]/@security"/&gt;
  &lt;/fo:block&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre>

		</section>
		<section>

<h4 id="attribute-value-templates" title="7.6.2 Attribute Value Templates">7.6.2 属性値テンプレート</h4>
      <p>
リテラル結果要素の属性など, <dfn id="dt-attribute-value-template">属性値テンプレート</dfn> として処理される属性値においては、波括弧（ <code>{}</code> ）で括られた
<a href="#dt-expression">式</a>
を利用できる。
属性値テンプレートは、式とそれを括る波括弧を式の評価結果に置換し, 結果のオブジェクトを
<b><a href="xpath10-ja.html#function-string">string</a></b>
関数が呼び出されたかのように文字列に変換することにより, インスタンス化される。
XSLT スタイルシートの属性においては、属性値を属性値テンプレートとして処理するものと明示的に指定される属性を除き, 属性値内の波括弧は認識されない。
要素の<a href="#notation" >構文要約</a>においては、このような属性の値は波括弧で括られている。
<span lang="en">
In an attribute value that is interpreted as an attribute value template, such as an attribute of a literal result element, an expression can be used by surrounding the expression with curly braces ({}).
The attribute value template is instantiated by replacing the expression together with surrounding curly braces by the result of evaluating the expression and converting the resulting object to a string as if by a call to the string function.
Curly braces are not recognized in an attribute value in an XSLT stylesheet unless the attribute is specifically stated to be one that is interpreted as an attribute value template; in an element syntax summary, the value of such attributes is surrounded by curly braces.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
すべての属性が属性値テンプレートに解釈されるわけではない。
値が式またはパターンの属性,
<a href="#dt-top-level">トップレベル</a>
要素の属性, 名前が付けられた XSLT オブジェクトを参照する属性は、属性値テンプレートに解釈されない。
加えて、 <code>xmlns</code> 属性も属性値テンプレートには解釈されない。
このような処理は XML 名前空間勧告に適合しないからである。
<span lang="en">
NOTE:Not all attributes are interpreted as attribute value templates.
Attributes whose value is an expression or pattern, attributes of top-level elements and attributes that refer to named XSLT objects are not interpreted as attribute value templates.
In addition, xmlns attributes are not interpreted as attribute value templates; it would not be conformant with the XML Namespaces Recommendation to do this.</span>
</p>
      </blockquote>
      <p>
次の例は <code>img</code> 結果要素を、ソース内の <code>photograph</code> 要素から生成する。
<code>img</code> 要素の <code>src</code> 属性の値は、 <code>image-dir</code> 変数の値と <code>photograph</code> 要素の <code>href</code> 子要素の文字列値から算出される。
<code>img</code> 要素の <code>width</code> 属性の値は <code>photograph</code> 要素の <code>size</code> 子要素の <code>width</code> 属性の値から算出される。
<span lang="en">
The following example creates an img result element from a photograph element in the source; the value of the src attribute of the img element is computed from the value of the image-dir variable and the string-value of the href child of the photograph element; the value of the width attribute of the img element is computed from the value of the width attribute of the size child of the photograph element:</span>
      </p>
      <pre>&lt;xsl:variable name="image-dir"&gt;/images&lt;/xsl:variable&gt;

&lt;xsl:template match="photograph"&gt;
&lt;img src="{$image-dir}/{href}" width="{size/@width}"/&gt;
&lt;/xsl:template&gt;</pre>
      <p>

次のソース
<span lang="en">
With this source</span>
      </p>
      <pre>&lt;photograph&gt;
  &lt;href&gt;headquarters.jpg&lt;/href&gt;
  &lt;size width="300"/&gt;
&lt;/photograph&gt;</pre>
      <p>
から生成される結果は次のようになる：
<span lang="en">
the result would be</span>
      </p>
      <pre>&lt;img src="/images/headquarters.jpg" width="300"/&gt;</pre>
      <p>
属性値テンプレートがインスタンス化される際は, 式の外側の右または左２重波括弧は、１重波括弧に置換される。
式の外側の属性値テンプレートでは, 右波括弧の後ろに２つ目の右波括弧がない場合、エラーとする。
<!-- □？？ -->
式の
<a href="xpath10-ja.html#NT-Literal">Literal</a>
内の右波括弧は、式を終了する波括弧とは認識されない。
<span lang="en">
When an attribute value template is instantiated, a double left or right curly brace outside an expression will be replaced by a single curly brace.
It is an error if a right curly brace occurs in an attribute value template outside an expression without being followed by a second right curly brace.
A right curly brace inside a Literal in an expression is not recognized as terminating the expression.</span>
      </p>
      <p>
波括弧が式内部で再帰的に認識されることは<em>ない</em>。
例えば：
<span lang="en">
Curly braces are not recognized recursively inside expressions.
For example:</span>
      </p>
      <pre style="color: red">&lt;a href="#{id({@ref})/title}"&gt;</pre>
      <p>
は認められ<em>ない</em>。
代わりに、単に次のように表記する：
<span lang="en">
is not allowed. Instead, use simply:</span>
      </p>
      <pre>&lt;a href="#{id(@ref)/title}"&gt;</pre>

		</section>
	</section>
	<section>

<h3 id="number" title="7.7 Numbering">7.7 番号付け</h3>
      <pre class="element-syntax" id="element-number">
&lt;!-- 分類：instruction --&gt;
&lt;xsl:number
  level = "single" | "multiple" | "any"
  count = <var>pattern</var> 
  from = <var>pattern</var> 
  value = <var>number-expression</var> 
  format = { <var>string</var> }
  lang = { <var>nmtoken</var> }
  letter-value = { "alphabetic" | "traditional" }
  grouping-separator = { <var>char</var> }
  grouping-size = { <var>number</var> } /&gt;</pre>
      <p>
<code>xsl:number</code> 要素は、結果ツリーにフォーマット化した数値を挿入するために利用される。
挿入する数値は、式で指定してもよい。
<code>value</code> 属性の値は
<a href="#dt-expression">式</a>
を含む。
この式が評価されると、結果のオブジェクトは
<b><a href="xpath10-ja.html#function-number">number</a></b>
関数を呼び出したかのように数値に変換される。
<ins class="errata"><!-- E24 -->
数値が NaN, infinite になった場合, または 0.5 より小さくなった場合、エラーとする。
XSLT プロセッサは、エラーを通知してもよい。
エラーを通知しない場合、数値を
<b><a href="xpath10-ja.html#function-string">string</a></b> 
関数を呼び出したかのように文字列に変換して, エラーから回復しなければならない。
他の場合、
</ins>
この数値は整数に丸められ,
<a href="#convert">[<b>7.7.1 数値から文字列への変換属性</b>]</a>
で述べる属性により文字列に変換される。
この処理において、これらの属性値はそれぞれ
<a href="#dt-attribute-value-template">属性値テンプレート</a>
として処理される。
変換後の結果の文字列が結果ツリーに挿入される。

次の例は、ソートされたリストに番号付けを行う。
<span lang="en">
The xsl:number element is used to insert a formatted number into the result tree.
The number to be inserted may be specified by an expression.
The value attribute contains an expression.
The expression is evaluated and the resulting object is converted to a number as if by a call to the number function.

<ins class="errata">
It is an error if the number is NaN, infinite or less than 0.5; an XSLT processor may signal the error; if it does not signal the error, it must recover by converting the number to a string as if by a call to the string  function and inserting the resulting string into the result tree.
Otherwise,
</ins><!-- E24 -->

The number is rounded to an integer and then converted to a string using the attributes specified in [7.7.1 Number to String Conversion Attributes]; in this context, the value of each of these attributes is interpreted as an attribute value template.
After conversion, the resulting string is inserted in the result tree.
For example, the following example numbers a sorted list:</span>
      </p>
      <pre>&lt;xsl:template match="items"&gt;
  &lt;xsl:for-each select="item"&gt;
    &lt;xsl:sort select="."/&gt;
    &lt;p&gt;
      &lt;xsl:number value="position()" format="1. "/&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/p&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</pre>
      <p>
<code>value</code> 属性が指定されていない場合、 <code>xsl:number</code> 要素はソースツリー内の現在のノード位置に基づいて数値を挿入する。
次に挙げる属性は、現在のノードに対する番号付けの方法を制御する。
<span lang="en">
If no value attribute is specified, then the xsl:number element inserts a number based on the position of the current node in the source tree.
The following attributes control how the current node is to be numbered:</span>
      </p>
      <ul>
         <li>
            <p>
<code>level</code> 属性は、対象とすべきソースツリーのレベルを指定する。
この属性の値は、 <code>single</code>, <code>multiple</code>, <code>any</code> のいずれかになる。
既定値は <code>single</code> 。
<span lang="en">
The level attribute specifies what levels of the source tree should be considered; it has the values single, multiple or any.
The default is single.</span>
            </p>
         </li>
         <li>
            <p>
<code>count</code> 属性は、上で指定したレベルにおいて, カウント対象にすべきノードを指定するパターンを与える。
<code>count</code> 属性が指定されていない場合、現在のノードと同じノード型を持つすべてのノードに合致するパターンが既定の値として用いられ, 現在のノードが展開名を持っている場合は、同じ展開名を持つすべてのノードに合致するパターンが既定の値として用いられる。
<span lang="en">
The count attribute is a pattern that specifies what nodes should be counted at those levels.
If count attribute is not specified, then it defaults to the pattern that matches any node with the same node type as the current node and, if the current node has an expanded-name, with the same expanded-name as the current node.</span>
            </p>
         </li>
         <li>
            <p>
<code>from</code> 属性は、カウントの開始位置を指定するパターンを与える。
<span lang="en">
The from attribute is a pattern that specifies where counting starts.</span>
            </p>
         </li>
      </ul>
      <p>
加えて, 数値から文字列への変換には、 <code>value</code> 属性が指定された場合と同様に
<a href="#convert">[<b>7.7.1 数値から文字列への変換属性</b>]</a>
で述べる属性が利用される。
<span lang="en">
In addition, the attributes specified in [7.7.1 Number to String Conversion Attributes] are used for number to string conversion, as in the case when the value attribute is specified.</span>
      </p>
      <p>
<code>xsl:number</code> 要素は、まず, <code>level</code> 属性, <code>count</code> 属性, <code>from</code> 属性から正の整数のリストを構築する。
<span lang="en">
The xsl:number element first constructs a list of positive integers using the level, count and from attributes:</span>
      </p>
      <ul>
         <li>
            <p>
<code>level="single"</code> の場合、 ancestor-or-self 軸の中で <code>count</code> パターンに合致する最初のノードまで遡り, その先祖の前にある同胞ノードのうち <code>count</code> パターンに合致する同胞ノードの総数に１を加えた値１個からなるリストを構築する。
そのような先祖が存在しない場合、リストは空とする。
<code>from</code> 属性が指定されている場合、検索される先祖の範囲は <code>from</code> パターンに合致する最も近い先祖の子孫に限られる。
（ここで, 前にある同胞とは、 <code>preceding-sibling</code> 軸に入るノードを意味する。）
<span lang="en">
When level="single", it goes up to the first node in the ancestor-or-self axis that matches the count pattern, and constructs a list of length one containing one plus the number of preceding siblings of that ancestor that match the count pattern.
If there is no such ancestor, it constructs an empty list.
If the from attribute is specified, then the only ancestors that are searched are those that are descendants of the nearest ancestor that matches the from pattern.
Preceding siblings has the same meaning here as with the preceding-sibling axis.</span>
            </p>
         </li>
         <li>
            <p>
<code>level="multiple"</code> の場合、現在のノードのすべての先祖を文書順に並べ, この要素自身を最後に加えたリストを構築する。
次に, このリストから <code>count</code> パターンに合致するノードのみを残し, 他を取り除く。
最後に, リストに含まれる各ノードを、そのノードの前にある同胞ノードのうち, <code>count</code> パターンに合致する同胞ノードの総数に１を加えた数に置き換える。

<code>from</code> 属性が指定されている場合、検索される先祖の範囲は <code>from</code> パターンに合致する最も近い先祖の子孫に限られる。
（ここで, 前にある同胞とは、 <code>preceding-sibling</code> 軸に入るノードを意味する。）
<span lang="en">
When level="multiple", it constructs a list of all ancestors of the current node in document order followed by the element itself; it then selects from the list those nodes that match the count pattern; it then maps each node in the list to one plus the number of preceding siblings of that node that match the count pattern.
If the from attribute is specified, then the only ancestors that are searched are those that are descendants of the nearest ancestor that matches the from pattern.
Preceding siblings has the same meaning here as with the preceding-sibling axis.</span>
            </p>
         </li>
         <li>
            <p>
<code>level="any"</code> の場合、現在のノードと（文書内のレベルを問わず）文書順で現在のノードの前にあるノードのうち, 名前空間ノードと属性ノードを除くすべてのノードの集合（すなわち <code>preceding</code> 軸と <code>ancestor-or-self</code> 軸に入るノードの和集合）の中で, <code>count</code> パターンに合致するものの総数１個からなるリストを構築する。

<ins class="errata">合致するものが存在しない場合、リストは空とする。
</ins>

<code>from</code> 属性が指定されている場合、検索されるノードの範囲は <code>from</code> パターンに最初に合致するノードより後のノードに限られる。

<span lang="en">
When level="any", it constructs a list of length one containing the number of nodes that match the count pattern and belong to the set containing the current node and all nodes at any level of the document that are before the current node in document order, excluding any namespace and attribute nodes (in other words the union of the members of the preceding and ancestor-or-self axes). 

<ins class="errata">If there are no matching nodes, it constructs an empty list.</ins>

If the from attribute is specified, then only nodes after the first node before the current node that match the from pattern are considered.</span>
            </p>
         </li>
      </ul>
      <p>
次に、上で構築した数のリストを
<a href="#convert">[<b>7.7.1 数値から文字列への変換属性</b>]</a>
で述べる属性を用いて文字列に変換する。
この処理においては, これらの属性値は、それぞれ
<a href="#dt-attribute-value-template">属性値テンプレート</a>
として処理される。
変換後の結果の文字列が結果ツリーに挿入される。
<!-- 【リストの個々の値に対し行う】 -->
<span lang="en">
The list of numbers is then converted into a string using the attributes specified in [7.7.1 Number to String Conversion Attributes]; in this context, the value of each of these attributes is interpreted as an attribute value template.
After conversion, the resulting string is inserted in the result tree.</span>
      </p>
      <p>
次の例は、順序付きリスト（ <code>ol</code> ）の項目（ <code>item</code> ）に対する番号付けを行なう。
<span lang="en">
The following would number the items in an ordered list:</span>
      </p>
      <pre>&lt;xsl:template match="ol/item"&gt;
  &lt;fo:block&gt;
    &lt;xsl:number/&gt;&lt;xsl:text&gt;. &lt;/xsl:text&gt;&lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;xsl:template&gt;</pre>
      <p>
次の２つのルールは、 <code>title</code> 要素に番号付けを行う。
この例では、一連の <code>chapter</code> と後続の <code>appendix</code> を含む文書が意図されている。
これらの <code>chapter</code> と <code>appendix</code> のいずれも <code>section</code> を含み, <code>section</code> は <code>subsection</code> を含んでいるとする。
<code>chapter</code> は 1, 2, 3, ... , <code>appendix</code> は A, B, C, ... , <code>chapter</code> の中の <code>section</code> は 1.1, 1.2, 1.3, ...,  <code>appendix</code> の中の <code>section</code> は A.1, A.2, A.3, ... のような形に番号が振られる。
<span lang="en">
The following two rules would number title elements.
This is intended for a document that contains a sequence of chapters followed by a sequence of appendices, where both chapters and appendices contain sections, which in turn contain subsections.
Chapters are numbered 1, 2, 3; appendices are numbered A, B, C; sections in chapters are numbered 1.1, 1.2, 1.3; sections in appendices are numbered A.1, A.2, A.3.</span>
      </p>
      <pre>&lt;xsl:template match="title"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="chapter|section|subsection"
                 format="1.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="appendix//title" priority="1"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="appendix|section|subsection"
                 format="A.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>
      <p>

次の例は、 <code>chapter</code> の中の <code>note</code> に番号付けを行う：
<span lang="en">
The following example numbers notes sequentially within a chapter:</span>
      </p>
      <pre>&lt;xsl:template match="note"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="any" from="chapter" format="(1) "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>
      <p>

次の例では、 HTML の <code>H4</code> 要素に対し、３部分からなるラベルで番号付けを行う：
<span lang="en">
The following example would number H4 elements in HTML with a three-part label:</span>
      </p>
      <pre>&lt;xsl:template match="H4"&gt;
 &lt;fo:block&gt;
   &lt;xsl:number level="any" from="H1" count="H2"/&gt;
   &lt;xsl:text&gt;.&lt;/xsl:text&gt;
   &lt;xsl:number level="any" from="H2" count="H3"/&gt;
   &lt;xsl:text&gt;.&lt;/xsl:text&gt;
   &lt;xsl:number level="any" from="H3" count="H4"/&gt;
   &lt;xsl:text&gt; &lt;/xsl:text&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>

		<section>

<h4 id="convert" title="7.7.1 Number to String Conversion Attributes">7.7.1 数値から文字列への変換の属性</h4>
      <p>
以下の属性は、数値のリストを文字列へ変換する際の制御に利用される。
数値は正整数とする。
属性はすべてオプションである。
<span lang="en">
The following attributes are used to control conversion of a list of numbers into a string.
The numbers are integers greater than 0.
The attributes are all optional.</span>
      </p>
      <p>
主要な属性は <code>format</code> である。
<code>format</code> 属性の既定値は <code>1</code>である。
<code>format</code> 属性は、トークンのシーケンスに分割される。
各トークンは、英数文字の最長シーケンスまたは非英数文字の最長シーケンスである。
英数文字とは, Nd, Nl, No, Lu, Ll, Lt, Lm, Lo いずれかの Unicode 分類に入る文字を意味する。
英数文字トークン（フォーマットトークン）は、リスト内の各数値に用いるフォーマットを指定する。
最初のトークンが非英数文字のトークンであれば、構築される文字列はそのトークンから始まり, 最後のトークンが非英数文字のトークンであれば、構築される文字列はそのトークンで終わることになる。
２つのフォーマットトークンの間に現れる非英数文字のトークンは、リスト内の数値を結合する区切りトークンである。
<var>n</var> 番目のフォーマットトークンは、リスト内の <var>n</var> 番目の数値のフォーマットに利用される。
フォーマットトークンより数値の個数が多い場合、最後のフォーマットトークンが残りの数値のフォーマットに利用される。
フォーマットトークンが存在しない場合、フォーマットトークン <code>1</code> がすべての数値のフォーマットに利用される。
フォーマットトークンは、数値の 1 の表現に用いられる文字列を指定する。
２番目以降の各数値は、その数値のフォーマットに利用するフォーマットトークンの前にある区切りトークンにより, 手前の数値と区切られる。
区切りトークンが存在しない場合、文字 <code>.</code> （ピリオド）が区切りに利用される。
<span lang="en">
The main attribute is format.
The default value for the format attribute is 1.
The format attribute is split into a sequence of tokens where each token is a maximal sequence of alphanumeric characters or a maximal sequence of non-alphanumeric characters.

Alphanumeric means any character that has a Unicode category of Nd, Nl, No, Lu, Ll, Lt, Lm or Lo. 
The alphanumeric tokens (format tokens) specify the format to be used for each number in the list. 
If the first token is a non-alphanumeric token, then the constructed string will start with that token; 
if the last token is non-alphanumeric token, then the constructed string will end with that token. 
Non-alphanumeric tokens that occur between two format tokens are separator tokens that are used to join numbers in the list. 
The nth format token will be used to format the nth number in the list.
If there are more numbers than format tokens, then the last format token will be used to format remaining numbers.
If there are no format tokens, then a format token of 1 is used to format all numbers.
The format token specifies the string to be used to represent the number 1.
Each number after the first will be separated from the preceding number by the separator token preceding the format token used to format that number, or, if there are no separator tokens, then by .
(a period character).</span>
      </p>
      <p>
フォーマットトークンは、 HTML 4.0 の <code>OL</code> 要素の <code>type</code> 属性で利用できる値のスーパーセットであり, 次のように解釈される：
<span lang="en">
Format tokens are a superset of the allowed values for the type attribute for the OL element in HTML 4.0 and are interpreted as follows:</span>
      </p>
      <ul>
         <li>
            <p>
最後の文字が（ Unicode の文字プロパティデータベースで規定された）十進数の 1 で終わり, その前の文字の Unicode 値が最後の文字の Unicode 値より 1 小さくなるような, すべてのトークンは、各数が少なくともフォーマットトークンの長さ以上になる十進数表現を生成する。
従って、フォーマットトークン <code>1</code> はフォーマット列 <code>1 2 ... 10 11 12 ...</code> を生成し, フォーマットトークン <code>01</code> はフォーマット列 <code>01 02 ... 09 10 11 12 ... 99 100 101</code> を生成する。
<span lang="en">
Any token where the last character has a decimal digit value of 1 (as specified in the Unicode character property database), 
and the Unicode value of preceding characters is one less than the Unicode value of the last character generates a decimal representation of the number where each number is at least as long as the format token. 

Thus, a format token 1 generates the sequence 1 2 ... 10 11 12 ..., and a format token 01 generates the sequence 01 02 ... 09 10 11 12 ... 99 100 101.</span>
            </p>
         </li>
         <li>
            <p>
フォーマットトークン <code>A</code> はフォーマット列 <code>A B C ... Z AA AB AC...</code> を生成する。
<span lang="en">
A format token A generates the sequence A B C ... Z AA AB AC....</span>
            </p>
         </li>
         <li>
            <p>
フォーマットトークン <code>a</code> はフォーマット列 <code>a b c ... z aa ab ac...</code> を生成する。
<span lang="en">
A format token a generates the sequence a b c ... z aa ab ac....</span>
            </p>
         </li>
         <li>
            <p>
フォーマットトークン <code>i</code> はフォーマット列 <code>i ii iii iv v vi vii viii ix x ...</code> を生成する。
<span lang="en">
A format token i generates the sequence i ii iii iv v vi vii viii ix x ....</span>
            </p>
         </li>
         <li>
            <p>
フォーマットトークン <code>I</code> はフォーマット列 <code>I II III IV V VI VII VIII IX X ...</code> を生成する。
<span lang="en">
A format token I generates the sequence I II III IV V VI VII VIII IX X ....</span>
            </p>
         </li>
         <li>
            <p>
その他のフォーマットトークンは、そのトークンから始まる番号付け規則を指示する。
実装は、あるトークンで始まる番号付け規則をサポートしていない場合、フォーマットトークン <code>1</code> を利用しなければならない。
<span lang="en">
Any other format token indicates a numbering sequence that starts with that token.
If an implementation does not support a numbering sequence that starts with that token, it must use a format token of 1.</span>
            </p>
         </li>
      </ul>
      <p>
アルファベット順に番号付けを行う際には、 <code>lang</code> 属性がどの言語のアルファベットを利用するかを指定する。
この属性は、<code>xml:lang</code>
<a href="#XML">[XML]</a>
と同じ範囲の値をとる。
<code>lang</code> が指定されていない場合、システム環境から言語を決定すべきである。
実装側は、番号付けをサポートする言語の種類を文書化しておくべきである。
<span lang="en">
When numbering with an alphabetic sequence, the lang attribute specifies which language's alphabet is to be used; it has the same range of values as xml:lang[XML]; if no lang value is specified, the language should be determined from the system environment.
Implementers should document for which languages they support numbering.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
実装側は、特定の言語に対する番号付けのふるまいを仮定せず, サポートしようとする言語を正確に調べるべきである。
多くの言語では、番号付けの慣行が英語とは大きく異なる。
<span lang="en">
NOTE:Implementers should not make any assumptions about how numbering works in particular languages and should properly research the languages that they wish to support.
The numbering conventions of many languages are very different from English.</span>
</p>
      </blockquote>
      <p>
<code>letter-value</code> 属性は、文字を用いる番号付けに生じる多義性を排除する。
多くの言語では、一般的に利用されている文字による番号付けに２種類の方法が存在する。
一つは数値をアルファベット順に文字に割り振る方法であり、もう一つはその言語で伝統的に用いられる別の作法になる。
英語の場合、これらの作法はフォーマットトークン <code>a</code> と <code>i</code> で指定される番号付け規則に対応する。
一部の言語では、異なるフォーマット列の最初の文字が同じため, フォーマットトークンだけではあいまいになる。
値に <code>alphabetic</code> を指定した場合はアルファベット順が適用され、 <code>traditional</code> を指定した場合はもう一方の規則が適用される。
<code>letter-value</code> 属性が指定されていない場合、あいまいさの解決は実装依存になる。
<span lang="en">
The letter-value attribute disambiguates between numbering sequences that use letters.
In many languages there are two commonly used numbering sequences that use letters.
One numbering sequence assigns numeric values to letters in alphabetic sequence, and the other assigns numeric values to each letter in some other manner traditional in that language.
In English, these would correspond to the numbering sequences specified by the format tokens a and i.
In some languages, the first member of each sequence is the same, and so the format token alone would be ambiguous.
A value of alphabetic specifies the alphabetic sequence; a value of traditional specifies the other sequence.
If the letter-value attribute is not specified, then it is implementation-dependent how any ambiguity is resolved.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
規定に適合する２つの XSLT プロセッサによる数値の文字列への変換結果が、完全に一致しない場合がある。
XSLT プロセッサには一部の言語をサポートしないものもあり得る。
さらに, <code>xsl:number</code> の属性による指定では不可能な特定の言語においては、変換の実行に様々な方法があり得る。
将来版の XSLT には、このようなバリエーションを制御する属性の追加が検討されている。
実装は、この目的で実装固有の名前空間の属性を <code>xsl:number</code> に用いてもよい。
<span lang="en">
NOTE:It is possible for two conforming XSLT processors not to convert a number to exactly the same string.
Some XSLT processors may not support some languages.
Furthermore, there may be variations possible in the way conversions are performed for any particular language that are not specifiable by the attributes on xsl:number.
Future versions of XSLT may provide additional attributes to provide control over these variations.
Implementations may also use implementation-specific namespaced attributes on xsl:number for this.</span>
</p>
      </blockquote>
      <p>
<code>grouping-separator</code> 属性は、十進記数法におけるグループ分け（例えば 1000 単位）の区切り記号を与える。
<code>grouping-size</code> 属性で, そのグループ化のサイズ（通常は 3 ）を指定する。
例えば <code>grouping-separator=","</code>, <code>grouping-size="3"</code> とした場合、 <code>1,000,000</code> の形式の数値が生成される。
<code>grouping-separator</code> 属性と <code>grouping-size</code> 属性の一方のみしか指定されていない場合、その指定は無視される。
<span lang="en">
The grouping-separator attribute gives the separator used as a grouping (e.g. thousands) separator in decimal numbering sequences, and the optional grouping-size specifies the size (normally 3) of the grouping.
For example, grouping-separator="," and grouping-size="3" would produce numbers of the form 1,000,000.
If only one of the grouping-separator and grouping-size attributes is specified, then it is ignored.</span>
      </p>
      <p>
以下に, 変換指定の例を示す。
<span lang="en">
Here are some examples of conversion specifications:</span>
      </p>
      <ul>
         <li>
            <p>
<code>format="&amp;#x30A2;"</code> は、五十音順のカタカナによる番号付けを指定する。
<span lang="en">
format="&amp;#x30A2;" specifies Katakana numbering</span>
            </p>
         </li>
         <li>
            <p>
<code>format="&amp;#x30A4;"</code> は、「いろは」順のカタカナによる番号付けを指定する。
<span lang="en">
format="&amp;#x30A4;" specifies Katakana numbering in the "iroha" order</span>
            </p>
         </li>
         <li>
            <p>
<code>format="&amp;#x0E51;"</code> は、タイ数字による番号付けを指定する。
<span lang="en">
format="&amp;#x0E51;" specifies numbering with Thai digits</span>
            </p>
         </li>
         <li>
            <p>
<code>format="&amp;#x05D0;" letter-value="traditional"</code> は、ヘブライ語の「伝統的」番号付けを指定する。
<span lang="en">
format="&amp;#x05D0;" letter-value="traditional" specifies "traditional" Hebrew numbering</span>
            </p>
         </li>
         <li>
            <p>
<code>format="&amp;#x10D0;" letter-value="traditional"</code> は、グルジア語による番号付けを指定する。
<span lang="en">
format="&amp;#x10D0;" letter-value="traditional" specifies Georgian numbering</span>
            </p>
         </li>
         <li>
            <p>
<code>format="&amp;#x03B1;" letter-value="traditional"</code> は、「古典」ギリシア語による番号付けを指定する。
<span lang="en">
format="&amp;#x03B1;" letter-value="traditional" specifies "classical" Greek numbering</span>
            </p>
         </li>
         <li>
            <p>
<code>format="&amp;#x0430;" letter-value="traditional"</code> は、古スラヴ語による番号付けを指定する。
<span lang="en">
format="&amp;#x0430;" letter-value="traditional" specifies Old Slavic numbering</span>
            </p>
         </li>
      </ul>

		</section>
	</section>
</section>
<section>

<h2 id="for-each" title="8 Repetition">8 繰り返し</h2>
      <pre class="element-syntax" id="element-for-each">
&lt;!-- 分類：instruction --&gt;
&lt;xsl:for-each
  <b>select</b> = <var>node-set-expression</var>&gt;
  &lt;!-- 内容：(<a href="#element-sort">xsl:sort</a>*, <var>template</var>) --&gt;
&lt;/xsl:for-each&gt;</pre>
      <p>
結果が規則的な構造を持つことが明らかな場合、選択したノードに直接テンプレートを指定できる機能が有用になる。
<code>xsl:for-each</code> 命令は１個のテンプレートを含む。
このテンプレートは、 <code>select</code> 属性に指定された
<a href="#dt-expression">式</a>
によって選択される各ノードごとにインスタンス化される。
<code>select</code> 属性の指定は必須である。
式の評価結果はノード集合でなければならない。
このテンプレートは、選択したノードを
<a href="#dt-current-node">現在のノード</a>
に利用し, 選択した全ノードのリストを
<a href="#dt-current-node-list">現在のノードリスト</a>
に利用してインスタンス化される。
ノードは、ソートの指定がなければ（
<a href="#sorting">[<b>10 ソート</b>]</a>
を見よ）, 文書順に処理される。
<span lang="en">
When the result has a known regular structure, it is useful to be able to specify directly the template for selected nodes.
The xsl:for-each instruction contains a template, which is instantiated for each node selected by the expression specified by the select attribute.
The select attribute is required.
The expression must evaluate to a node-set.
The template is instantiated with the selected node as the current node, and with a list of all of the selected nodes as the current node list.
The nodes are processed in document order, unless a sorting specification is present (see [10 Sorting]).</span>
      </p>
      <p>
例えば, 次の構造の XML 文書：
<span lang="en">
For example, given an XML document with this structure</span>
      </p>
      <pre>&lt;customers&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
&lt;/customers&gt;</pre>
      <p>
に対し、次のものは, 各 <code>customer</code> 要素に対応する行を持つテーブルを含む HTML 文書を生成する。
<span lang="en">
the following would create an HTML document containing a table with a row for each customer element</span>
      </p>
      <pre>&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Customers&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;xsl:for-each select="customers/customer"&gt;
            &lt;tr&gt;
              &lt;th&gt;
                &lt;xsl:apply-templates select="name"/&gt;
              &lt;/th&gt;
              &lt;xsl:for-each select="order"&gt;
                &lt;td&gt;
                  &lt;xsl:apply-templates/&gt;
                &lt;/td&gt;
              &lt;/xsl:for-each&gt;
            &lt;/tr&gt;
          &lt;/xsl:for-each&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;</pre>

</section>
<section>

<h2 id="section-Conditional-Processing" title="9 Conditional Processing">9 条件処理</h2>
      <p>
XSLT には、テンプレートにおける条件処理をサポートする２つの命令： <code>xsl:if</code> および <code>xsl:choose</code> がある。
<code>xsl:if</code> 命令は、単純な if-then による条件処理を行い, <code>xsl:choose</code> 命令は、選択肢がいくつかある中での選択処理をサポートする。
<span lang="en">
There are two instructions in XSLT that support conditional processing in a template: xsl:if and xsl:choose.
The xsl:if instruction provides simple if-then conditionality; the xsl:choose instruction supports selection of one choice when there are several possibilities.</span>
      </p>

	<section>

<h3 id="section-Conditional-Processing-with-xsl:if">9.1 <code>xsl:if</code> による条件処理</h3>
      <pre class="element-syntax" id="element-if">
&lt;!-- 分類：instruction --&gt;
&lt;xsl:if
  <b>test</b> = <var>boolean-expression</var>&gt;
  &lt;!-- 内容：<var>template</var> --&gt;
&lt;/xsl:if&gt;</pre>
      <p>
<code>xsl:if</code> 要素は
<a href="#dt-expression">式</a>
を指定する <code>test</code> 属性を持つ。
要素の内容はテンプレートである。
式が評価されると、結果のオブジェクトは 
<b><a href="xpath10-ja.html#function-boolean">boolean</a></b>
関数を呼び出したかのようにブール型に変換され, 結果が真の場合、内容のテンプレートがインスタンス化され, そうでなければ何も生成されない。

次の例は <code>namelist</code> に含まれる <code>name</code> をコンマ区切りのリストにフォーマットする：
<span lang="en">
The xsl:if element has a test attribute, which specifies an expression.
The content is a template.
The expression is evaluated and the resulting object is converted to a boolean as if by a call to the boolean function.
If the result is true, then the content template is instantiated; otherwise, nothing is created.
In the following example, the names in a group of names are formatted as a comma separated list:</span>
      </p>
      <pre>&lt;xsl:template match="namelist/name"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:if test="not(position()=last())"&gt;, &lt;/xsl:if&gt;
&lt;/xsl:template&gt;</pre>
      <p>

次の例は、表の行を１行おきに <code>yellow</code> にする：
<span lang="en">
The following colors every other table row yellow:</span>
      </p>
      <pre>&lt;xsl:template match="item"&gt;
  &lt;tr&gt;
    &lt;xsl:if test="position() mod 2 = 0"&gt;
       &lt;xsl:attribute name="bgcolor"&gt;yellow&lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;</pre>

	</section>
	<section>

<h3 id="section-Conditional-Processing-with-xsl:choose">9.2 <code>xsl:choose</code> による条件処理</h3>
      <pre class="element-syntax" id="element-choose">
&lt;!-- 分類：instruction --&gt;
&lt;xsl:choose&gt;
  &lt;!-- 内容：(<a href="#element-when">xsl:when</a>+, <a href="#element-otherwise">xsl:otherwise</a>?) --&gt;
&lt;/xsl:choose&gt;</pre>
      <pre class="element-syntax" id="element-when">
&lt;xsl:when
  <b>test</b> = <var>boolean-expression</var>&gt;
  &lt;!-- 内容：<var>template</var> --&gt;
&lt;/xsl:when&gt;</pre>
      <pre class="element-syntax" id="element-otherwise">
&lt;xsl:otherwise&gt;
  &lt;!-- 内容：<var>template</var> --&gt;
&lt;/xsl:otherwise&gt;</pre>
      <p>
<code>xsl:choose</code> 要素は、いくつかの選択肢の中から一つを選択する。
この要素の内容は、一連の <code>xsl:when</code> 要素と, 後続するオプションの <code>xsl:otherwise</code> 要素からなる。
各 <code>xsl:when</code> 要素は
<a href="#dt-expression">式</a>
を指定する１個の属性 <code>test</code> を持つ。
<code>xsl:when</code> 要素と <code>xsl:otherwise</code> 要素の内容は、テンプレートである。

<code>xsl:choose</code> 要素の処理においては、各 <code>xsl:when</code> 要素が順番にテストされる。
各テストでは、 <code>test</code> に与えた式が評価され, その結果のオブジェクトが
<b><a href="xpath10-ja.html#function-boolean">boolean</a></b>
関数を呼び出しかのようにブール型に変換される。
テスト結果が真になる <code>xsl:when</code> 要素のうち、最初の要素の内容のみがインスタンス化される。
テスト結果が真になる <code>xsl:when</code> が存在しない場合、 <code>xsl:otherwise</code> 要素の内容がインスタンス化される。
テスト結果が真の <code>xsl:when</code> 要素が存在せず, <code>xsl:otherwise</code> 要素も存在しない場合、何も生成されない。
<span lang="en">
The xsl:choose element selects one among a number of possible alternatives.
It consists of a sequence of xsl:when elements followed by an optional xsl:otherwise element.
Each xsl:when element has a single attribute, test, which specifies an expression.
The content of the xsl:when and xsl:otherwise elements is a template.
When an xsl:choose element is processed, each of the xsl:when elements is tested in turn, by evaluating the expression and converting the resulting object to a boolean as if by a call to the boolean function.
The content of the first, and only the first, xsl:when element whose test is true is instantiated.
If no xsl:when is true, the content of the xsl:otherwise element is instantiated.
If no xsl:when element is true, and no xsl:otherwise element is present, nothing is created.</span>
      </p>
      <p>
次の例は、順序付きリスト（ <code>orderedlist</code> ）の各項目（ <code>item</code> ）に対し、リストの入れ子の深さに応じて, アラビア数字, アルファベット, ローマ数字による番号を振る。
<span lang="en">
The following example enumerates items in an ordered list using arabic numerals, letters, or roman numerals depending on the depth to which the ordered lists are nested.</span>
      </p>
      <pre>&lt;xsl:template match="orderedlist/listitem"&gt;
  &lt;fo:list-item indent-start='2pi'&gt;
    &lt;fo:list-item-label&gt;
      &lt;xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test='$level=1'&gt;
          &lt;xsl:number format="i"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:when test='$level=2'&gt;
          &lt;xsl:number format="a"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:number format="1"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;/fo:list-item-label&gt;
    &lt;fo:list-item-body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/fo:list-item-body&gt;
  &lt;/fo:list-item&gt;
&lt;/xsl:template&gt;</pre>

	</section>
</section>
<section>

<h2 id="sorting" title="10 Sorting">10 ソート処理</h2>
      <pre class="element-syntax" id="element-sort">
&lt;xsl:sort
  select = <var>string-expression</var> 
  lang = { <var>nmtoken</var> }
  data-type = { "text" | "number" | <var>qname-but-not-ncname</var> }
  order = { "ascending" | "descending" }
  case-order = { "upper-first" | "lower-first" } /&gt;</pre>
      <p>
ソートを指定するには、 <code>xsl:apply-templates</code> 要素または <code>xsl:for-each</code> 要素の子に, <code>xsl:sort</code> 要素を与える。
１番目の <code>xsl:sort</code> 子要素が１次ソートキーを指定し, ２番目の <code>xsl:sort</code> 子要素が２次ソートキーを指定し, 以下同様である。

<code>xsl:apply-templates</code> 要素または <code>xsl:for-each</code> 要素に１個以上の <code>xsl:sort</code> 子要素が含まれている場合、選択されたノードは文書順ではなく, 指定されたソートキーに従ったソート処理が施された後の順序で処理される。
<code>xsl:for-each</code> 要素で利用する場合、 <code>xsl:sort</code> 要素は先頭に置かれなければならない。
テンプレートが <code>xsl:sort</code> 要素を子に含む <code>xsl:apply-templates</code> または <code>xsl:for-each</code> によりインスタンス化される際の
<a href="#dt-current-node-list">現在のノードリスト</a>
は、処理対象ノードすべてをソート後の順序に整列させたリストになる。
<span lang="en">
Sorting is specified by adding xsl:sort elements as children of an xsl:apply-templates or xsl:for-each element.
The first xsl:sort child specifies the primary sort key, the second xsl:sort child specifies the secondary sort key and so on.
When an xsl:apply-templates or xsl:for-each element has one or more xsl:sort children, then instead of processing the selected nodes in document order, it sorts the nodes according to the specified sort keys and then processes them in sorted order.
When used in xsl:for-each, xsl:sort elements must occur first.
When a template is instantiated by xsl:apply-templates and xsl:for-each, the current node list <del class="errata">list</del><!-- E22 --> consists of the complete list of nodes being processed in sorted order.</span>
      </p>
      <p>
<code>xsl:sort</code> は
<a href="#dt-expression">式</a>
を値にとる <code>select</code> 属性を持つ。
処理される各ノードに対し、そのノードを現在のノードに, 処理されるノードの<!-- <del class="errata">ソートしていない</del> --><ins class="errata">文書順の</ins>完全なリストを現在のノードリストにして、この式が評価される。
結果のオブジェクトは
<b><a href="xpath10-ja.html#function-string">string</a></b>
関数を呼び出したかのように文字列に変換され, この文字列がノードのソートキーに利用される。
<code>select</code> 属性の既定値は <code>.</code> であり, その値の場合、現在のノードの文字列値がソートキーに利用される。
<span lang="en">
xsl:sort has a select attribute whose value is an expression. 

For each node to be processed, the expression is evaluated with that node as the current node and with the complete list of nodes being processed in <!-- E21 --><del class="errata">unsorted</del> <ins class="errata"> document</ins> order as the current node list. 

The resulting object is converted to a string as if by a call to the string function; this string is used as the sort key for that node. 
The default value of the select attribute is ., which will cause the string-value of the current node to be used as the sort key.</span>
      </p>
      <p>
この文字列が、ノードのソートキーの役割を果たす。
以下に挙げる <code>xsl:sort</code> の属性はオプションであり, ソートキーのリストをどのようにソートするかを制御する。
これらの属性の値はすべて
<a href="#dt-attribute-value-template">属性値テンプレート</a>
として処理される。
<span lang="en">
This string serves as a sort key for the node.
The following optional attributes on xsl:sort control how the list of sort keys are sorted; the values of all of these attributes are interpreted as attribute value templates.</span>
      </p>
      <ul>
         <li>
            <p>
<code>order</code> は、文字列のソートを昇順か降順のどちらで行うべきかを指定する。
値 <code>ascending</code> （既定）は昇順, 値 <code>descending</code> は降順を指定する。
               <span lang="en">
order specifies whether the strings should be sorted in ascending or descending order; ascending specifies ascending order; descending specifies descending order; the default is ascending</span>
            </p>
         </li>
         <li>
            <p>
<code>lang</code> は、どの言語に基づいてソートを行うかを指定する。
値の範囲は <code>xml:lang</code>
<a href="#XML">[XML]</a>
と同じである。
<code>lang</code> が指定されていない場合、言語はシステム環境から決定されるべきである。
<span lang="en">
lang specifies the language of the sort keys; it has the same range of values as xml:lang[XML]; if no lang value is specified, the language should be determined from the system environment</span>
            </p>
         </li>
         <li>
            <p>
<code>data-type</code> は、文字列のデータ型を指定する。
次に挙げる値を利用できる。
<span lang="en">
data-type specifies the data type of the strings; the following values are allowed:</span>
            </p>
            <ul>
               <li>
                  <p>
<code>text</code> は、 <code>lang</code> に指定された言語文化圏の慣用に則った辞書式順序により, ソートキーがソートされるべきであることを指定する。
                     <span lang="en">
text specifies that the sort keys should be sorted lexicographically in the culturally correct manner for the language specified by lang</span>
                  </p>
               </li>
               <li>
                  <p>
<code>number</code> は、ソートキーを
<b><a href="xpath10-ja.html#function-number">number</a></b>
関数を呼び出したかのように数値に変換し、その値に従ってソートを行うこと指定する。
この場合 <code>lang</code> 属性は無視される。
<ins class="errata">
昇順においては、 NaN は他のすべての数値より先になり, 降順では後になる。
</ins>
<!-- E20 -->
<span lang="en">
number specifies that the sort keys should be converted to numbers and then sorted according to the numeric value; the sort key is converted to a number as if by a call to the number function; the lang attribute is ignored

<ins class="errata">; in ascending order a NaN precedes all other numeric values and in descending order it follows them</ins>
</span>
                  </p>
               </li>
               <li>
                  <p>
接頭辞付きの
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
は
<a href="#qname">[<b>2.4 修飾名</b>]</a>
に則って
<a href="xpath10-ja.html#dt-expanded-name">展開名</a>
に展開され、その展開名からデータ型が識別される。
この仕様では、この場合のふるまいは指定しない。
<span lang="en">
a QName with a prefix is expanded into an expanded-name as described in [2.4 Qualified Names]; the expanded-name identifies the data-type; the behavior in this case is not specified by this document</span>
                  </p>
               </li>
            </ul>
            <p>
この属性の既定値は <code>text</code> である。
<span lang="en">
The default value is text.</span>
            </p>
            <blockquote>
<p>
<b>注記：</b>
XSL 作業グループでは、 XML Schema を活用して将来版の XSLT においてこの属性に追加の値を定義することを予定している。
<span lang="en">
NOTE:The XSL Working Group plans that future versions of XSLT will leverage XML Schemas to define further values for this attribute.</span>
</p>
            </blockquote>
         </li>
         <li>
            <p>
<code>case-order</code> の値は <code>upper-first</code> または <code>lower-first</code> である。
この属性は <code>data-type="text"</code> を指定している場合に限り有効になり、それぞれ, <ins class="errata">昇順において</ins><!-- E19 -->大文字と小文字のどちらを先にすべきかを指定する。
例えば <code>lang="en"</code> の場合、 <code>case-order="upper-first"</code> ならば<ins class="errata">昇順における</ins>ソートは <code>A a B b</code> の順になり,  <code>case-order="lower-first"</code> ならば<ins class="errata">昇順における</ins>ソートは <code>a A b B</code> の順になる。
<ins class="errata">降順においては正反対になる。
例えば <code>lang="en"</code> の場合、 <code >case-order="upper-first"</code> ならば降順ソートは <code >b B a A</code> の順になる。
</ins>
既定の値は言語に依存する。
<span lang="en">
case-order has the value upper-first or lower-first; this applies when data-type="text", and specifies that
<ins class="errata">in ascending order</ins>
upper-case letters should sort before lower-case letters or vice-versa respectively.
For example, if lang="en", then A a B b are sorted 
<ins class="errata">in ascending order</ins>
with case-order="upper-first" and a A b B are sorted
<ins class="errata">in ascending order</ins>
with case-order="lower-first". 
<ins class="errata"> In descending order, the effect is reversed.
For example, if lang="en", then b B a A are sorted in descending order with case-order="upper-first".</ins>
The default value is language dependent.</span>
            </p>
         </li>
      </ul>
      <blockquote>
<p>
<b>注記：</b>
規定に適合する２つの XSLT プロセッサによるソート結果が完全に一致しない場合もある。
更に、どの言語にも <code>xsl:sort</code> の属性では指定できないソートのバリエーションが存在し得る。
例えば日本語の場合、ひらがなとカタカナのどちらを優先するかなど。
将来版の XSLT には、このようなバリエーションを制御する属性の追加が検討されている。
実装は、この目的で実装固有の名前空間の属性を <code>xsl:sort</code> に用いてもよい。
<span lang="en">
NOTE:It is possible for two conforming XSLT processors not to sort exactly the same.
Some XSLT processors may not support some languages.
Furthermore, there may be variations possible in the sorting of any particular language that are not specified by the attributes on xsl:sort, for example, whether Hiragana or Katakana is sorted first in Japanese.
Future versions of XSLT may provide additional attributes to provide control over these variations.
Implementations may also use implementation-specific namespaced attributes on xsl:sort for this.</span>
</p>
      </blockquote>
      <blockquote>
<p>
<b>注記：</b>
実装者は、多言語対応のソート処理に関し
<a href="#UNICODE-TR10">[UNICODE TR10]</a>
を参考にすることが推奨される。
<span lang="en">
NOTE:It is recommended that implementers consult [UNICODE TR10] for information on internationalized sorting.</span>
</p>
      </blockquote>
      <p>
ソートは安定ソートでなければならない。
すなわち、ソート順で等しいソートキーを持つ複数のノードはソート後においても文書順に並んでいなければならない。
<span lang="en">
The sort must be stable: in the sorted list of nodes, any sub list that has sort keys that all compare equal must be in document order.</span>
      </p>
      <p>
次のような形の <code>employee</code> （従業員）のデータベースを例にとる：
<span lang="en">
For example, suppose an employee database has the form</span>
      </p>
      <pre>&lt;employees&gt;
  &lt;employee&gt;
    &lt;name&gt;
      &lt;given&gt;James&lt;/given&gt;
      &lt;family&gt;Clark&lt;/family&gt;
    &lt;/name&gt;
    ...
  &lt;/employee&gt;
&lt;/employees&gt;</pre>
      <p>
このとき, 従業員の <code>name</code> によるソートのリストは、次のようにして生成できる：
<span lang="en">
Then a list of employees sorted by name could be generated using:</span>
      </p>
      <pre>&lt;xsl:template match="employees"&gt;
  &lt;ul&gt;
    &lt;xsl:apply-templates select="employee"&gt;
      &lt;xsl:sort select="name/family"/&gt;
      &lt;xsl:sort select="name/given"/&gt;
    &lt;/xsl:apply-templates&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="employee"&gt;
  &lt;li&gt;
    &lt;xsl:value-of select="name/given"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="name/family"/&gt;
  &lt;/li&gt;
&lt;/xsl:template&gt;</pre>

</section>
<section>

<h2 id="variables" title="11 Variables and Parameters">11 変数とパラメタ</h2>
      <pre class="element-syntax" id="element-variable">
&lt;!-- 分類：top-level-element --&gt;
&lt;!-- 分類：instruction --&gt;
&lt;xsl:variable
  <b>name</b> = <var>qname</var> 
  select = <var>expression</var>&gt;
  &lt;!-- 内容：<var>template</var> --&gt;
&lt;/xsl:variable&gt;</pre>
      <pre class="element-syntax" id="element-param">
&lt;!-- 分類：top-level-element --&gt;
&lt;xsl:param
  <b>name</b> = <var>qname</var> 
  select = <var>expression</var>&gt;
  &lt;!-- 内容：<var>template</var> --&gt;
&lt;/xsl:param&gt;</pre>
      <p>
変数とは、値に結びつけられ得る名前である。
変数が束縛される値（変数の<b>値</b>）は、式の返せる型であれば, どのような型のオブジェクトでもよい。
変数の束縛に利用できる要素には、<code>xsl:variable</code> と <code>xsl:param</code> の２つがある。
<code>xsl:param</code> 変数に指定される値は、束縛の既定値に限るという点が両者の違いになる。
<code>xsl:param</code> 要素を含むテンプレートやスタイルシートは、呼び出される際に既定値になり代わって利用されるパラメタを渡し得る。
<span lang="en">
A variable is a name that may be bound to a value.
The value to which a variable is bound (the value of the variable) can be an object of any of the types that can be returned by expressions. 
There are two elements that can be used to bind variables: xsl:variable and xsl:param.
The difference is that the value specified on the xsl:param variable is only a default value for the binding; when the template or stylesheet within which the xsl:param element occurs is invoked, parameters may be passed that are used in place of the default values.</span>
      </p>
      <p>
<code>xsl:variable</code> と <code>xsl:param</code> のいずれも <code>name</code> 属性は必須である。
この属性は変数の名前を指定する。
<code>name</code> 属性の値は
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
であり、この値は
<a href="#qname">[<b>2.4 修飾名</b>]</a>
に則って展開される。
<span lang="en">
Both xsl:variable and xsl:param have a required name attribute, which specifies the name of the variable.
The value of the name attribute is a QName, which is expanded as described in [2.4 Qualified Names].</span>
      </p>
      <p>
これらの変数束縛要素（ Variable-binding element ）の利用においては、束縛が見える（スコープに入る）スタイルシートツリーの範囲は限定される。

<!-- 
<del class="errata">
この範囲内では、変数束縛要素自身から見えていた変数束縛はすべて隠蔽される。そのため、もっとも内側にある変数束縛のみが見える。
</del>
 -->
ある式から見える変数束縛の集合は、スタイルシートにその式が現れる場所から見える束縛からなる。
<span lang="en">
For any use of these variable-binding elements, there is a region of the stylesheet tree within which the binding is visible
<del class="errata">; within this region, any binding of the variable that was visible on the variable-binding element itself is hidden.
Thus, only the innermost binding of a variable is visible</del>.

The set of variable bindings in scope for an expression consists of those bindings that are visible at the point in the stylesheet where the expression occurs.</span>
      </p>

	<section>

<h3 id="section-Result-Tree-Fragments" title="11.1 Result Tree Fragments">11.1 結果ツリー素片</h3>
      <p>
変数は式言語に新しいデータ型を導入する。
この追加のデータ型を、 <dfn id="dt-result-tree-fragment">結果ツリー素片</dfn> と呼ぶ。
変数を XPath の４種の基本データ型（ string, number, boolean, node-set ）のいずれかではなく、結果ツリー素片に束縛してもよい。
結果ツリー素片は、結果ツリーの素片を表現する。
結果ツリー素片は、ルートノード１個のみからなるノード集合と等価に扱われる。
ただし、結果ツリー素片に許容される演算は、ノード集合に許容される演算のサブセットになる。
文字列に許容される演算のみが、結果ツリー素片に許容される（文字列に対する演算には、最初に数値やブール型に変換する処理も含まれ得る）。
特に, 結果ツリー素片に対しては演算子 <code>/</code>, <code>//</code>, <code>[]</code> は許容されない。
結果ツリー素片に許容される演算は、等価なノード集合に対する演算と全く同じに実行される。
<span lang="en">
Variables introduce an additional data-type into the expression language.
This additional data type is called result tree fragment.
A variable may be bound to a result tree fragment instead of one of the four basic XPath data-types (string, number, boolean, node-set).
A result tree fragment represents a fragment of the result tree.
A result tree fragment is treated equivalently to a node-set that contains just a single root node.
However, the operations permitted on a result tree fragment are a subset of those permitted on a node-set.
An operation is permitted on a result tree fragment only if that operation would be permitted on a string (the operation on the string may involve first converting the string to a number or boolean).
In particular, it is not permitted to use the /, //, and [] operators on result tree fragments.
When a permitted operation is performed on a result tree fragment, it is performed exactly as it would be on the equivalent node-set.</span>
      </p>
      <p>
結果ツリー素片が結果ツリーに複製される際は（
<a href="#copy-of">[<b>11.3 <code >xsl:copy-of</code> における変数とパラメタの値の利用</b>]</a>
を見よ）、その結果ツリー素片と等価なノード集合におけるルートノードのすべての子ノードが、連続する形で結果ツリーに追加される。
<!-- □ -->
<span lang="en">
When a result tree fragment is copied into the result tree (see [11.3 Using Values of Variables and Parameters with xsl:copy-of]), then all the nodes that are children of the root node in the equivalent node-set are added in sequence to the result tree.</span>
      </p>
      <p>
式の評価結果が結果ツリー素片の型になるのは、結果ツリー素片型の変数を参照したときか, 結果ツリー素片を返す拡張関数を呼び出したときか, 値が結果ツリー素片のシステムプロパティを取得したときか、のいずれかのみである。
<span lang="en">
Expressions can only return values of type result tree fragment by referencing variables of type result tree fragment or calling extension functions that return a result tree fragment or getting a system property whose value is a result tree fragment.</span>
      </p>

	</section>
	<section>

<h3 id="variable-values" title="11.2 Values of Variables and Parameters">11.2 変数とパラメタの値</h3>
      <p>
変数束縛要素には、次の３方法いずれかにより変数の値を指定できる。
<span lang="en">
A variable-binding element can specify the value of the variable in three alternative ways.</span>
      </p>
      <ul>
         <li>
            <p>
変数束縛要素が <code>select</code> 属性を持つ場合、属性値は
<a href="#dt-expression">式</a>
でなければならない。
この変数の値は、式の評価結果のオブジェクトになる。
この場合、要素の内容は空でなければならない。
<span lang="en">
If the variable-binding element has a select attribute, then the value of the attribute must be an expression and the value of the variable is the object that results from evaluating the expression.
In this case, the content must be empty.</span>
            </p>
         </li>
         <li>
            <p>
変数束縛要素が <code>select</code> 属性を持たず, 空でない内容を持つ場合（すなわち、変数束縛要素が１個以上の子ノードを持つ場合）、その内容が変数の値になる。
変数束縛要素の内容はテンプレートであり, 変数の値はこのテンプレートのインスタンス化により得られる。
この値は、テンプレートのインスタンス化で生成される一連のノードを子として持つルートノード１個からなるノード集合と等価な, 結果ツリー素片である。
結果ツリー素片のノードの基底 URI は、変数束縛要素の基底 URI になる。
<span lang="en">
If the variable-binding element does not have a select attribute and has non-empty content (i.e. the variable-binding element has one or more child nodes), then the content of the variable-binding element specifies the value.
The content of the variable-binding element is a template, which is instantiated to give the value of the variable.
The value is a result tree fragment equivalent to a node-set containing just a single root node having as children the sequence of nodes produced by instantiating the template.
The base URI of the nodes in the result tree fragment is the base URI of the variable-binding element.</span>
            </p>
            <p>
ルートノードは属性ノードや名前空間ノードを子に持てないので、テンプレートのインスタンス化により生成される一連のノードに 属性ノードや名前空間ノードがあった場合、エラーとする。
XSLT プロセッサは、エラーを通知してもよい。
エラーを通知しない場合、属性ノードまたは名前空間ノードを追加しないことにより, エラーから回復しなければならない。
<span lang="en">
It is an error if a member of the sequence of nodes created by instantiating the template is an attribute node or a namespace node, since a root node cannot have an attribute node or a namespace node as a child.
An XSLT processor may signal the error; if it does not signal the error, it must recover by not adding the attribute node or namespace node.</span>
            </p>
         </li>
         <li>
            <p>
変数束縛要素の内容が空, かつ <code>select</code> 属性もない場合、変数の値は空文字列になる。従って
従って,
<span lang="en">
If the variable-binding element has empty content and does not have a select attribute, then the value of the variable is an empty string. Thus</span>
            </p>
            <pre>&lt;xsl:variable name="x"/&gt;</pre>
            <p>
は、次と等価になる。
<span lang="en">
is equivalent to</span>
            </p>
            <pre>&lt;xsl:variable name="x" select="''"/&gt;</pre>
         </li>
      </ul>

      <blockquote>
<p>
<b>注記：</b>
位置によってノードを選択する目的で変数を利用する場合、次のように記述しないように注意する。
         <span lang="en">
NOTE:When a variable is used to select nodes by position, be careful not to do:</span>
</p>
  <pre>&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="item[$n]"/&gt;</pre>

<p>
この記述では、最初の <code>item</code> 要素の値を出力することになる。
これは、変数 <code>n</code> が数値ではなく, 結果ツリー素片に束縛されるためである。

         <span lang="en">
This will output the value of the first item element, because the variable n will be bound to a result tree fragment, not a number. </span>
</p>
<p>
代わりに、次のいずれかにする：
         <span lang="en">
Instead, do either</span>
</p>

  <pre>&lt;xsl:variable name="n" select="2"/&gt;
...
&lt;xsl:value-of select="item[$n]"/&gt;</pre>

<p>
         <span lang="en">
or</span>
</p>

  <pre>&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="item[position()=$n]"/&gt;</pre>

      </blockquote>
      <blockquote>
<p>
<b>注記：</b>
空のノード集合をパラメタの既定値として指定する場合、次のようにするのが便利である。
         <span lang="en">
NOTE:One convenient way to specify the empty node-set as the default value of a parameter is:</span>
</p>

  <pre>&lt;xsl:param name="x" select="/.."/&gt;</pre>
      </blockquote>

	</section>
	<section>

<h3 id="copy-of">11.3 <code >xsl:copy-of</code> における変数とパラメタの値の利用</h3>
      <pre class="element-syntax" id="element-copy-of">
&lt;!-- 分類：instruction --&gt;
&lt;xsl:copy-of
  <b>select</b> = <var>expression</var> /&gt;</pre>
      <p>
<code>xsl:copy-of</code> 要素の利用により、 <code>xsl:value-of</code> のときのような文字列への変換を行わずに（
<a href="#value-of">[<b>7.6.1 <code>xsl:value-of</code> によるテキストの生成</b>]</a>
を見よ）、結果ツリー素片を結果ツリーに挿入できる。
必須の <code>select</code> 属性には、
<a href="#dt-expression">式</a>
が含まれる。
式の評価結果が結果ツリー素片であれば、その完全な素片が結果ツリーの中に複製される。
評価結果がノード集合の場合は、その全ノードが文書順に結果ツリーの中に複製され, 要素ノードの複製に伴なって属性ノード, 名前空間ノード, 要素ノードの子も複製される。
ルートノード１個はその子の複製により複製される。
<ins class="errata">
属性ノードと名前空間ノードの複製については <code>xsl:copy</code> と同じ規則が適用される（
<a href="#copying">[<b>7.5 複製</b>]</a>
を見よ）。
</ins>
評価結果がノード集合でも結果ツリー素片でもない場合、 <code>xsl:value-of</code> の場合と同様に文字列に変換されてから結果ツリーに挿入される。
<span lang="en">
The xsl:copy-of element can be used to insert a result tree fragment into the result tree, without first converting it to a string as xsl:value-of does (see [7.6.1 Generating Text with xsl:value-of]).
The required select attribute contains an expression.
When the result of evaluating the expression is a result tree fragment, the complete fragment is copied into the result tree.
When the result is a node-set, all the nodes in the set are copied in document order into the result tree; copying an element node copies the attribute nodes, namespace nodes and children of the element node as well as the element node itself; a root node is copied by copying its children. 

<ins class="errata">
For copying an attribute or namespace node, the same rules apply as with xsl:copy (see [7.5 Copying]).
</ins><!-- E25 -->

When the result is neither a node-set nor a result tree fragment, the result is converted to a string and then inserted into the result tree, as with xsl:value-of.</span>
      </p>

	</section>
	<section>

<h3 id="top-level-variables" title="11.4 Top-level Variables and Parameters">11.4 トップレベルの変数とパラメタ</h3>
      <p>
<code>xsl:variable</code> と <code>xsl:param</code> は
<a href="#dt-top-level">トップレベル</a>
要素として利用できる。
トップレベルに置く変数束縛要素は、どこからでも見える大域変数を宣言する
<ins class="errata">（他の束縛により
<a  href="#dt-shadows">隠蔽</a>
されない限り）
</ins>
。
トップレベルの <code>xsl:param</code> 要素はスタイルシートに渡すパラメタを宣言する。
XSLT においては、どのパラメタをスタイルシートに渡すかの仕組みは定義しない。
<ins class="errata">
一つのスタイルシートに, 同じ名前の束縛が複数ある場合、最も
<a href="#dt-import-precedence">インポート優先順位</a>
が高いものが利用される。
</ins><!-- E17 -->
一つのスタイルシートに, 名前も
<a href="#dt-import-precedence">インポート優先順位</a>
も同じトップレベルの変数束縛が複数含まれる場合、エラーとする。

トップレベルにおいて, 変数の値を指定する式またはテンプレートは、ソース文書のルートノードを処理する際に利用される文脈と同じ文脈で評価される：すなわち, 現在のノードはソース文書のルートノード, 現在のノードリストはソース文書のルートノード１個からなる。
それらのテンプレートや式が大域変数 <var>x</var> の値を指定していて、大域変数 <var>y</var> を参照している場合、<var>y</var> の値は <var>x</var> の値より先に算出されなければならない。
いずれかの大域変数定義でこの順序の処理ができなくなる場合, すなわち定義が循環している場合、エラーとする。
<span lang="en">
Both xsl:variable and xsl:param are allowed as top-level elements.
A top-level variable-binding element declares a global variable that is visible everywhere
<ins class="errata"> (except where it is shadowed by another binding)</ins>. <!-- E18 -->
A top-level xsl:param element declares a parameter to the stylesheet; XSLT does not define the mechanism by which parameters are passed to the stylesheet. 

<ins class="errata"><!-- E17 -->
If a stylesheet contains more than one binding for a variable of a particular name, then the binding with the highest import precedence  is used. 
</ins>
It is an error if a stylesheet contains more than one binding of a top-level variable with the same name and same import precedence.
At the top-level, the expression or template specifying the variable value is evaluated with the same context as that used to process the root node of the source document: the current node is the root node of the source document and the current node list is a list containing just the root node of the source document.
If the template or expression specifying the value of a global variable x references a global variable y, then the value for y must be computed before the value of x.
It is an error if it is impossible to do this for all global variable definitions; in other words, it is an error if the definitions are circular.</span>
      </p>
      <p>
次の例は、大域変数 <code>para-font-size</code> を宣言し, 属性値テンプレートから参照させる。
<span lang="en">
This example declares a global variable para-font-size, which it references in an attribute value template.</span>
      </p>
      <pre>&lt;xsl:variable name="para-font-size"&gt;12pt&lt;/xsl:variable&gt;

&lt;xsl:template match="para"&gt;
 &lt;fo:block font-size="{$para-font-size}"&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>

	</section>
	<section>

<h3 id="local-variables" title="11.5 Variables and Parameters within Templates">11.5 テンプレート内の変数とパラメタ</h3>
      <p>
<code>xsl:variable</code> と <code>xsl:param</code> のいずれも、トップレベルに限らず, テンプレート内でも利用できる。
<code>xsl:variable</code> は、テンプレート内で命令が利用できる場所なら, どこでも利用できる。
この場合、束縛は
<!-- 
<del class="errata">後続のすべての同胞とその子孫</del>
 -->
<ins class="errata"><code >xsl:fallback</code> 命令を除く後続のすべての同胞の子孫</ins>
から参照できる。
この束縛は <code>xsl:variable</code> 要素自身からは見えないことに注意。
<code>xsl:param</code> は、<code>xsl:template</code> 要素の先頭の子として記述できる。
この場合、束縛は
<!-- 
<del class="errata">後続のすべての同胞とその子孫から</del>
 -->
<ins class="errata"><code >xsl:fallback</code> 命令を除く後続のすべての同胞の子孫</ins>
から参照できる。
この束縛は <code>xsl:param</code> 要素自身からは見えないことに注意。
<span lang="en">
As well as being allowed at the top-level, both xsl:variable and xsl:param are also allowed in templates.
xsl:variable is allowed anywhere within a template that an instruction is allowed.
In this case, the binding is visible for <del class="errata">all following siblings and their descendants</del><!-- E37 -->
<ins class="errata">the descendants of all following siblings that are not xsl:fallback instructions</ins>.
Note that the binding is not visible for the xsl:variable element itself.
xsl:param is allowed as a child at the beginning of an xsl:template element.
In this context, the binding is visible for <del class="errata">all following siblings and their descendants</del> <ins class="errata">the descendants of all following siblings that are not xsl:fallback instructions</ins>.
Note that the binding is not visible for the xsl:param element itself.</span>
      </p>
      <p>
同じ名前の他の束縛が見える位置に新たに現れた束縛は、その束縛を <dfn id="dt-shadows">隠蔽する</dfn> 。
テンプレート内の <code>xsl:variable</code> 要素や <code>xsl:param</code> 要素が確立する束縛が, 同じテンプレート内の <code>xsl:variable</code> 要素や <code>xsl:param</code> 要素が確立した束縛を
<a href="#dt-shadows">隠蔽</a>
する場合、エラーとする。
テンプレート内の <code>xsl:variable</code> 要素や <code>xsl:param</code> 要素が確立した束縛が、
<a href="#dt-top-level">トップレベル</a>
の <code>xsl:variable</code> 要素や <code>xsl:param</code> 要素が確立した束縛を
<a href="#dt-shadows">隠蔽</a>
するのはエラーではない。
<ins class="errata">
この場合、トップレベルの束縛はスタイルシート内で他の束縛により隠蔽される場所からは見えなくなる。
</ins><!-- E18 -->
従って, 次はエラーになるが：
<span lang="en">
A binding shadows another binding if the binding occurs at a point where the other binding is visible, and the bindings have the same name.
It is an error if a binding established by an xsl:variable or xsl:param element within a template shadows another binding established by an xsl:variable or xsl:param element also within the template.
It is not an error if a binding established by an xsl:variable or xsl:param element in a template shadows another binding established by an xsl:variable or xsl:paramtop-level element.

<ins class="errata">In this case, the top-level binding will not be visible in the region of the stylesheet where it is shadowed by the other binding.</ins><!-- E18 -->
Thus, the following is an error:</span>
      </p>
      <pre style="color: red">&lt;xsl:template name="foo"&gt;
&lt;xsl:param name="x" select="1"/&gt;
&lt;xsl:variable name="x" select="2"/&gt;
&lt;/xsl:template&gt;</pre>
      <p>
次は許容される：
<span lang="en">
However, the following is allowed:</span>
      </p>
      <pre>&lt;xsl:param name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
&lt;xsl:variable name="x" select="2"/&gt;
&lt;/xsl:template&gt;</pre>
      <blockquote>
<p>
<b>注記：</b>
Java 言語において, テンプレート内の <code>xsl:variable</code> 要素と最も近い存在は、初期化子を伴う final 局所変数の宣言になる。
例えば,
<span lang="en">
NOTE:The nearest equivalent in Java to an xsl:variable element in a template is a final local variable declaration with an initializer. For example,</span>
</p>

  <pre>&lt;xsl:variable name="x" select="'value'"/&gt;</pre>

<p>
は、次と似た意味内容になる：
<span lang="en">
has similar semantics to</span>
</p>

  <pre>final Object x = "value";</pre>

<p>
ただし, XSLT には次の Java の代入演算子と等価な表記は存在しない。
<span lang="en">
XSLT does not provide an equivalent to the Java assignment operator</span>
</p>

  <pre>x = "value";</pre>

<p>
その理由は、これを取り入れると, 先頭から終わりまで間断なく続けるバッチ的手法以外に文書の処理を実装することが難しくなるためである。
<span lang="en">
because this would make it harder to create an implementation that processes a document other than in a batch-like way, starting at the beginning and continuing through to the end.</span>
</p>
      </blockquote>

	</section>
	<section>

<h3 id="section-Passing-Parameters-to-Templates" title="11.6 Passing Parameters to Templates">11.6 テンプレートへのパラメタの引き渡し</h3>
      <pre class="element-syntax" id="element-with-param">
&lt;xsl:with-param
  <b>name</b> = <var>qname</var> 
  select = <var>expression</var>&gt;
  &lt;!-- 内容：<var>template</var> --&gt;
&lt;/xsl:with-param&gt;</pre>
      <p>
<code>xsl:with-param</code> 要素を通してパラメタをテンプレートに渡すことができる。
必須の <code>name</code> 属性に、パラメタ（束縛の値に置換される変数）の名前を指定する。
<code>name</code> 属性の値は
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
であり,
<a href="#qname">[<b>2.4 修飾名</b>]</a>
に則って展開される。
<code>xsl:with-param</code> は <code>xsl:call-template</code> と <code>xsl:apply-templates</code> の内部で利用できる。
<ins class="errata">
同じ <code>xsl:call-template</code> または <code>xsl:apply-templates</code> 要素内に同じ名前の複数の <code>xsl:with-param</code> 要素が含まれる場合、エラーとする。
</ins>
パラメタの値は <code>xsl:variable</code> や <code>xsl:param</code> の場合と同じ方法で指定する。
<code>xsl:with-param</code> 要素に指定された値の評価に利用される現在のノードと現在のノードリストは、 <code>xsl:apply-templates</code> 要素や <code>xsl:call-template</code> 要素の場合と同じものになる。
パラメタ <var>x</var> を受け取る <code>xsl:param</code> 要素を持たないテンプレートに、パラメタ <var>x</var> を渡してもエラーにはならない。
このようなパラメタは単に無視される。
<span lang="en">
Parameters are passed to templates using the xsl:with-param element.
The required name attribute specifies the name of the parameter (the variable the value of whose binding is to be replaced).
The value of the name attribute is a QName, which is expanded as described in [2.4 Qualified Names].
xsl:with-param is allowed within both xsl:call-template and xsl:apply-templates. 

<ins class="errata">
It is an error if a single xsl:call-template  or xsl:apply-templates element contains more than one xsl:with-param element with the same name. </ins><!-- E16 -->

The value of the parameter is specified in the same way as for xsl:variable and xsl:param.
The current node and current node list used for computing the value specified by xsl:with-param element is the same as that used for the xsl:apply-templates or xsl:call-template element within which it occurs.
It is not an error to pass a parameter x to a template that does not have an xsl:param element for x; the parameter is simply ignored.</span>
      </p>
      <p>
次の例は、数値フォーマットを制御する引数を伴う名前付きテンプレート <code>numbered-block</code> を定義している。
<span lang="en">
This example defines a named template for a numbered-block with an argument to control the format of the number.</span>
      </p>
      <pre>&lt;xsl:template name="numbered-block"&gt;
  &lt;xsl:param name="format"&gt;1. &lt;/xsl:param&gt;
  &lt;fo:block&gt;
    &lt;xsl:number format="{$format}"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ol//ol/li"&gt;
  &lt;xsl:call-template name="numbered-block"&gt;
    &lt;xsl:with-param name="format"&gt;a. &lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</pre>

	</section>
</section>
<section>

<h2 id="add-func" title="12 Additional Functions">12 その他の追加の関数</h2>
      <p>
この節では、 XPath のコア関数ライブラリに追加される XSLT 固有の関数について述べる。
これらの追加の関数の一部は、スタイルシートの
<a href="#dt-top-level">トップレベル</a>
要素で指定された情報も利用するため、それらの要素についても述べる。
<span lang="en">
This section describes XSLT-specific additions to the core XPath function library.
Some of these additional functions also make use of information specified by top-level elements in the stylesheet; this section also describes these elements.</span>
      </p>

	<section>

<h3 id="document" title="12.1 Multiple Source Documents">12.1 複数のソース文書</h3>

      <p>
<a id="function-document"><b>関数：</b> <i>node-set</i> <b>document</b> ( <i>object</i>, <i>node-set</i>?)</a>
         <span lang="en">
Function: node-set document(object, node-set?)</span>
      </p>
      <p>
<b><a href="#function-document">document</a></b>
関数は、メインのソース文書以外の XML 文書へのアクセスを可能にする。
<span lang="en">
The document function allows access to XML documents other than the main source document.</span>
      </p>
      <p>
<span class="trans-note">【第１引数がノード集合の場合の結果は第１引数が文字列の場合の結果から定義される】</span>
<b><a href="#function-document">document</a></b>
関数の引数が１個だけで, その引数がノード集合だった場合、その結果は, 引数のノード集合に含まれる各ノードに対し、ノードの
<a href="xpath10-ja.html#dt-string-value">文字列値</a>
を第１引数に, そのノードを唯一のメンバとするノード集合を第２引数にして
<b><a href="#function-document">document</a></b>
関数を呼び出した結果の和集合をとったものになる。
<b><a href="#function-document">document</a></b>
関数の引数が２個あり, 第１引数がノード集合だった場合、その結果は, 引数のノード集合に含まれる各ノードに対し、ノードの
<a href="xpath10-ja.html#dt-string-value">文字列値</a>
を第１引数に, 第２引数を
<b><a href="#function-document">document</a></b>
関数に渡された第２引数にして
<b><a href="#function-document">document</a></b>
関数を呼び出した結果の和集合をとったものになる。
<span lang="en">
When the document function has exactly one argument and the argument is a node-set, then the result is the union, for each node in the argument node-set, of the result of calling the document function with the first argument being the string-value of the node, and the second argument being a node-set with the node as its only member.
When the document function has two arguments and the first argument is a node-set, then the result is the union, for each node in the argument node-set, of the result of calling the document function with the first argument being the string-value of the node, and with the second argument being the second argument passed to the document function.</span>
      </p>
      <p>
<b><a href="#function-document">document</a></b>
関数に指定した第１引数がノード集合でない場合、第１引数は
<b><a href="xpath10-ja.html#function-string">string</a></b>
関数を呼び出したかのように文字列に変換される。
この文字列は URI 参照として扱われ, まず この URI が参照するリソースが取得される。
取得された結果のデータは XML 文書として構文解析され, データモデルに従ってツリーが構築される（
<a href="#data-model">[<b>3 データモデル</b>]</a>
を見よ）。
リソースの取得時にエラーが生じた場合、 XSLT プロセッサはエラーを通知してもよい。
エラーを通知しない場合、空のノード集合を返してエラーから回復しなければならない。
リソース取得時のエラーとしては XSLT プロセッサが URI のスキーマをサポートしていないなどが挙げられる。
XSLT プロセッサには特定の URI スキーマのサポートは要求されていないが、実装側は XSLT プロセッサの説明書においてどの URI スキーマをサポートしているかを示すべきである。
<span lang="en">
When the first argument to the document function is not a node-set, the first argument is converted to a string as if by a call to the string function.
This string is treated as a URI reference; the resource identified by the URI is retrieved.
The data resulting from the retrieval action is parsed as an XML document and a tree is constructed in accordance with the data model (see [3 Data Model]).
If there is an error retrieving the resource, then the XSLT processor may signal an error; if it does not signal an error, it must recover by returning an empty node-set.
One possible kind of retrieval error is that the XSLT processor does not support the URI scheme used by the URI.
An XSLT processor is not required to support any particular URI schemes.
The documentation for an XSLT processor should specify which URI schemes the XSLT processor supports.</span>
      </p>
      <p>
URI 参照が素片識別子を含まない場合、文書のルートノードのみからなるノード集合が返される。
URI 参照が素片識別子を含む場合、この関数は URI 参照の素片識別子から特定されるツリー内のノード集合を返す。
素片識別子の意味内容は、 URI による取得結果のメディア型から決定される。
素片識別子の処理過程でエラーが発生した場合、 XSLT プロセッサはエラーを通知してもよい。
エラーを通知しない場合、空のノード集合を返してエラーから回復しなければならない。

生じ得るエラーには次のものが挙げられる：
<span lang="en">
If the URI reference does not contain a fragment identifier, then a node-set containing just the root node of the document is returned.
If the URI reference does contain a fragment identifier, the function returns a node-set containing the nodes in the tree identified by the fragment identifier of the URI reference.
The semantics of the fragment identifier is <ins class="errata">are</ins><!-- E15 --> dependent on the media type of the result of retrieving the URI.
If there is an error in processing the fragment identifier, the XSLT processor may signal the error; if it does not signal the error, it must recover by returning an empty node-set.
Possible errors include:</span>
      </p>
      <ul>
         <li>
            <p>
素片識別子が XSLT のノード集合では表現できないものを指している（テキストノード内のある範囲の文字など）。
<span lang="en">
The fragment identifier identifies something that cannot be represented by an XSLT node-set (such as a range of characters within a text node).</span>
            </p>
         </li>
         <li>
            <p>
取得結果のメディア型の素片識別子を XSLT プロセッサがサポートしていない。
XSLT プロセッサには、特定のメディア型のサポートは要求されていないが、実装側は XSLT プロセッサの説明書においてメディア型の素片識別子をサポートしているかを示すべきである。
<span lang="en">
The XSLT processor does not support fragment identifiers for the media-type of the retrieval result.
An XSLT processor is not required to support any particular media types.
The documentation for an XSLT processor should specify for which media types the XSLT processor supports fragment identifiers.</span>
            </p>
         </li>
      </ul>
      <p>
メディア型に関わらず、取得結果のデータは XML 文書として構文解析される。
構文解析においては, トップレベルメディア型が <code>text</code> だった場合、メディア型を <code>text/xml</code> とみなした上で行い, それ以外の場合、メディア型を <code>application/xml</code> とみなした上で行うものとする。
<span lang="en">
The data resulting from the retrieval action is parsed as an XML document regardless of the media type of the retrieval result; if the top-level media type is text, then it is parsed in the same way as if the media type were text/xml; otherwise, it is parsed in the same way as if the media type were application/xml.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
トップレベルの <code>xml</code> メディア型は存在しないため, <code>text/xml</code> または <code>application/xml</code> 以外のメディア型のデータでも、実際は XML になっていることがある。
<span lang="en">
NOTE:Since there is no top-level xml media type, data with a media type other than text/xml or application/xml may in fact be XML.</span>
</p>
      </blockquote>
      <p>
URI 参照は相対 URI にもなり得る。
この場合、相対 URI の解決に用いる基底 URI （
<a href="#base-uri">[<b>3.2 基底 URI</b>]</a>
を見よ）は、第２引数のノード集合に含まれるノードのうち, 文書順で最初のノードの基底 URI とする。
<ins class="errata">
URI 参照が相対 URI にもかかわらず第２引数のノード集合が空だった場合、エラーとする。
この場合、 XSLT プロセッサはエラーを通知してもよい。
エラーを通知しない場合、空のノード集合を返して, エラーから回復しなければならない。
</ins><!-- E14 -->

第２引数が省略された場合、
<b><a href="#function-document">document</a></b>
関数の呼び出しを含む式を含んでいるスタイルシート内のノードの基底 URI を既定のものとして利用するものとする。
長さゼロの URI 参照は、解決対象の URI 参照に相対的な文書への参照になることに注意。
<!-- □ -->
従って <code>document("")</code> は、スタイルシートのルートノードを参照することになり, そのツリー表現は、そのスタイルシートを含む XML 文書を, ソース文書としてあてがったときと全く同じになる。
<span lang="en">
The URI reference may be relative.
The base URI (see [3.2 Base URI]) of the node in the second argument node-set that is first in document order is used as the base URI for resolving the relative URI into an absolute URI. 

<ins class="errata">
It is an error if the second argument node-set is empty and the URI reference is relative; the XSLT processor may signal the error; if it does not signal an error, it must recover by returning an empty node-set. </ins><!-- E14 -->

If the second argument is omitted, then it defaults to the node in the stylesheet that contains the expression that includes the call to the document function.
Note that a zero-length URI reference is a reference to the document relative to which the URI reference is being resolved; thus document("") refers to the root node of the stylesheet; the tree representation of the stylesheet is exactly the same as if the XML document containing the stylesheet was the initial source document.</span>
      </p>
      <p>
同一の URI から取得された文書は、同一の文書として扱われる。
識別時の比較に用いる URI においては、相対 URI は絶対 URI に解決されるものとし, かつ 素片識別子は含まないものとする。
２つのルートノードが同一の文書からのものであった場合、同一のノードとして扱われる。
従って, 次の式は常に真になる。
<span lang="en">
Two documents are treated as the same document if they are identified by the same URI.
The URI used for the comparison is the absolute URI into which any relative URI was resolved and does not include any fragment identifier.
One root node is treated as the same node as another root node if the two nodes are from the same document.
Thus, the following expression will always be true:</span>
      </p>
      <pre>generate-id(document("foo.xml"))=generate-id(document("foo.xml"))</pre>
      <p>
<b><a href="#function-document">document</a></b>
関数の利用においては、ノード集合は複数の文書からのノードを含み得る。
このようなノード集合においては, 同一の文書からの２つのノードの相対的な文書順は、 XPath
<a href="#XPATH">[XPath]</a>
で定められる通常の
<a href="xpath10-ja.html#dt-document-order">文書順</a>
とし, 異なる文書からの２つのノードの相対的な文書順は、それらの文書の実装依存の順序付けに従うものとする。
複数の文書の順序付けについては、一貫性のある順序付けを行わなければならないこと以外に制約はない。
すなわち, 実装は、同じ文書集合に対し常に同じ順序を与えなければならない。

<span lang="en">
The document function gives rise to the possibility that a node-set may contain nodes from more than one document.
With such a node-set, the relative document order of two nodes in the same document is the normal document order defined by XPath [XPath].
The relative document order of two nodes in different documents is determined by an implementation-dependent ordering of the documents containing the two nodes.
There are no constraints on how the implementation orders documents other than that it must do so consistently: an implementation must always use the same order for the same set of documents.</span>
      </p>

	</section>
	<section>

<h3 id="key" title="12.2 Keys">12.2 キー</h3>
      <p>
キーを利用すると、暗黙的な相互参照構造を持つ文書を扱えるようになる。
XML の属性型 <code>ID</code>, <code>IDREF</code>, <code>IDREFS</code> は、 XML 文書の相互参照を明示的に利用可能にする仕組みを提供する。
XSLT は XPath の 
<b><a href="xpath10-ja.html#function-id">id</a></b>
関数を利用してこの仕組みをサポートする。
しかしながら、この仕組みには以下に挙げるようないくつもの制約がある。
<span lang="en">
Keys provide a way to work with documents that contain an implicit cross-reference structure.
The ID, IDREF and IDREFS attribute types in XML provide a mechanism to allow XML documents to make their cross-reference explicit.
XSLT supports this through the XPath id function.
However, this mechanism has a number of limitations:</span>
      </p>
      <ul>
         <li>
            <p>
ID 型の属性は、 DTD 内で ID 型の属性として宣言されていなければならない。
ある ID 型の属性が, 外部 DTD サブセットの内部だけで宣言されている場合、その ID 型の属性は XML プロセッサがその外部 DTD サブセットを読み込んだ場合に限り、 ID 型として認識される。
しかしながら, XML の仕様では XML プロセッサに対する外部 DTD の読み込みは要求されていない。
特に, 文書において <code>standalone="yes"</code> が宣言されている場合、外部 DTD の読み込みを行わないふるまいも十分適切になる。
<span lang="en">
ID attributes must be declared as such in the DTD.
If an ID attribute is declared as an ID attribute only in the external DTD subset, then it will be recognized as an ID attribute only if the XML processor reads the external DTD subset.
However, XML does not require XML processors to read the external DTD, and they may well choose not to do so, especially if the document is declared standalone="yes".</span>
            </p>
         </li>
         <li>
            <p>
一つの文書内では、一意 ID の集合は１個までに限られ, 独立した別個の一意 ID の集合は存在できない。
<span lang="en">
A document can contain only a single set of unique IDs.
There cannot be separate independent sets of unique IDs.</span>
            </p>
         </li>
         <li>
            <p>
要素に ID を指定できるのは属性に限られる。
要素の内容や子要素による指定はできない。
<span lang="en">
The ID of an element can only be specified in an attribute; it cannot be specified by the content of the element, or by a child element.</span>
            </p>
         </li>
         <li>
            <p>
ID は XML 名でなければならない。
例えばスペースが含まれてはならない。
<span lang="en">
An ID is constrained to be an XML name.
For example, it cannot contain spaces.</span>
            </p>
         </li>
         <li>
            <p>
要素が持てる ID は１個までに限られる。
<span lang="en">
An element can have at most one ID.</span>
            </p>
         </li>
         <li>
            <p>
同じ ID を持てる要素は１個までに限られる。
<span lang="en">
At most one element can have a particular ID.</span>
            </p>
         </li>
      </ul>
      <p>
これらの制約のため、 XML 文書には明示的に ID, IDREF, IDREFS 型の属性で宣言されないような相互参照構造を含むものがある。
<span lang="en">
Because of these limitations XML documents sometimes contain a cross-reference structure that is not explicitly declared by ID/IDREF/IDREFS attributes.</span>
      </p>
      <p>
キーは次の三つ組からなる：
<span lang="en">
A key is a triple containing:</span>
      </p>
      <ol>
         <li>
            <p>
キーを持つノード
<span lang="en">
the node which has the key</span>
            </p>
         </li>
         <li>
            <p>
キーの名前（
<a href="xpath10-ja.html#dt-expanded-name">展開名</a>
）
<span lang="en">
the name of the key (an expanded-name)</span>
            </p>
         </li>
         <li>
            <p>
キーの値（文字列）
<span lang="en">
the value of the key (a string)</span>
            </p>
         </li>
      </ol>
      <p>
スタイルシートは、<code>xsl:key</code> 要素を用いて各文書ごとにキーの集合を宣言する。
以下, この集合に属するキーがノード <var>x</var>, 名前 <var>y</var>, 値 <var>z</var> を持つとき、ノード <var>x</var> は名前 <var>y</var>, 値 <var>z</var> のキーを持つ, と表現することにする。
<span lang="en">
A stylesheet declares a set of keys for each document using the xsl:key element.
When this set of keys contains a member with node x, name y and value z, we say that node x has a key with name y and value z.</span>
      </p>
      <p>
このようにキーは ID を一般化したものなので、 XML の ID のような制約は課されない。
<span lang="en">
Thus, a key is a kind of generalized ID, which is not subject to the same limitations as an XML ID:</span>
      </p>
      <ul>
         <li>
            <p>
キーはスタイルシートの中で <code>xsl:key</code> 要素を用いて宣言する。
<span lang="en">
Keys are declared in the stylesheet using xsl:key elements.</span>
            </p>
         </li>
         <li>
            <p>
１個のキーは１個の名前と１個の値を持つ。
キーの各名前は、独立した別個の識別子の空間を区別するものと見なせる。
<span lang="en">
A key has a name as well as a value; each key name may be thought of as distinguishing a separate, independent space of identifiers.</span>
            </p>
         </li>
         <li>
            <p>
要素に対する名前付きキーの値は、例えば, 属性の中, 子要素の中, 内容の中など、任意に都合のいい場所に指定できる。
XPath 式を名前付きキーの値の位置の指定に利用する。
<span lang="en">
The value of a named key for an element may be specified in any convenient place; for example, in an attribute, in a child element or in content.
An XPath expression is used to specify where to find the value for a particular named key.</span>
            </p>
         </li>
         <li>
            <p>
キーの値は、名前でなくともよく, 任意の文字列が可能である。
<span lang="en">
The value of a key can be an arbitrary string; it is not constrained to be a name.</span>
            </p>
         </li>
         <li>
            <p>
同じ文書内に、同じノード, 同じ名前を持ち, 異なる値を持つキーを複数含められる。
<span lang="en">
There can be multiple keys in a document with the same node, same key name, but different key values.</span>
            </p>
         </li>
         <li>
            <p>
同じ文書内に、同じ名前, 同じ値を持ち, 異なるノードを持つキーを複数含められる。
<span lang="en">
There can be multiple keys in a document with the same key name, same key value, but different nodes.</span>
            </p>
         </li>
      </ul>
      <pre class="element-syntax" id="element-key">
&lt;!-- Category:
top-level-element --&gt;
&lt;xsl:key
  <b>name</b> = <var>qname</var>
         <b>match</b> = <var>pattern</var>
         <b>use</b> = <var>expression</var> /&gt;</pre>
      <p>
キーの宣言には <code>xsl:key</code> 要素を利用する。
<code>name</code> 属性の値（以下これを <var >y</var> とする）にキーの名前を指定する。
値は
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
であり,
<a href="#qname">[<b>2.4 修飾名</b>]</a>
に則って展開される。
<code>match</code> 属性の値は
<a href="#NT-Pattern">Pattern</a>
である。
<code>xsl:key</code> 要素は <code>match</code> 属性に指定されたパターンに合致するすべてのノードに対し、それらのキーの情報を提供するものになる。

<code>use</code> 属性はキーの値を指定する
<a href="#dt-expression">式</a>
である。
この式はパターンに合致したノード（ <var >x</var> とする）ごとに１度ずつ評価される。
その結果がノード集合の場合、 <var >x</var> は結果の各ノードごとに, その文字列値を値とする名前 <var >y</var> のキーを持つ。
他の場合、結果は文字列に変換され, <var >x</var> はその文字列を値とする名前 <var >y</var> のキーを持つ。
すなわち, <code>xsl:key</code> 要素が次の条件を満たす場合、そのときに限り, ノード <var>x</var> に名前 <var>y</var> , 値 <var>z</var> を持つキーが存在する。
<span lang="en">
The xsl:key element is used to declare keys.
The name attribute specifies the name of the key.
The value of the name attribute is a QName, which is expanded as described in [2.4 Qualified Names].
The match attribute is a Pattern; an xsl:key element gives information about the keys of any node that matches the pattern specified in the match attribute.
The use attribute is an expression specifying the values of the key; the expression is evaluated once for each node that matches the pattern.
If the result is a node-set, then for each node in the node-set, the node that matches the pattern has a key of the specified name whose value is the string-value of the node in the node-set;
otherwise, the result is converted to a string, and the node that matches the pattern has a key of the specified name with value equal to that string.
Thus, a node x has a key with name y and value z if and only if there is an xsl:key element such that:</span>
      </p>
      <ul>
         <li>
            <p>
<var>x</var> が <code>xsl:key</code> 要素の <code>match</code> 属性に指定されたパターンに合致する。
<span lang="en">
x matches the pattern specified in the match attribute of the xsl:key element;</span>
            </p>
         </li>
         <li>
            <p>
<code>xsl:key</code> 要素の <code>name</code> 属性の値が <var>y</var> に等しい。
<span lang="en">
the value of the name attribute of the xsl:key element is equal to y; and</span>
            </p>
         </li>
         <li>
            <p>
<var>x</var> を現在のノードに, <var>x</var> のみからなるノードリストを現在のノードリストにして <code>xsl:key</code> 要素の <code>use</code> 属性に指定された式を評価した結果のオブジェクトを <var>u</var> とする。
このとき,
<b><a href="xpath10-ja.html#function-string">string</a></b>
関数を呼び出したかのように <var>u</var> を文字列に変換した結果が <var>z</var> に等しくなるか, または <var>u</var> がノード集合で <var>z</var> が <var>u</var> の中のどれかのノードの文字列値に等しい。
<span lang="en">
when the expression specified in the use attribute of the xsl:key element is evaluated with x as the current node and with a node list containing just x as the current node list resulting in an object u, then either z is equal to the result of converting u to a string as if by a call to the string function, or u is a node-set and z is equal to the string-value of one or more of the nodes in u.</span>
            </p>
         </li>
      </ul>
      <p>
ノードに合致する <code>xsl:key</code> 要素は複数存在し得ることに注意。
要素の
<a href="#dt-import-precedence">インポート優先順位</a>
が異なっていても、合致する <code>xsl:key</code> 要素はすべて利用される。
<span lang="en">
Note also that there may be more than one xsl:key element that matches a given node; all of the matching xsl:key elements are used, even if they do not have the same import precedence.</span>
      </p>
      <p>
<code>use</code> 属性または <code>match</code> 属性のいずれかの値が
<a href="xpath10-ja.html#NT-VariableReference">VariableReference</a>
を含む
<ins class="errata">
, または
<b><a href="#function-key">key</a></b>
関数を呼び出した
</ins><!-- E13 -->
場合、エラーとする。
<span lang="en">
It is an error for the value of either the use attribute or the match attribute to contain a VariableReference

<ins class="errata">, or a call to the key function</ins><!-- E13 -->
.
</span>
      </p>
      <p>
<a id="function-key"><b>関数：</b> <i>node-set</i> <b>key</b> ( <i>string</i>, <i>object</i> )</a>
         <span lang="en">
Function: node-set key(string, object)</span>
      </p>
      <p>
<b><a href="#function-key">key</a></b>
関数は、 ID に対し
<b><a href="xpath10-ja.html#function-id">id</a></b>
関数が実行することをキーに対して実行する。
第１引数にはキーの名前を指定する。
この引数の値は
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
でなければならない。
この値は
<a href="#qname">[<b>2.4 修飾名</b>]</a>
に則って展開される。
<b><a href="#function-key">key</a></b>
関数の第２引数がノード集合の場合、それに属する各ノードに対し, その
<ins class="errata">
<a href="xpath10-ja.html#dt-string-value">文字列値</a>
</ins><!-- E12 -->
を第２引数として
<b><a href="#function-key">key</a></b>
関数を呼び出した結果の和集合が返される。

<b><a href="#function-key">key</a></b>
関数の第２引数が他の型の場合、
<b><a href="xpath10-ja.html#function-string">string</a></b>
関数を呼び出したかのように文字列に変換し, 文脈ノードと同じ文書に含まれるノードのうち, 第１引数の名前とこの文字列に等しい値のキーを持つものからなるノード集合が返される。
<span lang="en">
The key function does for keys what the id function does for IDs.
The first argument specifies the name of the key.
The value of the argument must be a QName, which is expanded as described in [2.4 Qualified Names].
When the second argument to the key function is of type node-set, then the result is the union of the result of applying the key function to the <ins class="errata">string-value</ins><!-- E12 --> of each of the nodes in the argument node-set.
When the second argument to key is of any other type, the argument is converted to a string as if by a call to the string function; it returns a node-set containing the nodes in the same document as the context node that have a value for the named key equal to this string.</span>
      </p>
      <p>
例えば次の宣言：
<span lang="en">
For example, given a declaration</span>
      </p>
      <pre>&lt;xsl:key name="idkey" match="div" use="@id"/&gt;</pre>
      <p>
において, 式 <code>key("idkey",@ref)</code> は、 XML ソース文書に宣言されている唯一の ID 型の属性が次のもの：
<span lang="en">
an expression key("idkey",@ref) will return the same node-set as id(@ref), assuming that the only ID attribute declared in the XML source document is:</span>
      </p>
      <pre>&lt;!ATTLIST div id ID #IMPLIED&gt;</pre>
      <p>
で, かつ 現在のノードの <code>ref</code> 属性に空白が含まれていなければ、 <code>id(@ref)</code> と同じノード集合を返す。
<span lang="en">
and that the ref attribute of the current node contains no whitespace.</span>
      </p>
      <p>
関数ライブラリを記述する文書があって, 次のように <code>prototype</code> 要素を用いて関数を定義しているとする：
<span lang="en">
Suppose a document describing a function library uses a prototype element to define functions</span>
      </p>
      <pre>&lt;prototype name="key" return-type="node-set"&gt;
&lt;arg type="string"/&gt;
&lt;arg type="object"/&gt;
&lt;/prototype&gt;</pre>
      <p>
更に,  <code>function</code> 要素があって次のように関数名を参照しているとする：
<span lang="en">
and a function element to refer to function names</span>
      </p>
      <pre>&lt;function&gt;key&lt;/function&gt;</pre>
      <p>
このとき, 次ようなスタイルシートで、参照と定義の間にハイパーリンクを生成できる：
<span lang="en">
Then the stylesheet could generate hyperlinks between the references and definitions as follows:</span>
      </p>
      <pre>&lt;xsl:key name="func" match="prototype" use="@name"/&gt;

&lt;xsl:template match="function"&gt;
&lt;b&gt;
  &lt;a href="#{generate-id(key('func',.))}"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/a&gt;
&lt;/b&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="prototype"&gt;
&lt;p&gt;&lt;a name="{generate-id()}"&gt;
&lt;b&gt;Function: &lt;/b&gt;
...
&lt;/a&gt;&lt;/p&gt;
&lt;/xsl:template&gt;</pre>
      <p>
<!-- 
<del class="errata">
<b><a href="#function-key">key</a></b>
関数は、文脈ノードを含む文書以外の文書から、キーを取得するために利用できる。
</del>
 -->

<ins class="errata">
<b><a href="#function-key">key</a></b>
関数は、常に現在のノードと同じ文書のノードの集合を返す。
他の文書からキーを取得するためには、まず現在のノードを変更しておく必要がある。
</ins><!-- E11 -->

例えば <code>&lt;bibref&gt;XSLT&lt;/bibref&gt;</code> の形式の書籍目録参照を含む文書があって, 書籍目録データベースを内容とする別の XML 文書 <code>bib.xml</code> に次の形式の項目が含まれているとする：
<span lang="en">

<del class="errata">The key can be used to retrieve a key from a document other than the document containing the context node. </del>

<ins class="errata">The key always returns nodes that are in the same document as the current node; to retrieve a key from any other document, it is necessary first to change the current node.</ins><!-- E11 -->

For example, suppose a document contains bibliographic references in the form &lt;bibref&gt;XSLT&lt;/bibref&gt;, and there is a separate XML document bib.xml containing a bibliographic database with entries in the form:</span>
      </p>
      <pre>&lt;entry name="XSLT"&gt;...&lt;/entry&gt;</pre>
      <p>
このとき, スタイルシートでは、次のようにして <code>bibref</code> 要素を変換できる：
<span lang="en">
Then the stylesheet could use the following to transform the bibref elements:</span>
      </p>
      <pre>&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:variable name="name" select="."/&gt;
  &lt;xsl:for-each select="document('bib.xml')"&gt;
    &lt;xsl:apply-templates select="key('bib',$name)"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</pre>

	</section>
	<section>

<h3 id="format-number" title="12.3 Number Formatting">12.3 数値のフォーマット化</h3>
      <p>
<a id="function-format-number"><b>関数：</b> <i>string</i> <b>format-number</b> ( <i>number</i>, <i>string</i>, <i>string</i> ? )</a>
         <span lang="en">
Function: string format-number(number, string, string?)</span>
      </p>
      <p>
<b><a href="#function-format-number">format-number</a></b>
関数は、第２引数で与えられたフォーマットパターン文字列と第３引数で与えられた名前の十進フォーマット（ decimal-format ）を利用して, 第１引数を文字列に変換する。
第３引数が指定されていない場合、既定の十進フォーマットが利用される。
フォーマットパターン文字列の構文は、 JDK 1.1 の
<a href="http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormat.html">DecimalFormat</a>
クラスで規定されるものとする。
フォーマットパターン文字列は、ローカライズされた記法で表記される。
十進フォーマットは、パターン内で特別な意味を持つ文字を規定する（引用符はローカライズされないので, これには含まれない）。
フォーマットパターンには通貨記号（ #x00A4 ）を含めてはならない。
この通貨記号が JDK 1.1 の初期リリース版以後にサポートされるようになったためである。
十進フォーマットの名前は
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
でなければならない。
この値は
<a href="#qname">[<b>2.4 修飾名</b>]</a>
に則って展開される。
スタイルシートが, 指定された
<a href="xpath10-ja.html#dt-expanded-name">展開名</a>
を持つ十進フォーマットの宣言を含まない場合、エラーとする。
<span lang="en">
The format-number function converts its first argument to a string using the format pattern string specified by the second argument and the decimal-format named by the third argument, or the default decimal-format, if there is no third argument.
The format pattern string is in the syntax specified by the JDK 1.1 DecimalFormat class.
The format pattern string is in a localized notation: the decimal-format determines what characters have a special meaning in the pattern (with the exception of the quote character, which is not localized).
The format pattern must not contain the currency sign (#x00A4); support for this feature was added after the initial release of JDK 1.1.
The decimal-format name must be a QName, which is expanded as described in [2.4 Qualified Names].
It is an error if the stylesheet does not contain a declaration of the decimal-format with the specified expanded-name.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
XSLT の実装には JDK 1.1 の実装の利用は要求されていないし, XSLT を Java で実装することも要求されていない。
<span lang="en">
NOTE:Implementations are not required to use the JDK 1.1 implementation, nor are implementations required to be implemented in Java.</span>
</p>
      </blockquote>
      <blockquote>
<p>
<b>注記：</b>
スタイルシートは、数値の丸め方の制御に XPath のその他の機能を利用できる。
<span lang="en">
NOTE:Stylesheets can use other facilities in XPath to control rounding.</span>
</p>
      </blockquote>
      <pre class="element-syntax" id="element-decimal-format">
&lt;!-- 分類：top-level-element --&gt;
&lt;xsl:decimal-format
  name = <var>qname</var> 
  decimal-separator = <var>char</var> 
  grouping-separator = <var>char</var> 
  infinity = <var>string</var> 
  minus-sign = <var>char</var> 
  NaN = <var>string</var> 
  percent = <var>char</var> 
  per-mille = <var>char</var> 
  zero-digit = <var>char</var> 
  digit = <var>char</var> 
  pattern-separator = <var>char</var> /&gt;</pre>
      <p>
<code>xsl:decimal-format</code> 要素は、十進フォーマットを宣言して 
<b><a href="#function-format-number">format-number</a></b>
関数が利用するフォーマットパターンの解釈を制御する。
要素に <code>name</code> 属性が与えられた場合、名前付きの十進フォーマットを宣言する。
他の場合、既定の十進フォーマットを宣言する。
<code>name</code> 属性の値は
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
であり,
<a href="#qname">[<b>2.4 修飾名</b>]</a>
に則って展開される。
既定の十進フォーマットまたは同じ名前の十進フォーマットが（
<a href="#dt-import-precedence">インポート優先順位</a>
に関わらず）複数回宣言された場合、それらの（すべての既定値も含めた）すべての属性値が同じになる場合を除き, エラーとする。
<ins class="errata">
スタイルシートに既定の十進フォーマットの宣言が与えられていない場合、属性を持たない <code>xsl:decimal-format</code> 要素と等価な宣言が既定のものとして利用されるものとする。
</ins><!-- E10 -->
<span lang="en">
The xsl:decimal-format element declares a decimal-format, which controls the interpretation of a format pattern used by the format-number function.
If there is a name attribute, then the element declares a named decimal-format; otherwise, it declares the default decimal-format.
The value of the name attribute is a QName, which is expanded as described in [2.4 Qualified Names].
It is an error to declare either the default decimal-format or a decimal-format with a given name more than once (even with different import precedence), unless it is declared every time with the same value for all attributes (taking into account any default values).
<ins class="errata"><!-- E10 -->
If a stylesheet does not contain a declaration of the default decimal format, a declaration equivalent to an xsl:decimal-format element with no attributes is implied.
</ins>
</span>
      </p>
      <p>
<code>xsl:decimal-format</code> の他の属性は、 JDK 1.1 の
<a href="http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormatSymbols.html">DecimalFormatSymbols</a>
クラスが提供するメソッドに対応している。
<code>xsl:decimal-format</code> 要素には、このクラスの <code>get</code>, <code>set</code> メソッドの各ペアに対応する属性が定義されている。
<span lang="en">
The other attributes on xsl:decimal-format correspond to the methods on the JDK 1.1 DecimalFormatSymbols class.
For each get/set method pair there is an attribute defined for the xsl:decimal-format element.</span>
      </p>
      <p>

次に挙げる属性は、フォーマットパターンに含まれる文字の解釈を制御するとともに, 数値のフォーマット結果に現れる文字を規定する。
<span lang="en">
The following attributes both control the interpretation of characters in the format pattern and specify characters that may appear in the result of formatting the number:</span>
      </p>
      <ul>
         <li>
            <p>
<code>decimal-separator</code> は、小数点記号として利用する文字を指定する。
既定値はピリオド（ <code>.</code> ）。
<span lang="en">
decimal-separator specifies the character used for the decimal sign; the default value is the period character (.)</span>
            </p>
         </li>
         <li>
            <p>
<code>grouping-separator</code> は、グループ化（例えば 1000 単位）の区切り記号に用いる文字を指定する。
既定値はコンマ（ <code>,</code> ）。
<span lang="en">
grouping-separator specifies the character used as a grouping (e.g. thousands) separator; the default value is the comma character (,)</span>
            </p>
         </li>
         <li>
            <p>
<code>percent</code> は、パーセント記号に用いる文字を指定する。
既定値はパーセント（ <code>%</code> ）。
<span lang="en">
percent specifies the character used as a percent sign; the default value is the percent character (%)</span>
            </p>
         </li>
         <li>
            <p>
<code>per-mille</code> は、パーミル（千分率）記号に用いる文字を指定する。
既定値は Unicode のパーミル文字（ #x2030 ）。
<span lang="en">
per-mille specifies the character used as a per mille sign; the default value is the Unicode per-mille character (#x2030)</span>
            </p>
         </li>
         <li>
            <p>
<code>zero-digit</code> は、数表記用数字のゼロに使う文字を指定する。
既定値は数表記用数字のゼロ（ <code>0</code> ）。
<span lang="en">
zero-digit specifies the character used as the digit zero; the default value is the digit zero (0)</span>
            </p>
         </li>
      </ul>
      <p>

次に挙げる属性は、フォーマットパターンに含まれる文字の解釈を制御する。
<span lang="en">
The following attributes control the interpretation of characters in the format pattern:</span>
      </p>
      <ul>
         <li>
            <p>
<code>digit</code> は、フォーマットパターンに含まれる数字の表記に用いる文字を指定する。
既定値は番号記号（ <code>#</code> ）。
<span lang="en">
digit specifies the character used for a digit in the format pattern; the default value is the number sign character (#)</span>
            </p>
         </li>
         <li>
            <p>
<code>pattern-separator</code> は、パターン内の正の部分パターンと負の部分パターンの区切りに用いる文字を指定する。
既定値はセミコロン（ <code>;</code> ）。
<span lang="en">
pattern-separator specifies the character used to separate positive and negative sub patterns in a pattern; the default value is the semi-colon character (;)</span>
            </p>
         </li>
      </ul>
      <p>
次に挙げる属性は、数値をフォーマットした結果に現れる文字または文字列を指定する。
<span lang="en">
The following attributes specify characters or strings that may appear in the result of formatting the number:</span>
      </p>
      <ul>
         <li>
            <p>
<code>infinity</code> は、無限大の表記に用いる文字列を指定する。
既定値は文字列 <code>Infinity</code> 。
               <span lang="en">
infinity specifies the string used to represent infinity; the default value is the string Infinity</span>
            </p>
         </li>
         <li>
            <p>
<code>NaN</code> は、 NaN 型の値の表記に用いる文字列を指定する。
既定値は文字列 <code>NaN</code> 。
               <span lang="en">
NaN specifies the string used to represent the NaN value; the default value is the string NaN</span>
            </p>
         </li>
         <li>
            <p>
<code>minus-sign</code> は、負符号の表記に用いる既定の文字を指定する。
既定値はハイフンマイナス（ <code>-</code>, #x2D ）。
<span lang="en">
minus-sign specifies the character used as the default minus sign; the default value is the hyphen-minus character (-, #x2D)</span>
            </p>
         </li>
      </ul>

	</section>
	<section>

<h3 id="misc-func" title="12.4 Miscellaneous Additional Functions">12.4 その他の追加の関数</h3>
      <p>
<a id="function-current"><b>関数：</b> <i>node-set</i> <b>current</b>()</a>
         <span lang="en">
Function: node-set current()</span>
      </p>
      <p>
<b><a href="#function-current">current</a></b>
関数は、
<a href="#dt-current-node">現在のノード</a>
のみからなるノード集合を返す。
最も外側の式（他の式の内部に現れない式）においては、現在のノードは常に文脈ノードと同じになる。
従って,
<span lang="en">
The current function returns a node-set that has the current node as its only member.
For an outermost expression (an expression not occurring within another expression), the current node is always the same as the context node. Thus,</span>
      </p>
      <pre>&lt;xsl:value-of select="current()"/&gt;</pre>
      <p>
は、次と同じ意味になる。
<span lang="en">
means the same as</span>
      </p>
      <pre>&lt;xsl:value-of select="."/&gt;</pre>
      <p>
しかしながら, 角括弧内では、通常, 現在のノードと文脈ノードは異なる。
例えば：
<span lang="en">
However, within square brackets the current node is usually different from the context node. For example,</span>
      </p>
      <pre>&lt;xsl:apply-templates select="//glossary/item[@name=current()/@ref]"/&gt;</pre>
      <p>
は、親要素が <code>glossary</code>, かつ <code></code> <code>name</code> 属性の値が現在のノードの <code>ref</code> 属性の値と等しい, すべての <code>item</code> 要素を処理する。
これは次とは異なる：
<span lang="en">
will process all item elements that have a glossary parent element and that have a name attribute with value equal to the value of the current node's ref attribute.
This is different from</span>
      </p>
      <pre>&lt;xsl:apply-templates select="//glossary/item[@name=./@ref]"/&gt;</pre>
      <p>
これは次と同じ意味になる：
<span lang="en">
which means the same as</span>
      </p>
      <pre>&lt;xsl:apply-templates select="//glossary/item[@name=@ref]"/&gt;</pre>
      <p>
この場合, 親要素が <code>glossary</code>, かつ <code>name</code> 属性と <code>ref</code> 属性の値が等しい, すべての <code>item</code> 要素を処理することになる。
<span lang="en">
and so would process all item elements that have a glossary parent element and that have a name attribute and a ref attribute with the same value.</span>
      </p>
      <p>
<a href="#dt-pattern">パターン</a>
内の
<b><a href="#function-current">current</a></b>
関数の利用は、エラーとする。
<span lang="en">
It is an error to use the current function in a pattern.</span>
      </p>
      <p>
<a id="function-unparsed-entity-uri"><b>関数：</b> <i>string</i> <b>unparsed-entity-uri</b> ( <i>string</i> )</a>
         <span lang="en">
Function: string unparsed-entity-uri(string)</span>
      </p>
      <p>
<b><a href="#function-unparsed-entity-uri">unparsed-entity-uri</a></b>
関数は、文脈ノードと同じ文書に含まれる, 引数に指定された名前の解析対象外実体の URI を返す （
<a href="#unparsed-entities">[<b>3.3 解析対象外実体</b>]</a>
を見よ）。
該当する解析対象外実体が存在しない場合、空文字列を返す。
<span lang="en">
The unparsed-entity-uri returns the URI of the unparsed entity with the specified name in the same document as the context node (see [3.3 Unparsed Entities]).
It returns the empty string if there is no such entity.</span>
      </p>
      <p>
<a id="function-generate-id"><b>関数：</b> <i>string</i> <b>generate-id</b> ( <i>node-set</i>?)</a>
         <span lang="en">
Function: string generate-id(node-set?)</span>
      </p>
      <p>
<b><a href="#function-generate-id">generate-id</a></b>
関数は、引数に指定されたノード集合の中から, 文書順で最初のノードを一意的に識別する文字列を返す。
この識別子は ASCII の英数文字からなり, 先頭の文字はアルファベットでなければならない。
従って, この文字列は構文上は XML 名になる。
実装は、同じノードには常に同じ識別子を生成し, 異なるノードには常に異なる識別子を生成する限り, どのような方法で識別子を生成してもよい。
実装は、文書が変換されるごとに同じ識別子を生成する義務はない。
生成される一意的な識別子が、ソース文書内の一意 ID とは別個になる保証はない。
引数に指定されたノード集合が空の場合、空文字列を返す。
引数が省略された場合、文脈ノードが既定の引数として利用される。
<span lang="en">
The generate-id function returns a string that uniquely identifies the node in the argument node-set that is first in document order.
The unique identifier must consist of ASCII alphanumeric characters and must start with an alphabetic character.
Thus, the string is syntactically an XML name.
An implementation is free to generate an identifier in any convenient way provided that it always generates the same identifier for the same node and that different identifiers are always generated from different nodes.
An implementation is under no obligation to generate the same identifiers each time a document is transformed.
There is no guarantee that a generated unique identifier will be distinct from any unique IDs specified in the source document.
If the argument node-set is empty, the empty string is returned.
If the argument is omitted, it defaults to the context node.</span>
      </p>
      <p>
<a id="function-system-property"><b>関数：</b> <i>object</i> <b>system-property</b> ( <i>string</i> )</a>
         <span lang="en">
Function: object system-property(string)</span>
      </p>
      <p>
引数は
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
の文字列に評価されなければならない。その
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
は、式のスコープに含まれる名前空間宣言を用いて名前に展開される。
<b><a href="#function-system-property">system-property</a></b>
関数は、その名前で識別されるシステムプロパティの値を表すオブジェクトを返す。
システムプロパティが存在しない場合、空文字列を返すべきである。
<span lang="en">
The argument must evaluate to a string that is a QName.
The QName is expanded into a name using the namespace declarations in scope for the expression.
The system-property function returns an object representing the value of the system property identified by the name.
If there is no such system property, the empty string should be returned.</span>
      </p>
      <p>
実装は、次に挙げるシステムプロパティを提供しなければならない。
これらはすべて XSLT 名前空間に属する：
<span lang="en">
Implementations must provide the following system properties, which are all in the XSLT namespace:</span>
      </p>
      <ul>
         <li>
<p>
<code>xsl:version</code>。
XSLT プロセッサに実装されている XSLT のバージョンを示す数値。
この文書で規定している XSLT のバージョンを実装した XSLT プロセッサの場合、これは 1.0 になる。
<span lang="en">
xsl:version, a number giving the version of XSLT implemented by the processor; for XSLT processors implementing the version of XSLT specified by this document, this is the number 1.0</span>
</p></li>
         <li>
<p>
<code>xsl:vendor</code>。
XSLT プロセッサのベンダを識別する文字列。
<span lang="en">
xsl:vendor, a string identifying the vendor of the XSLT processor</span>
</p></li>
         <li>
<p>
<code>xsl:vendor-url</code>。
XSLT プロセッサのベンダを識別する URL を含む文字列。
通常はベンダのウェブサイトのホストページ （ホームページ）になる。
<span lang="en">
xsl:vendor-url, a string containing a URL identifying the vendor of the XSLT processor; typically this is the host page (home page) of the vendor's Web site.</span>
</p></li>
      </ul>

<p ><!-- E9 -->
<ins class="errata">ベンダは XSLT 名前空間に属する追加のシステムプロパティを定義してはならない。
</ins>
<span lang="en">
<ins class="errata">Vendors must not define additional system properties in the XSLT namespace.</ins></span>
</p>

	</section>
</section>
<section>

<h2 id="message" title="13 Messages">13 メッセージ</h2>
      <pre class="element-syntax" id="element-message">
&lt;!-- 分類：instruction --&gt;
&lt;xsl:message
  terminate = "yes" | "no"&gt;
  &lt;!-- 内容：<var>template</var> --&gt;
&lt;/xsl:message&gt;</pre>
      <p>
<code>xsl:message</code> 命令は、 XSLT プロセッサに固有の形式でメッセージを送信する。
<code>xsl:message</code> 命令の内容はテンプレートである。
<code>xsl:message</code> は、その内容のインスタンス化によりインスタンス化され, XML の素片を生成する。
この XML 素片がメッセージの内容になる。
<span lang="en">
The xsl:message instruction sends a message in a way that is dependent on the XSLT processor.
The content of the xsl:message instruction is a template.
The xsl:message is instantiated by instantiating the content to create an XML fragment.
This XML fragment is the content of the message.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
XSLT プロセッサは <code>xsl:message</code> の実装において、警告ボックスのポップアップやログファイルへの書き込みのような方法をとってもよい。
<span lang="en">
NOTE:An XSLT processor might implement xsl:message by popping up an alert box or by writing to a log file.</span>
</p>
      </blockquote>
      <p>
<code>terminate</code> 属性に <code>yes</code> が指定されている場合、 XSLT プロセッサはメッセージ送信後に処理を終了すべきである。
既定値は <code>no</code> 。
<span lang="en">
If the terminate attribute has the value yes, then the XSLT processor should terminate processing after sending the message.
The default value is no.</span>
      </p>
      <p>
ローカライズを行う便利な方法の一つは、ローカライズ済みの情報（メッセージのテキストなど）を XML 文書に挿入することである。
これは、スタイルシートへの追加の入力ファイルになる。
例えば、言語 <code><var>L</var></code> のメッセージが次の形式で XML ファイル <code>resources/<var>L</var>.xml</code> に格納されているとする：
<span lang="en">
One convenient way to do localization is to put the localized information (message text, etc.) in an XML document, which becomes an additional input file to the stylesheet.
For example, suppose messages for a language L are stored in an XML file resources/L.xml in the form:</span>
      </p>
      <pre>&lt;messages&gt;
  &lt;message name="problem"&gt;A problem was detected.&lt;/message&gt;
  &lt;message name="error"&gt;An error was detected.&lt;/message&gt;
&lt;/messages&gt;</pre>
      <p>
スタイルシートは、次のやり方でメッセージをローカライズできる：
<span lang="en">
Then a stylesheet could use the following approach to localize messages:</span>
      </p>
      <pre>&lt;xsl:param name="lang" select="<ins class="errata">'</ins>en<ins class="errata">'</ins>"/&gt;<!-- E8 -->
&lt;xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/&gt;

&lt;xsl:template name="localized-message"&gt;
  &lt;xsl:param name="name"/&gt;
  &lt;xsl:message&gt;
    &lt;xsl:value-of select="$messages/message[@name=$name]"/&gt;
  &lt;/xsl:message&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="problem"&gt;
  &lt;xsl:call-template name="localized-message"/&gt;
    &lt;xsl:with-param name="name"&gt;problem&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</pre>

</section>
<section>

<h2 id="extension" title="14 Extensions">14 拡張</h2>
      <p>
XSLT では、拡張要素と拡張関数の２種類の拡張が可能である。
<span lang="en">
XSLT allows two kinds of extension, extension elements and extension functions.</span>
      </p>
      <p>
このバージョンの XSLT では、拡張機能の実装を定義する仕組みは提供しない。
したがって, 異なる XSLT 実装間での相互利用が必須になる XSLT スタイルシートは、特定の拡張機能に依存できない。
そのため, XSLT では、 XSLT スタイルシートにおいて, それを処理する XSLT プロセッサに特定の拡張機能が実装されているかどうかを判定し、利用できない場合の処理を指定できる仕組みを提供している。
XSLT スタイルシートにおいてこの仕組みを注意深く利用することにより, 拡張機能の利便性を享受しつつ、スタイルシートがどの XSLT 実装でも有効に機能するようにできる。
<span lang="en">
This version of XSLT does not provide a mechanism for defining implementations of extensions.
Therefore, an XSLT stylesheet that must be portable between XSLT implementations cannot rely on particular extensions being available.
XSLT provides mechanisms that allow an XSLT stylesheet to determine whether the XSLT processor by which it is being processed has implementations of particular extensions available, and to specify what should happen if those extensions are not available.
If an XSLT stylesheet is careful to make use of these mechanisms, it is possible for it to take advantage of extensions and still work with any XSLT implementation.</span>
      </p>

	<section>

<h3 id="extension-element" title="14.1 Extension Elements">14.1 拡張要素</h3>
      <p>
要素を拡張する仕組みにより、名前空間を <dfn id="dt-extension-namespace">拡張名前空間</dfn> に指定できる（以下「拡張指定」）。
名前空間が拡張指定にされると, その名前空間に属する名前の要素は、テンプレートの中ではリテラル結果要素としてではなく, 命令として扱われる。
この名前空間は、命令の意味内容を定める。
<span lang="en">
The element extension mechanism allows namespaces to be designated as extension namespaces.
When a namespace is designated as an extension namespace and an element with a name from that namespace occurs in a template, then the element is treated as an instruction rather than as a literal result element.
The namespace determines the semantics of the instruction.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
<code>xsl:stylesheet</code> 要素の子要素は<em>テンプレートの内部</em>の要素ではないので, 非 XSLT の
<a href="#dt-top-level">トップレベル</a>
の要素は、ここで定義する拡張要素には該当せず, この節の内容は全て適用されない。
<span lang="en">
NOTE:Since an element that is a child of an xsl:stylesheet element is not occurring in a template, non-XSLT top-level elements are not extension elements as defined here, and nothing in this section applies to them.</span>
</p>
      </blockquote>
      <p>
名前空間を拡張指定にするためには、 <code>xsl:stylesheet</code> 要素に <code>extension-element-prefixes</code> 属性を与えるか, リテラル結果要素または拡張要素に <code>xsl:extension-element-prefixes</code> 属性を与える。
これらの属性の値は、いずれも名前空間接頭辞の空白区切りのリストである。
各接頭辞に結びつけられた名前空間が、拡張指定にされる。
<code>extension-element-prefixes</code> 属性または <code>xsl:extension-element-prefixes</code> 属性を持つ要素のスコープに, これらの接頭辞に結びつけられた名前空間が存在しない場合、エラーとする。
名前空間接頭辞のリストに <code>#default</code> を含めることにより, 既定の名前空間（ <code>xmlns</code> で宣言されたもの）を拡張指定にしてもよい。
名前空間の拡張指定は、 <code>extension-element-prefixes</code> 属性または <code>xsl:extension-element-prefixes</code> 属性を持つ要素をルートとするスタイルシートの部分ツリーの中で有効になる。
<code>xsl:stylesheet</code> 要素をルートとする部分ツリーでは、その <code>xsl:stylesheet</code> 要素の子によりインポートまたはインクルードされたスタイルシートには指定の効力は及ばない。
<span lang="en">
A namespace is designated as an extension namespace by using an extension-element-prefixes attribute on an xsl:stylesheet element or an xsl:extension-element-prefixes attribute on a literal result element or extension element.
The value of both these attributes is a whitespace-separated list of namespace prefixes.
The namespace bound to each of the prefixes is designated as an extension namespace.
It is an error if there is no namespace bound to the prefix on the element bearing the extension-element-prefixes or xsl:extension-element-prefixes attribute.
The default namespace (as declared by xmlns) may be designated as an extension namespace by including #default in the list of namespace prefixes.
The designation of a namespace as an extension namespace is effective within the subtree of the stylesheet rooted at the element bearing the extension-element-prefixes or xsl:extension-element-prefixes attribute; a subtree rooted at an xsl:stylesheet element does not include any stylesheets imported or included by children of that xsl:stylesheet element.</span>
      </p>
      <p>
XSLT プロセッサが特定の拡張要素に対応する実装を備えていない場合、
<b><a href="#function-element-available">element-available</a></b>
関数はその要素の名前に対し, 偽を返さなければならない。
そのような拡張要素がインスタンス化される際は、 XSLT プロセッサは
<a href="#fallback">[<b>15 フォールバック</b>]</a>
に則って, その要素に対するフォールバックを実行しなければならない。
XSLT プロセッサは、単に実装が対応しない拡張要素がテンプレートに含まれているだけの理由でエラーを通知してはならない。
<span lang="en">
If the XSLT processor does not have an implementation of a particular extension element available, then the element-available function must return false for the name of the element.
When such an extension element is instantiated, then the XSLT processor must perform fallback for the element as specified in [15 Fallback].
An XSLT processor must not signal an error merely because a template contains an extension element for which no implementation is available.</span>
      </p>
      <p>
XSLT プロセッサの実装が特定の拡張要素に対応している場合、
<b><a href="#function-element-available">element-available</a></b>
関数はその要素の名前に対し, 真を返さなければならない。
<span lang="en">
If the XSLT processor has an implementation of a particular extension element available, then the element-available function must return true for the name of the element.</span>
      </p>

	</section>
	<section>

<h3 id="section-Extension-Functions" title="14.2 Extension Functions">14.2 拡張関数</h3>
      <p>
式
<a href="xpath10-ja.html#NT-FunctionCall">FunctionCall</a>
（関数呼び出しの生成規則）に含まれる
<a href="xpath10-ja.html#NT-FunctionName">FunctionName</a>
（関数名）が
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-NCName">NCName</a>
でない場合（すなわちコロンが含まれる）、この FunctionName は拡張関数の呼び出しとして扱われる。
この
<a href="xpath10-ja.html#NT-FunctionName">FunctionName</a>
は評価文脈のスコープに入る名前空間宣言を用いて名前に展開される。
<span lang="en">
If a FunctionName in a FunctionCall expression is not an NCName (i.e. if it contains a colon), then it is treated as a call to an extension function.
The FunctionName is expanded to a name using the namespace declarations from the evaluation context.</span>
      </p>
      <p>
XSLT プロセッサの実装が特定の名前の拡張関数に対応していない場合、
<b><a href="#function-function-available">function-available</a></b>
関数はその名前に対し, 偽を返さなければならない。
そのような拡張関数が式に現れ, 実際に呼び出された場合、 XSLT プロセッサはエラーを通知しなければならない。
XSLT プロセッサは、実装が対応しない拡張関数が式に含まれているだけの理由でエラーを通知してはならない。
<span lang="en">
If the XSLT processor does not have an implementation of an extension function of a particular name available, then the function-available function must return false for that name.
If such an extension function occurs in an expression and the extension function is actually called, the XSLT processor must signal an error.
An XSLT processor must not signal an error merely because an expression contains an extension function for which no implementation is available.</span>
      </p>
      <p>
XSLT プロセッサの実装が特定の名前の拡張関数に対応している場合、
<b><a href="#function-function-available">function-available</a></b>
関数はその名前に対し、真を返さなければならない。
そのような拡張機能が呼び出された場合、 XSLT プロセッサは関数呼び出しの引数を渡して実装を呼び出さなければならない。
実装から返された結果が、その関数呼び出しの結果として返される。
<span lang="en">
If the XSLT processor has an implementation of an extension function of a particular name available, then the function-available function must return true for that name.
If such an extension is called, then the XSLT processor must call the implementation passing it the function call arguments; the result returned by the implementation is returned as the result of the function call.</span>
      </p>

	</section>
</section>
<section>

<h2 id="fallback" title="15 Fallback">15 フォールバック</h2>
      <pre class="element-syntax" id="element-fallback">
&lt;!-- 分類：instruction --&gt;
&lt;xsl:fallback&gt;
  &lt;!-- 内容：<var>template</var> --&gt;
&lt;/xsl:fallback&gt;</pre>
      <p>
通常, <code>xsl:fallback</code> 要素のインスタンス化では何も実行されないが、 XSLT プロセッサがある命令要素に対し, フォールバックを実行する場合、その命令要素に１個以上の <code>xsl:fallback</code> 子要素が含まれているならば、それら各子要素の内容を順次インスタンス化しなければならない。
そうでないならば、エラーを通知しなければならない。
<code>xsl:fallback</code> 要素の内容はテンプレートである。
<span lang="en">
Normally, instantiating an xsl:fallback element does nothing.
However, when an XSLT processor performs fallback for an instruction element, if the instruction element has one or more xsl:fallback children, then the content of each of the xsl:fallback children must be instantiated in sequence; otherwise, an error must be signaled.
The content of an xsl:fallback element is a template.</span>
      </p>
      <p>
<code>xsl:choose</code> 命令および <code>xsl:if</code> 命令と伴に次の関数を利用すると、特定の要素または関数を利用できない場合のスタイルシートのふるまいを明示的に制御できる。
<span lang="en">
The following functions can be used with the xsl:choose and xsl:if instructions to explicitly control how a stylesheet should behave if particular elements or functions are not available.</span>
      </p>
      <p>
<a id="function-element-available"><b>関数：</b> <i>boolean</i> <b>element-available</b> ( <i>string</i> )</a>
         <span lang="en">
Function: boolean element-available(string)</span>
      </p>
      <p>
引数は
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
の文字列に評価されなければならない。
この
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
は、式のスコープに入る名前空間宣言を用いて
<a href="xpath10-ja.html#dt-expanded-name">展開名</a>
に展開される。

<ins class="errata">
スコープに既定の名前空間が入る場合、それが接頭辞無しの
<a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a>
の展開に用いられる。
</ins><!-- E7 -->

<b><a href="#function-element-available">element-available</a></b>
関数は、展開名が命令の名前に一致するとき, そのときに限り真を返す。
展開名が XSLT 名前空間 URI と同じ名前空間 URI を持つ場合、 XSLT が定義する要素を参照する。
他の場合は拡張要素を参照する。
展開名の名前空間 URI が null の場合、
<b><a href="#function-element-available">element-available</a></b>
関数は偽を返す。
<span lang="en">
The argument must evaluate to a string that is a QName.
The QName is expanded into an expanded-name using the namespace declarations in scope for the expression. 

<ins class="errata"> If there is a default namespace in scope, then it is used to expand an unprefixed QName.</ins><!-- E7 -->

The element-available function returns true if and only if the expanded-name is the name of an instruction.
If the expanded-name has a namespace URI equal to the XSLT namespace URI, then it refers to an element defined by XSLT.
Otherwise, it refers to an extension element.
If the expanded-name has a null namespace URI, the element-available function will return false.</span>
      </p>
      <p>
<a id="function-function-available"><b>関数：</b> <i>boolean</i> <b>function-available</b> ( <i>string</i> )</a>
         <span lang="en">
Function: boolean function-available(string)</span>
      </p>
      <p>
引数は
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
の文字列に評価されなければならない。
この
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
は、式のスコープに入る名前空間宣言を用いて
<a href="xpath10-ja.html#dt-expanded-name">展開名</a>
に展開される。
<b><a href="#function-function-available">function-available</a></b>
関数は、展開名が関数名として関数ライブラリに含まれる場合にのみ真を返す。
展開名が非 null 名前空間 URI を持つ場合、拡張関数を参照する。
他の場合、 XPath または XSLT が定義する関数を参照する。
<span lang="en">
The argument must evaluate to a string that is a QName.
The QName is expanded into an expanded-name using the namespace declarations in scope for the expression.
The function-available function returns true if and only if the expanded-name is the name of a function in the function library.
If the expanded-name has a non-null namespace URI, then it refers to an extension function; otherwise, it refers to a function defined by XPath or XSLT.</span>
      </p>

</section>
<section>

<h2 id="output" title="16 Output">16 出力</h2>
      <pre class="element-syntax" id="element-output">
&lt;!-- 分類：top-level-element --&gt;
&lt;xsl:output
  method = "xml" | "html" | "text" | <var>qname-but-not-ncname</var> 
  version = <var>nmtoken</var> 
  encoding = <var>string</var> 
  omit-xml-declaration = "yes" | "no"
  standalone = "yes" | "no"
  doctype-public = <var>string</var> 
  doctype-system = <var>string</var> 
  cdata-section-elements = <var>qnames</var> 
  indent = "yes" | "no"
  media-type = <var>string</var> /&gt;</pre>
      <p>
XSLT プロセッサは、バイト列として結果ツリーを出力してもよいが, この形式の出力機能は要求されていない（
<a href="#conformance">[<b>17 適合性</b>]</a>
を見よ）。
<code>xsl:output</code> 要素を利用して、結果ツリーの出力方法をスタイルシートの作成時に指定できる。
XSLT プロセッサが結果ツリーを出力する際は <code>xsl:output</code> 要素の指定に従って出力すべきである。
しかしながら、これは必須ではない。
<span lang="en">
An XSLT processor may output the result tree as a sequence of bytes, although it is not required to be able to do so (see [17 Conformance]).
The xsl:output element allows stylesheet authors to specify how they wish the result tree to be output.
If an XSLT processor outputs the result tree, it should do so as specified by the xsl:output element; however, it is not required to do so.</span>
      </p>
      <p>
<code>xsl:output</code> 要素は、
<a href="#dt-top-level">トップレベル</a>
の要素としてのみ許容される。
<span lang="en">
The xsl:output element is only allowed as a top-level element.</span>
      </p>
      <p>
<code>xsl:output</code> の <code>method</code> 属性は、結果ツリーの出力全般に渡り適用されるべきメソッド（フォーマット方式）を指定する。
この値は
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
でなければならない。
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
に接頭辞がない場合、この仕様が規定する出力メソッドであるものと解釈され, 値は <code>xml</code>, <code>html</code>, <code>text</code> のいずれかでなければならない。
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
に接頭辞がある場合、
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
は
<a href="#qname">[<b>2.4 修飾名</b>]</a>
に則って
<a href="xpath10-ja.html#dt-expanded-name">展開名</a>
に展開され, この展開名から出力メソッドが特定される。
この場合のふるまいについてはこの仕様では規定しない。
<span lang="en">
The method attribute on xsl:output identifies the overall method that should be used for outputting the result tree.
The value must be a QName.
If the QName does not have a prefix, then it identifies a method specified in this document and must be one of xml, html or text.
If the QName has a prefix, then the QName is expanded into an expanded-name as described in [2.4 Qualified Names]; the expanded-name identifies the output method; the behavior in this case is not specified by this document.</span>
      </p>
      <p>
<code>method</code> 属性の既定は、次のように選択される。
まず, 以下の条件を満たすとき、既定の出力メソッドは <code>html</code> になる：
<span lang="en">
The default for the method attribute is chosen as follows. If</span>
      </p>
      <ul>
         <li>
            <p>
結果ツリーのルートノードが子要素を持ち, かつ
<span lang="en">
the root node of the result tree has an element child,</span>
            </p>
         </li>
         <li>
            <p>
結果ツリーのルートノードの１個目の子要素（すなわち文書要素）の展開名の局所部が <code>html</code> で（文字の大小は区別されない）, その名前空間 URI が null であり, かつ
<span lang="en">
the expanded-name of the first element child of the root node (i.e. the document element) of the result tree has local part html (in any combination of upper and lower case) and a null namespace URI, and</span>
            </p>
         </li>
         <li>
            <p>
結果ツリーのルートノードの１個目の子要素より前に現れるすべてのテキストノードが、空白文字のみからなる。
<span lang="en">
any text nodes preceding the first element child of the root node of the result tree contain only whitespace characters,</span>
            </p>
         </li>
      </ul>
      <p>
上記以外の場合、既定の出力メソッドは <code>xml</code> になる。
<code>xsl:output</code> 要素が与えられていない場合, あるいはどの <code>xsl:output</code> 要素にも <code>method</code> 属性の値が指定されていない場合、既定の出力メソッドが利用されるべきである。
<span lang="en">
then the default output method is html; otherwise, the default output method is xml.
The default output method should be used if there are no xsl:output elements or if none of the xsl:output elements specifies a value for the method attribute.</span>
      </p>
      <p>
<code>xsl:output</code> の他の属性には、出力メソッドに与えるパラメタを指定する。
以下に挙げる属性がある：
<span lang="en">
The other attributes on xsl:output provide parameters for the output method.
The following attributes are allowed:</span>
      </p>
      <ul>
         <li>
            <p>
<code>version</code> には、出力メソッドのバージョンを指定する。
<span lang="en">
version specifies the version of the output method</span>
            </p>
         </li>
         <li>
            <p>
<code>indent</code> には、 XSLT プロセッサによる結果ツリーの出力に追加の空白を挿入してもよいかどうかを指定する。
値は <code>yes</code> または <code>no</code> でなければならない。
               <span lang="en">
indent specifies whether the XSLT processor may add additional whitespace when outputting the result tree; the value must be yes or no</span>
            </p>
         </li>
         <li>
            <p>
<code>encoding</code> には、文字列をバイト列に符号化する際に XSLT プロセッサが利用すべき望ましい文字エンコーディング（符号化法）を指定する。
この属性値の文字の大小は区別せずに扱われるべきである。
値を構成する文字は #x21 から #x7E まで（すなわち ASCII 印字可能文字）でなければならない。
値は、 IANA （ Internet Assigned Numbers Authority ）
<a href="#IANA">[IANA]</a>
または
<a href="#RFC2278">[RFC2278]</a>
に登録されている <code>charset</code> 名または <code>X-</code> から始まる文字列にすべきである。
               <span lang="en">
encoding specifies the preferred character encoding that the XSLT processor should use to encode sequences of characters as sequences of bytes; the value of the attribute should be treated case-insensitively; the value must contain only characters in the range #x21 to #x7E (i.e. printable ASCII characters); the value should either be a charset registered with the Internet Assigned Numbers Authority [IANA], [RFC2278] or start with X-</span>
            </p>
         </li>
         <li>
            <p>
<code>media-type</code> には、結果ツリーの出力結果のデータのメディア型（ MIME 内容型）を指定する。
この属性には <code>charset</code> パラメタを明示的に指定すべきではなく, トップレベルのメディア型が <code>text</code> の場合には、出力メソッドで実際に用いられる文字エンコーディングに対応する <code>charset</code> パラメタを追加すべきである。
<!-- □ -->
<span lang="en">
media-type specifies the media type (MIME content type) of the data that results from outputting the result tree; the charset parameter should not be specified explicitly; instead, when the top-level media type is text, a charset parameter should be added according to the character encoding actually used by the output method</span>
            </p>
         </li>
         <li>
            <p>
<code>doctype-system</code> には、文書型宣言に利用するシステム識別子を指定する。
<span lang="en">
doctype-system specifies the system identifier to be used in the document type declaration</span>
            </p>
         </li>
         <li>
            <p>
<code>doctype-public</code> には、文書型宣言に利用する公開識別子を指定する。
<span lang="en">
doctype-public specifies the public identifier to be used in the document type declaration</span>
            </p>
         </li>
         <li>
            <p>
<code>omit-xml-declaration</code> には、 XSLT プロセッサが XML 宣言を出力すべきかどうかを指定する。
値は <code>yes</code> または <code>no</code> でなければならない。
               <span lang="en">
omit-xml-declaration specifies whether the XSLT processor should output an XML declaration; the value must be yes or no</span>
            </p>
         </li>
         <li>
            <p>
<code>standalone</code> には、 XSLT プロセッサがスタンドアロン文書宣言を出力すべきかどうかを指定する。
値は <code>yes</code> または <code>no</code> でなければならない。
               <span lang="en">
standalone specifies whether the XSLT processor should output a standalone document declaration; the value must be yes or no</span>
            </p>
         </li>
         <li>
            <p>
<code>cdata-section-elements</code> には、子テキストノードを CDATA セクションにくるんで出力すべき要素の名前のリストを指定する。
<span lang="en">
cdata-section-elements specifies a list of the names of elements whose text node children should be output using CDATA sections</span>
            </p>
         </li>
      </ul>
      <p>
各属性の意味内容の詳細は、その属性の適用対象になる出力メソッドごとに説明を与える。
意味内容についての言及がない所は、その出力メソッドにはその属性が適用されないことを意味する。
<span lang="en">
The detailed semantics of each attribute will be described separately for each output method for which it is applicable. If the semantics of an attribute are not described for an output method, then it is not applicable to that output method.</span>
      </p>
      <p>
スタイルシートは複数の <code>xsl:output</code> 要素を含み得る。
また, <code>xsl:output</code> 要素を持つ他のスタイルシートのインクルードやインポートもできる。
スタイルシートに現れるすべての <code>xsl:output</code> 要素は、１個の有効な <code>xsl:output</code> 要素に併合される。
<code>cdata-section-elements</code> 属性については、指定された値全体の和集合が有効な値になる。
その他の属性については、指定された値のうち
<a href="#dt-import-precedence">インポート優先順位</a>
が最高のものが有効な値になる。
一つの属性において最高の優先順位を持つ値が複数存在する場合、エラーとする。
XSLT プロセッサはエラーを通知してもよい。
エラーを通知しない場合、スタイルシートの最後方に現れる値を利用して, エラーから回復すべきである。
属性の既定値は <code>xsl:output</code> 要素が併合された後で設定される。
属性の既定値は出力メソッドにより異なり得る。
<span lang="en">
A stylesheet may contain multiple xsl:output elements and may include or import stylesheets that also contain xsl:output elements.
All the xsl:output elements occurring in a stylesheet are merged into a single effective xsl:output element.
For the cdata-section-elements attribute, the effective value is the union of the specified values.
For other attributes, the effective value is the specified value with the highest import precedence.
It is an error if there is more than one such value for an attribute.
An XSLT processor may signal the error; if it does not signal the error, if should recover by using the value that occurs last in the stylesheet.
The values of attributes are defaulted after the xsl:output elements have been merged; different output methods may have different default values for an attribute.</span>
      </p>

	<section>

<h3 id="section-XML-Output-Method" title="16.1 XML Output Method">16.1 XML 出力メソッド</h3>
      <p>
<code>xml</code> 出力メソッドは、結果ツリーを整形式 XML の外部一般解析対象実体として出力する。
結果ツリーのルートノードが、１個の要素を子に持ち, テキストノードは１個も子に持たない場合、この実体は整形式 XML 文書にもなる。
そのような実体が、次のような小さな XML 文書ラッパー：
<span lang="en">
The xml output method outputs the result tree as a well-formed XML external general parsed entity.
If the root node of the result tree has a single element node child and no text node children, then the entity should also be a well-formed XML document entity.
When the entity is referenced within a trivial XML document wrapper like this</span>
      </p>
      <pre><ins class="errata">&lt;?xml version="<var>xml-version</var>"?&gt;</ins>
&lt;!DOCTYPE doc [
&lt;!ENTITY e SYSTEM "<var>entity-URI</var>"&gt;
]&gt;
&lt;doc&gt;&amp;e;&lt;/doc&gt;</pre>
      <p>
から参照されている場合（
ここで <code><var>entity-URI</var></code> は実体の URI
<ins class="errata">, <code><var>xml-version</var></code> は実体に対応する XML のバージョン</ins><!-- E36 -->
を表すとする）、ラッパー文書は<!-- <del class="errata"> XML 名前空間勧告</del> -->
<a href="#XMLNAMES">[XML Names]</a>
<ins class="errata">または
<a href="#XMLNames11">[XML Names 1.1]</a></ins>
に適合する整形式 XML 文書になるべきである。
加えて, 出力に対しては、ラッパーを
<a href="#data-model">[<b>3 データモデル</b>]</a>
に則って XML 文書として構文解析し, 文書要素の子要素をルートノードの子にそっくり移し替えて出来上がるツリーが、以下に挙げる例外を除いて結果ツリーと同じになるべきである：
<span lang="en">
where entity-URI is a URI for the entity
<ins class="errata">and xml-version corresponds to the XML version of the entity</ins><!-- E36 -->
, then the wrapper document as a whole should be a well-formed XML document conforming 
<del class="errata">to the XML Namespaces Recommendation [XML Names].</del>
<ins class="errata">either to [XML Names]  or [XML Names 1.1].</ins>
In addition, the output should be such that if a new tree was constructed by parsing the wrapper as an XML document as specified in [3 Data Model], and then removing the document element, making its children instead be children of the root node, then the new tree would be the same as the result tree, with the following possible exceptions:</span>
      </p>
      <ul>
         <li>
            <p>
２つのツリーに含まれる属性
<ins class="errata">と名前空間ノード</ins><!-- E6 -->
の順序は異なってもよい。
<span lang="en">
The order of attributes
<ins class="errata">and namespace nodes</ins><!-- E6 -->
in the two trees may be different.</span>
            </p>
         </li>
         <li>
            <p>
新しいツリーは、結果ツリーに存在しない名前空間ノードを含んでもよい。
<span lang="en">
The new tree may contain namespace nodes that were not present in the result tree.</span>
            </p>
            <blockquote>
<p>
<b>注記：</b>
XSLT プロセッサは、結果ツリーを XML として出力する際に名前空間宣言を追加する必要も生じ得る。
<span lang="en">
NOTE:An XSLT processor may need to add namespace declarations in the course of outputting the result tree as XML.</span>
</p>
            </blockquote>
         </li>
         <li class="errata"><!-- E5 -->
            <p>
<ins class="errata">２つのツリーのノードの基底 URI は異なってもよい。
</ins>
<span lang="en">
<ins class="errata">The base URIs of nodes in the two trees may be different.</ins>
</span>
            </p>
         </li>
      </ul>
      <p>
<!-- 
<del class="errata"><code>doctype-system</code> 属性の指定によって XSLT プロセッサが文書型宣言を生成する場合があるが、このような場合には、生成した文書型宣言を削除した実体に対して、上記の要件が適用される。
</del>
 -->
<ins class="errata">
XSLT プロセッサが <code>doctype-system</code> 属性の指定により文書型宣言を生成する場合, あるいは <code>standalone</code> 属性の指定によりスタンドアロン文書宣言を生成する場合、出力は整形式 XML 文書でなければならず, 上の要件は DTD を処理しない XML プロセッサを用いて出力文書をラッパ無しに直接構文解析することにより構築されるツリーに適用される。
</ins><!-- E4 -->

<span lang="en">
<del class="errata">If the XSLT processor generated a document type declaration because of the doctype-system attribute, then the above requirements apply to the entity with the generated document type declaration removed.</del>

<ins class="errata">If the XSLT processor generated a document type declaration because of the doctype-system attribute or generated a standalone document declaration because of the standalone attribute, then the output must be a well-formed XML document, and the above requirements apply to the tree constructed by parsing that document directly, without any wrapper, using an XML processor that does not process the DTD.
</ins><!-- E4 -->
</span>
      </p>

            <blockquote><!-- E4 -->
<p>
<b>注記：</b>
<ins class="errata">DTD の処理が行われる場合、属性の既定値により, ツリー内に追加の属性が現れ得る。
</ins>
<span lang="en">
<ins class="errata">
NOTE:Processing the DTD might cause additional attributes to appear in the tree because of attribute defaulting.
</ins>
</span>
</p>
            </blockquote>


      <p>
<code>version</code> 属性は、結果ツリーの出力に利用される XML のバージョンを指定する。
XSLT プロセッサは, このバージョンをサポートしない場合、サポートするバージョンを利用すべきである。
XML 宣言が出力される場合、宣言内に出力されるバージョンは,  XSLT プロセッサが結果ツリーの出力に利用したバージョンに対応するものにすべきである。
<!-- 
<del class="errata"><code>version</code> 属性の値は、 XML 勧告
<a href="#XML">[XML]</a>
の生成規則
<a href="http://www.w3.org/TR/REC-xml/index.html#NT-VersionNum">VersionNum</a>
に該当すべきである。
既定値は <code>1.0</code> 。
</del>
 -->
<!-- E36 -->
<ins class="errata">
既定値は <code >1.0</code> 。
値が <code >1.1</code> で XSLT プロセッサが XML 1.1 と XML Names 1.1 をともにサポートする場合、次の制約が課せられる：
</ins>
<span lang="en">
The version attribute specifies the version of XML to be used for outputting the result tree.
If the XSLT processor does not support this version of XML, it should use a version of XML that it does support.
The version output in the XML declaration (if an XML declaration is output) should correspond to the version of XML that the processor used for outputting the result tree. 
<del class="errata">The value of the version attribute should match the VersionNum production of the XML Recommendation [XML].
The default value is 1.0.</del><!-- E36 -->
<ins class="errata">The default value is 1.0.
If the value is 1.1 and the XSLT processor does support XML 1.1 and XML Names 1.1, then the following restrictions apply: </ins>
</span>
      </p>

<ul class="errata">
  <li><p><ins class="errata">接頭辞の宣言取り消しが生じてはならない。
</ins>
<span lang="en">
<ins class="errata">Undeclaring prefixes must not occur.</ins></span>
</p></li>
  <li><p><ins class="errata">Unicode 正規化が生じてはならない。
</ins>
<span lang="en">
<ins class="errata">Unicode normalization must not occur.</ins></span>
</p></li>
</ul>
      <p>
<code>encoding</code> 属性には、結果ツリーの出力処理に望まれるエンコーディングを指定する。
XSLT プロセッサには、値 <code>UTF-8</code> と <code>UTF-16</code> に対するサポートが要求される。
他の値については,  XSLT プロセッサが未サポートのエンコーディングが指定された場合、 XSLT プロセッサはエラーを通知してもよい。
エラーを通知しない場合、代わりに <code>UTF-8</code> または <code>UTF-16</code> を利用すべきである。
XSLT プロセッサは、 XML 勧告
<a href="#XML">[XML]</a>
<ins class="errata">
または
<a href="#XML11">[XML 1.1]</a>
</ins><!-- E36 -->
の生成規則
<a href="http://www.w3.org/TR/REC-xml/index.html#NT-EncName">EncName</a>
に合致しない名前のエンコーディングを利用してはならない。
<code>encoding</code> 属性が指定されていない場合、 XSLT プロセッサは <code>UTF-8</code> または <code>UTF-16</code> のいずれかを利用すべきである。
結果ツリーには、 XSLT プロセッサが出力に利用するエンコーディングでは表現できない文字も含まれ得る。
この場合、 XML において文字参照が認識され得る場所に（すなわち属性ノードの値の中またはテキストノードの内部に）その文字が現れるのであれば, 文字参照として出力すべきである。
それ以外の場合（例えばその文字が要素名に現れる場合）、 XSLT プロセッサはエラーを通知すべきである。
<span lang="en">
The encoding attribute specifies the preferred encoding to use for outputting the result tree.
XSLT processors are required to respect values of UTF-8 and UTF-16.
For other values, if the XSLT processor does not support the specified encoding it may signal an error; if it does not signal an error it should use UTF-8 or UTF-16 instead.
The XSLT processor must not use an encoding whose name does not match the EncName production of the XML Recommendation [XML] 
<ins class="errata">or [XML 1.1]</ins><!-- E36 -->.
If no encoding attribute is specified, then the XSLT processor should use either UTF-8 or UTF-16.
It is possible that the result tree will contain a character that cannot be represented in the encoding that the XSLT processor is using for output.
In this case, if the character occurs in a context where XML recognizes character references (i.e. in the value of an attribute node or text node), then the character should be output as a character reference; otherwise (for example if the character occurs in the name of an element) the XSLT processor should signal an error.</span>
      </p>
      <p>
<code>indent</code> 属性の値が <code>yes</code> の場合、 <code>xml</code> 出力メソッドは, 結果を見栄え良くインデント（字下げ）するため, 結果ツリー内の空白に（可能ならソース文書やスタイルシートから削除された空白などを基にして）空白を追加して出力してもよい。
<code>indent</code> 属性の値が <code>no</code> （既定値）の場合、空白を追加出力すべきではない。
<code>xml</code> 出力メソッドで利用する空白追加出力のアルゴリズムは、その出力に対し <code>xsl:text</code> のみを空白保持要素名の集合として
<a href="#strip">[<b>3.4 空白の削除</b>]</a>
で述べたプロセスにより空白を削除した結果が、空白を追加出力しないときの出力に対し同じプロセスを適用した結果と一致するようなものになるべきである。
<span lang="en">
If the indent attribute has the value yes, then the xml output method may output whitespace in addition to the whitespace in the result tree (possibly based on whitespace stripped from either the source document or the stylesheet) in order to indent the result nicely; if the indent attribute has the value no, it should not output any additional whitespace.
The default value is no.
The xml output method should use an algorithm to output additional whitespace that ensures that the result if whitespace were to be stripped from the output using the process described in [3.4 Whitespace Stripping] with the set of whitespace-preserving elements consisting of just xsl:text would be the same when additional whitespace is output as when additional whitespace is not output.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
一般に、混合内容を持つ要素型を含む文書型に <code>indent="yes"</code> を利用すると問題が生じ易い。
<span lang="en">
NOTE:It is usually not safe to use indent="yes" with document types that include element types with mixed content.</span>
</p>
      </blockquote>
      <p>
<code>cdata-section-elements</code> 属性の値は、空白区切りの
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
のリストである。
これらの
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
は、各
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
が現れる <code>xsl:output</code> 要素で有効な名前空間宣言を用いて展開名に展開される。
接頭辞を持たない
<a href="http://www.w3.org/TR/REC-xml-names/index.html#NT-QName">QName</a>
の展開には、既定の名前空間が（存在すれば）利用される。
この展開処理は、複数の <code>xsl:output</code> 要素が有効な <code>xsl:output</code> 要素に併合される前に行われる。
テキストノードはその親の展開名がこのリストに含まれるならば CDATA セクションとして出力されるべきである。
例えば：
<span lang="en">
The cdata-section-elements attribute contains a whitespace-separated list of QNames.
Each QName is expanded into an expanded-name using the namespace declarations in effect on the xsl:output element in which the QName occurs; if there is a default namespace, it is used for QNames that do not have a prefix.
The expansion is performed before the merging of multiple xsl:output elements into a single effective xsl:output element.
If the expanded-name of the parent of a text node is a member of the list, then the text node should be output as a CDATA section. For example,</span>
      </p>
      <pre>&lt;xsl:output cdata-section-elements="example"/&gt;</pre>
      <p>
により、次のリテラル結果要素：
<span lang="en">
would cause a literal result element written in the stylesheet as</span>
      </p>
      <pre>&lt;example&gt;&amp;lt;foo&gt;&lt;/example&gt;</pre>
      <p>
あるいは、次のリテラル結果要素：
<span lang="en">
or as</span>
      </p>
      <pre>&lt;example&gt;&lt;![CDATA[&lt;foo&gt;]]&gt;&lt;/example&gt;</pre>
      <p>
の出力は、いずれも次のようになる：
<span lang="en">
to be output as</span>
      </p>
      <pre>&lt;example&gt;&lt;![CDATA[&lt;foo&gt;]]&gt;&lt;/example&gt;</pre>
      <p>
テキストノードが文字列 <code>]]&gt;</code> を含む場合、処理中の CDATA セクションを <code>]]</code> の直後で閉じ, 新たな CDATA セクションを <code>&gt;</code> の直前から開始させるべきである。
例えば、スタイルシートの次のリテラル結果要素：
<span lang="en">
If the text node contains the sequence of characters ]]&gt;, then the currently open CDATA section should be closed following the ]] and a new CDATA section opened before the &gt;.
For example, a literal result element written in the stylesheet as</span>
      </p>
      <pre>&lt;example&gt;]]&amp;gt;&lt;/example&gt;</pre>
      <p>
の出力は、次のようになる：
<span lang="en">
would be output as</span>
      </p>
      <pre>&lt;example&gt;&lt;![CDATA[]]]]&gt;&lt;![CDATA[&gt;]]&gt;&lt;/example&gt;</pre>
      <p>
結果ツリーの出力に利用する文字エンコーディングで表現できない文字がテキストノードに含まれている場合、処理中の CDATA セクションをその文字の直前で閉じ, その文字を文字参照または実体参照を用いて出力し, 新たな CDATA セクションを開始してから後続の文字出力するべきである。
<span lang="en">
If the text node contains a character that is not representable in the character encoding being used to output the result tree, then the currently open CDATA section should be closed before the character, the character should be output using a character reference or entity reference, and a new CDATA section should be opened for any further characters in the text node.</span>
      </p>
      <p>
<code>cdata-section-elements</code> 属性により CDATA セクションを用いた出力が明示的に指示されていない限り、テキストノードの出力に CDATA セクションを用いるべきではない。
<span lang="en">
CDATA sections should not be used except for text nodes that the cdata-section-elements attribute explicitly specifies should be output using CDATA sections.</span>
      </p>
      <p>
<code>omit-xml-declaration</code> 属性の値が <code>yes</code> でない限り、 <code>xml</code> 出力メソッドは XML 宣言を出力すべきである。
XML 宣言には、バージョン情報もエンコーディング宣言も含めるべきである。
<code>standalone</code> 属性が指定されている場合はその属性値と同じ値のスタンドアロン文書宣言も含めるべきである。
そうでない場合、スタンドアロン文書宣言は含めるべきではない：これにより, （文書実体の先頭で記述が許されている） XML 宣言になると同時に、（外部一般解析対象実体の先頭で記述が許されている）テキスト宣言にもなるので。
<span lang="en">
The xml output method should output an XML declaration unless the omit-xml-declaration attribute has the value yes.
The XML declaration should include both version information and an encoding declaration.
If the standalone attribute is specified, it should include a standalone document declaration with the same value as the value as the value of the standalone attribute.
Otherwise, it should not include a standalone document declaration; this ensures that it is both a<ins class="errata">n</ins><!-- E3 --> XML declaration (allowed at the beginning of a document entity) and a text declaration (allowed at the beginning of an external general parsed entity).</span>
      </p>
      <p>
<code>doctype-system</code> 属性が指定されている場合、 <code>xml</code> 出力メソッドは最初の要素の直前に文書型宣言を出力すべきである。
<code>&lt;!DOCTYPE</code> に後続する名前は、最初の要素の名前になるべきである。
<code>doctype-public</code> 属性も指定されている場合、 <code>xml</code> 出力メソッドは <code>PUBLIC</code> に続けて公開識別子を出力し, 次にシステム識別子を出力すべきである。
そうでない場合、 <code>SYSTEM</code> に続けてシステム識別子を出力すべきである。
内部サブセットは空にすべきである。
<code>doctype-public</code> 属性は <code>doctype-system</code> 属性が指定されていない限り無視される。
<span lang="en">
If the doctype-system attribute is specified, the xml output method should output a document type declaration immediately before the first element.
The name following &lt;!DOCTYPE should be the name of the first element.
If doctype-public attribute is also specified, then the xml output method should output PUBLIC followed by the public identifier and then the system identifier; otherwise, it should output SYSTEM followed by the system identifier.
The internal subset should be empty.
The doctype-public attribute should be ignored unless the doctype-system attribute is specified.</span>
      </p>
      <p>
<code>media-type</code> 属性は <code>xml</code> 出力メソッドに適用できる。
既定の値は <code>text/xml</code> である。
<span lang="en">
The media-type attribute is applicable for the xml output method.
The default value for the media-type attribute is text/xml.</span>
      </p>

	</section>
	<section>

<h3 id="section-HTML-Output-Method" title="16.2 HTML Output Method">16.2 HTML 出力メソッド</h3>
      <p>
<code>html</code> 出力メソッドは結果ツリーを HTML として出力する。
例を次に示す。
<span lang="en">
The html output method outputs the result tree as HTML; for example,</span>
      </p>
      <pre>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
   &lt;xsl:apply-templates/&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

...

&lt;/xsl:stylesheet&gt;</pre>
      <p>
<code>version</code> 属性は HTML のバージョンを指示する。
既定値の <code>4.0</code> は、結果ツリーを HTML 4.0 勧告
<a href="#HTML">[HTML]</a>
に適合する HTML で出力すべきであることを指定する。
<span lang="en">
The version attribute indicates the version of the HTML.
The default value is 4.0, which specifies that the result should be output as HTML conforming to the HTML 4.0 Recommendation [HTML].</span>
      </p>
      <p>
<code>html</code> 出力メソッドは、要素の展開名の名前空間 URI が null でない限り, <code>xml</code> 出力メソッドと異なる方法で要素を出力すべきではない。
展開名が非 null の名前空間 URI を持つ要素は、 XML として出力すべきである。
展開名の名前空間 URI が null で, 局所部が HTML 要素名と認識されない要素は、 <code>span</code> などの空要素でない行内要素と同じ方法で出力すべきである。
<span lang="en">
The html output method should not output an element differently from the xml output method unless the expanded-name of the element has a null namespace URI; an element whose expanded-name has a non-null namespace URI should be output as XML.
If the expanded-name of the element has a null namespace URI, but the local part of the expanded-name is not recognized as the name of an HTML element, the element should output in the same way as a non-empty, inline element such as span.</span>
      </p>
      <p>
<code>html</code> 出力メソッドは空要素の終了タグを出力すべきではない。
HTML 4.0 の空要素は、 <code>area</code>, <code>base</code>, <code>basefont</code>, <code>br</code>, <code>col</code>, <code>frame</code>, <code>hr</code>, <code>img</code>, <code>input</code>, <code>isindex</code>, <code>link</code>, <code>meta</code>, <code>param</code> である。
例えば, スタイルシートに <code>&lt;br/&gt;</code> あるいは <code>&lt;br&gt;&lt;/br&gt;</code> と記述された要素の出力は、 <code>&lt;br&gt;</code> にすべきである。
<span lang="en">
The html output method should not output an end-tag for empty elements.
For HTML 4.0, the empty elements are area, base, basefont, br, col, frame, hr, img, input, isindex, link, meta and param.
For example, an element written as &lt;br/&gt; or &lt;br&gt;&lt;/br&gt; in the stylesheet should be output as &lt;br&gt;.</span>
      </p>
      <p>
<code>html</code> 出力メソッドは、文字の大小を区別せずに HTML 要素名を認識すべきである。
例えば、要素名 <code>br</code>, <code>BR</code>, <code>Br</code> はすべて HTML の <code>br</code> 要素と認識され, 終了タグなしで出力される。
<span lang="en">
The html output method should recognize the names of HTML elements regardless of case.
For example, elements named br, BR or Br should all be recognized as the HTML br element and output without an end-tag.</span>
      </p>
      <p>
<code>html</code> 出力メソッドは、<code>script</code> および <code>style</code> 要素の内容にエスケープ処理を施すべきではない。
例えば, 次の２つのリテラル結果要素：
<span lang="en">
The html output method should not perform escaping for the content of the script and style elements.
For example, a literal result element written in the stylesheet as</span>
      </p>
      <pre>&lt;script&gt;if (a &amp;lt; b) foo()&lt;/script&gt;</pre>
      <p>
<span lang="en">
or</span>
      </p>
      <pre>&lt;script&gt;&lt;![CDATA[if (a &lt; b) foo()]]&gt;&lt;/script&gt;</pre>
      <p>
の出力は、いずれも次になる：
<span lang="en">
should be output as</span>
      </p>
      <pre>&lt;script&gt;if (a &lt; b) foo()&lt;/script&gt;</pre>
      <p>
<code>html</code> 出力メソッドでは、属性値に現れる文字 <code>&lt;</code> をエスケープすべきではない。
<span lang="en">
The html output method should not escape &lt; characters occurring in attribute values.</span>
      </p>
      <p>
<code>indent</code> 属性の値が <code>yes</code> （既定値）の場合、<code>html</code> 出力メソッドは、 HTML ユーザエージェントによるレンダリングに影響を与えない範囲で, 結果ツリーの出力に空白を追加／削除してよい。
<span lang="en">
If the indent attribute has the value yes, then the html output method may add or remove whitespace as it outputs the result tree, so long as it does not change how an HTML user agent would render the output.
The default value is yes.</span>
      </p>
      <p>
<code>html</code> 出力メソッドは、 HTML 4.0 勧告
<a href="http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.2.1">B.2.1 節</a>
で推奨される方法を用いて, URI 属性の値に含まれる非 ASCII 文字をエスケープすべきである。
<span lang="en">
The html output method should escape non-ASCII characters in URI attribute values using the method recommended in Section B.2.1 of the HTML 4.0 Recommendation.</span>
      </p>
      <p>
<code>html</code> 出力メソッドは、文字に対する文字実体参照が利用中の HTML のバージョンで定義されていれば, 文字実体参照を用いてその文字を出力してもよい。
<span lang="en">
The html output method may output a character using a character entity reference, if one is defined for it in the version of HTML that the output method is using.</span>
      </p>
      <p>
<code>html</code> 出力メソッドは、 <code>?&gt;</code> ではなく <code>&gt;</code> により処理命令を閉じるべきである。
<span lang="en">
The html output method should terminate processing instructions with &gt; rather than ?&gt;.</span>
      </p>
      <p>
<code>html</code> 出力メソッドは、ブール型の属性（属性名と同じ値のみが, 値として許されている属性）を最小形で出力すべきである。
例えば, スタイルシートの次の開始タグ：
<span lang="en">
The html output method should output boolean attributes (that is attributes with only a single allowed value that is equal to the name of the attribute) in minimized form.
For example, a start-tag written in the stylesheet as</span>
      </p>
      <pre>&lt;OPTION selected="selected"&gt;</pre>
      <p>
の出力は次のようになる：
<span lang="en">
should be output as</span>
      </p>
      <pre>&lt;OPTION selected&gt;</pre>
      <p>
<code>html</code> 出力メソッドは属性値に現れる文字 <code>{</code> の直前の文字 <code>&amp;</code> をエスケープすべきではない（ HTML 4.0 勧告の
<a href="http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.7.1.1">B.7.1 節</a>
を見よ）。
例えば, スタイルシートに次の開始タグが記述されている場合：
<span lang="en">
The html output method should not escape a &amp; character occurring in an attribute value immediately followed by a { character (see Section B.7.1 of the HTML 4.0 Recommendation).
For example, a start-tag written in the stylesheet as</span>
      </p>
      <pre>&lt;BODY bgcolor='&amp;amp;{{randomrbg}};'&gt;</pre>
      <p>
出力は次のようになるべきである：
<span lang="en">
should be output as</span>
      </p>
      <pre>&lt;BODY bgcolor='&amp;{randomrbg};'&gt;</pre>
      <p>
<code>encoding</code> 属性は、 HTML 出力メソッドに利用する望ましい文字エンコーディングを指定する。
<code>HEAD</code> 要素がある場合、 <code>html</code> 出力メソッドは <code>HEAD</code> 要素の開始タグの直後に <code>META</code> 要素を追加して, 実際に用いられる文字エンコーディングを指定すべきである。
例えば：
<span lang="en">
The encoding attribute specifies the preferred encoding to be used.
If there is a HEAD element, then the html output method should add a META element immediately after the start-tag of the HEAD element specifying the character encoding actually used.
For example,</span>
      </p>
      <pre>&lt;HEAD&gt;
&lt;META http-equiv="Content-Type" content="text/html; charset=EUC-JP"&gt;
...</pre>
      <p>
結果ツリーには、 XSLT プロセッサが出力に利用するエンコーディングで表現できない文字も含まれ得る。
この場合、 HTML において文字参照が認識され得る場所にその文字が現れるのであれば, 文字実体参照または十進コードによる文字参照として出力すべきである。
それ以外の場合（例えば <code>script</code> 要素や <code>style</code> 要素内, またはコメント内にその文字が現れた場合）、 XSLT プロセッサはエラーを通知すべきである。
<span lang="en">
It is possible that the result tree will contain a character that cannot be represented in the encoding that the XSLT processor is using for output.
In this case, if the character occurs in a context where HTML recognizes character references, then the character should be output as a character entity reference or decimal numeric character reference; otherwise (for example, in a script or style element or in a comment), the XSLT processor should signal an error.</span>
      </p>
      <p>
<code>doctype-public</code> 属性または <code>doctype-system</code> 属性が指定されている場合、 <code>html</code> 出力メソッドは最初の要素の直前に文書型宣言を出力すべきである。
<code>&lt;!DOCTYPE</code> に後続する名前は、 <code>HTML</code> または <code>html</code> である。
<code>doctype-public</code> 属性も指定されている場合、出力メソッドは <code>PUBLIC</code> に続けて指定された公開識別子を出力すべきである。
<code>doctype-system</code> 属性も指定されている場合、公開識別子に続けてシステム識別子も出力すべきである。
<code>doctype-system</code> 属性は指定されているが, <code>doctype-public</code> 属性は指定されていない場合、出力メソッドは <code>SYSTEM</code> に続けて指定されたシステム識別子を出力すべきである。
<span lang="en">
If the doctype-public or doctype-system attributes are specified, then the html output method should output a document type declaration immediately before the first element.
The name following &lt;!DOCTYPE should be HTML or html.
If the doctype-public attribute is specified, then the output method should output PUBLIC followed by the specified public identifier; if the doctype-system attribute is also specified, it should also output the specified system identifier following the public identifier.
If the doctype-system attribute is specified but the doctype-public attribute is not specified, then the output method should output SYSTEM followed by the specified system identifier.</span>
      </p>
      <p>
<code>media-type</code> 属性は <code>html</code> 出力メソッドに適用できる。
既定の値は <code>text/html</code> 。
<span lang="en">
The media-type attribute is applicable for the html output method.
The default value is text/html.</span>
      </p>

	</section>
	<section>

<h3 id="section-Text-Output-Method" title="16.3 Text Output Method">16.3 テキスト出力メソッド</h3>
      <p>
テキスト出力メソッドにおける結果ツリーの出力では、エスケープ処理を施さずに, 結果ツリーの各テキストノードの文字列値を文書順に出力する。
<span lang="en">
The text output method outputs the result tree by outputting the string-value of every text node in the result tree in document order without any escaping.</span>
      </p>
      <p>
<code>media-type</code> 属性はテキスト出力メソッドに適用できる。
既定の値は <code>text/plain</code> である。
<span lang="en">
The media-type attribute is applicable for the text output method.
The default value for the media-type attribute is text/plain.</span>
      </p>
      <p>
<code>encoding</code> 属性には、テキスト出力メソッドが文字列をバイト列に変換する際に利用するエンコーディングを指定する。
既定の値はシステム依存になる。
XSLT プロセッサが出力に利用するエンコーディングでは表現できない文字が結果ツリーに含まれている場合、 XSLT プロセッサはエラーを通知すべきである。
<span lang="en">
The encoding attribute identifies the encoding that the text output method should use to convert sequences of characters to sequences of bytes.
The default is system-dependent.
If the result tree contains a character that cannot be represented in the encoding that the XSLT processor is using for output, the XSLT processor should signal an error.</span>
      </p>

	</section>
	<section>

<h3 id="disable-output-escaping" title="16.4 Disabling Output Escaping">16.4 出力エスケープの無効化</h3>
      <p>
通常, <code>xml</code> 出力メソッドによるテキストノードの出力においては、 &amp; や &lt; （あるいは他の文字も）にエスケープが施される。
このような処理により、出力結果は確実に整形式 XML になる。
しかしながら、出力結果が完全ではなくともほぼ整形式 XML になっていることが便利な場合もある。
例えば、後段の XML 非対応の処理プロセスで整形式 XML に変換することを意図して, 整形式でないセクションを出力結果に含める場合など。
このため XSLT では、出力エスケープを無効化する仕組みを提供している。
<code>xsl:value-of</code> 要素や <code>xsl:text</code> 要素には、 <code>disable-output-escaping</code> 属性を与えられる。
値は <code>yes</code> または <code>no</code> （既定値）のいずれかであり, <code>yes</code> だった場合、 <code>xsl:value-of</code> 要素や <code>xsl:text</code> 要素のインスタンス化により生成されるテキストノードは, エスケープ処理を施さずに出力すべきである。
例えば：
<span lang="en">
Normally, the xml output method escapes &amp; and &lt; (and possibly other characters) when outputting text nodes.
This ensures that the output is well-formed XML.
However, it is sometimes convenient to be able to produce output that is almost, but not quite well-formed XML; for example, the output may include ill-formed sections which are intended to be transformed into well-formed XML by a subsequent non-XML aware process.
For this reason, XSLT provides a mechanism for disabling output escaping.
An xsl:value-of or xsl:text element may have a disable-output-escaping attribute; the allowed values are yes or no; the default is no; if the value is yes, then a text node generated by instantiating the xsl:value-of or xsl:text element should be output without any escaping.
For example,</span>
      </p>
      <pre>&lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;</pre>
      <p>
は、１個の文字 <code>&lt;</code> を生成する。
<ins class="errata">
ルートノードが <code>xsl:copy-of</code> 要素を用いて複製される際に（
<a href="#copy-of">[<b>11.3 <code >xsl:copy-of</code> における変数とパラメタの値の利用</b>]</a>
を見よ）, ルートノードの子孫のテキストノードに対するエスケープが無効化されている場合、それらのテキストノードの複製結果に対するエスケープも無効化されるべきである。
例えば：
</ins><!-- E2 -->
<span lang="en">
should generate the single character &lt;.
<ins class="errata">
When a root node is copied using an xsl:copy-of element (see [11.3 Using Values of Variables and Parameters with xsl:copy-of]) and escaping was disabled for a text node descendant of that root node, then escaping should also be disabled for the resulting copy of that text node.
For example</ins><!-- E2 -->
</span>
</p>

<pre class="errata"><ins class="errata">
&lt;xsl:variable name="x"&gt;
  &lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;
&lt;/xsl:variable&gt;
&lt;xsl:copy-of select="$x"/&gt;
</ins></pre>

<p class="errata">
<ins class="errata">は <code>&amp;lt;</code> でなく, <code>&lt;</code> と出力されるべきである。
.</ins>
<span lang="en">
<ins class="errata">
should output &lt; not &amp;lt;.
</ins>
</span>
</p>

      <p>
結果ツリーのテキストノード以外の部分に利用されるテキストノードに対する出力エスケープの無効化は、エラーとする。
従って、コメント, 処理命令, 属性ノードの文字列値の生成に利用される <code>xsl:value-of</code> 要素や <code>xsl:text</code> 要素に対する出力エスケープの無効化もエラーとする。
また、エスケープ処理を無効化したテキストノードが含まれている
<a href="#dt-result-tree-fragment">結果ツリー素片</a>
を数値や文字列に変換しようとした場合もエラーとする。
いずれの場合も、 XSLT プロセッサはエラーを通知してもよい。
エラーを通知しない場合、 <code>disable-output-escaping</code> 属性を無視してエラーから回復しなければならない。
<span lang="en">
It is an error for output escaping to be disabled for a text node that is used for something other than a text node in the result tree.
Thus, it is an error to disable output escaping for an xsl:value-of or xsl:text element that is used to generate the string-value of a comment, processing instruction or attribute node; it is also an error to convert a result tree fragment to a number or a string if the result tree fragment contains a text node for which escaping was disabled.
In both cases, an XSLT processor may signal the error; if it does not signal the error, it must recover by ignoring the disable-output-escaping attribute.</span>
      </p>
      <p>
<code>disable-output-escaping</code> 属性は、 <code>xml</code> 出力メソッドのみならず, <code>html</code> 出力メソッドでも利用できる。
テキスト出力メソッドでは、出力のエスケープ処理は行われないので <code>disable-output-escaping</code> 属性は無視される。
<span lang="en">
The disable-output-escaping attribute may be used with the html output method as well as with the xml output method.
The text output method ignores the disable-output-escaping attribute, since it does not perform any output escaping.</span>
      </p>
      <p>
XSLT プロセッサは、結果ツリーの出力を制御する場合にのみ, 出力エスケープを無効にできるが、例外もある。
例えば、結果ツリーは出力以外にも別の XSLT 変換のソースツリーとして利用し得る。
XSLT プロセッサには、出力エスケープの無効化のサポートは要求されていない。
<code>xsl:value-of</code> や <code>xsl:text</code> に出力エスケープを無効化すべきことが指定されていて, XSLT プロセッサがそれをサポートしていない場合、 XSLT プロセッサはエラーを通知してもよい。
エラーを通知しない場合、出力エスケープの無効化を行わないことにより, エラーから回復しなければならない。
<span lang="en">
An XSLT processor will only be able to disable output escaping if it controls how the result tree is output.
This may not always be the case.
For example, the result tree may be used as the source tree for another XSLT transformation instead of being output.
An XSLT processor is not required to support disabling output escaping.
If an xsl:value-of or xsl:text specifies that output escaping should be disabled and the XSLT processor does not support this, the XSLT processor may signal an error; if it does not signal an error, it must recover by not disabling output escaping.</span>
      </p>
      <p>
XSLT プロセッサが出力に利用するエンコーディングで表現できない文字に対し, 出力エスケープが無効化されている場合、 XSLT プロセッサはエラーを通知してもよい。
エラーを通知しない場合、出力エスケープの無効化を行わないことにより, エラーから回復しなければならない。
<span lang="en">
If output escaping is disabled for a character that is not representable in the encoding that the XSLT processor is using for output, then the XSLT processor may signal an error; if it does not signal an error, it must recover by not disabling output escaping.</span>
      </p>
      <p>
出力エスケープの無効化は、すべての XSLT プロセッサで働くとは限らない上に, XML の出力結果は整形式にならない可能性もあるので、この機能は他に選択肢が無い場合に限って利用すべきである。
<span lang="en">
Since disabling output escaping may not work with all XSLT processors and can result in XML that is not well-formed, it should be used only when there is no alternative.</span>
      </p>

</section>
<section>

<h2 id="conformance" title="17 Conformance">17 適合性</h2>
      <p>
適合 XSLT プロセッサは、この仕様の規定に従って, スタイルシートを利用してソースツリーを結果ツリーに変換できなければならない。
適合 XSLT プロセッサには、 XML またはその他の形式による結果の出力機能は要求されていない。
<span lang="en">
A conforming XSLT processor must be able to use a stylesheet to transform a source tree into a result tree as specified in this document.
A conforming XSLT processor need not be able to output the result in XML or in any other form.</span>
      </p>
      <blockquote>
<p>
<b>注記：</b>
XSLT プロセッサのベンダには、結果ツリーを XML として出力可能にしたり, DOM や SAX などの標準 API からの結果ツリーへのアクセスを提供することにより、プロセッサのふるまいの適合性を検証する手段を提供することが強く奨励される。
<span lang="en">
NOTE:Vendors of XSLT processors are strongly encouraged to provide a way to verify that their processor is behaving conformingly by allowing the result tree to be output as XML or by providing access to the result tree through a standard API such as the DOM or SAX.</span>
</p>
      </blockquote>
      <p>
適合 XSLT プロセッサは、この仕様でエラーを通知しなくてよいことを特に指定しているもの以外の, すべてのエラーを通知しなければならない。
適合 XSLT プロセッサは、通知したエラーから回復してもよいが, エラーからの回復は適合性の要件ではない。
<span lang="en">
A conforming XSLT processor must signal any errors except for those that this document specifically allows an XSLT processor not to signal.
A conforming XSLT processor may but need not recover from any errors that it signals.</span>
      </p>
      <p>
適合 XSLT プロセッサは、スタイルシートの処理に消費される処理演算リソースに制限を設けてもよい。
<span lang="en">
A conforming XSLT processor may impose limits on the processing resources consumed by the processing of a stylesheet.</span>
      </p>

</section>
<section>

<h2 id="notation" title="18 Notation">18 表記法</h2>
      <p>
XSLT で定義する要素型それぞれの仕様記述の最初に、その要素型の要素を見本にした構文の要約を与えている。
構文の要約における表記法の意味は、次のようになる：
<span lang="en">
The specification of each XSLT-defined element type is preceded by a summary of its syntax in the form of a model for elements of that element type.
The meaning of syntax summary notation is as follows:</span>
      </p>
      <ul>
         <li>
            <p>
必ず指定しなければならない属性は太字で表記。
<span lang="en">
An attribute is required if and only if its name is in bold.</span>
            </p>
         </li>
         <li>
            <p>
属性値のあたる部分の文字列は、その属性で利用できる値を指定する。
この文字列が波括弧で括られている場合、属性値は
<a href="#dt-attribute-value-template">属性値テンプレート</a>
として扱われ, 波括弧内部の文字列は、属性値テンプレートのインスタンス化の結果として許容される値を指定する。
値として複数の選択肢が許容される所は <code>|</code> で区切られる。
引用符で括られた文字列は、その文字列そのものが値になることを示す。
引用符で囲まれていない斜体の名前は、特定の型の値を指す。
<span lang="en">
The string that occurs in the place of an attribute value specifies the allowed values of the attribute.
If this is surrounded by curly braces, then the attribute value is treated as an attribute value template, and the string occurring within curly braces specifies the allowed values of the result of instantiating the attribute value template.
Alternative allowed values are separated by |.
A quoted string indicates a value equal to that specific string.
An unquoted, italicized name specifies a particular type of value.</span>
            </p>
         </li>
         <li>
            <p>
空要素でなくてもよい要素の場合、許容される内容を指定するコメントが要素内に記述される。
許容される内容は、 XML の要素型宣言と同様の形式で指定される。
<i>template</i> は、テキストノード, リテラル結果要素, 拡張要素, <code>instruction</code> に分類される XSLT 要素を任意に組み合わせて利用できることを意味する。
<i>top-level-elements</i> は、 <code>top-level-element</code> に分類される XSLT 要素を任意に組み合わせて利用できることを意味する。
<span lang="en">
If the element is allowed not to be empty, then the element contains a comment specifying the allowed content.
The allowed content is specified in a similar way to an element type declaration in XML; template means that any mixture of text nodes, literal result elements, extension elements, and XSLT elements from the instruction category is allowed; top-level-elements means that any mixture of XSLT elements from the top-level-element category is allowed.</span>
            </p>
         </li>
         <li>
            <p>
要素の最初に、その要素がどの分類に属するかが示される： <code>instruction</code> か, <code>top-level-element</code> か, またはその両方か。
この分類は、単にその要素が <i>template</i> または <i>top-level-elements</i> を内容に許容する要素の内容として許容されるかどうかを表すためのものである。

<span lang="en">
The element is prefaced by comments indicating if it belongs to the instruction category or top-level-element category or both.
The category of an element just affects whether it is allowed in the content of elements that allow a template or top-level-elements.</span>
            </p>
         </li>
      </ul>

</section>

<hr title="Separator from footer"/>

<section>

<h2 id="section-References" title="A References">A 参照文献</h2>

<h3 id="section-Normative-References" title="A.1 Normative References">A.1 正式な参照文献</h3>

<div lang="en">
      <dl>
         <dt>
            <a id="XML">XML</a>
         </dt>
         <dd>World Wide Web Consortium. <i>Extensible Markup Language (XML)
      1.0.</i> W3C Recommendation. See <a href="http://www.w3.org/TR/1998/REC-xml-19980210">http://www.w3.org/TR/1998/REC-xml-19980210</a>
         </dd>

         <dt class="errata"><!-- E35 -->
            <a id="XML11"><ins class="errata">XML11</ins></a>
         </dt>
         <dd>World Wide Web Consortium. <i>Extensible Markup Language (XML) 1.1.
      1.0.</i> W3C Recommendation. See <a href="http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</a>
         </dd>

         <dt>
            <a id="XMLNAMES">XML Names</a>
         </dt>
         <dd>World Wide Web Consortium. <i>Namespaces in XML.</i> W3C
      Recommendation. See <a href="http://www.w3.org/TR/REC-xml-names">http://www.w3.org/TR/REC-xml-names</a>
         </dd>

         <dt class="errata"><!-- E35 -->
            <a id="XMLNames11"><ins class="errata">XML Names 1.1</ins></a>
         </dt>
         <dd>World Wide Web Consortium. <i>Namespaces in XML 1.1.</i> W3C
      Recommendation. See <a href="http://www.w3.org/TR/xml-names11/">http://www.w3.org/TR/xml-names11/</a>
         </dd>


         <dt>
            <a id="XPATH">XPath</a>
         </dt>
         <dd>World Wide Web Consortium. <i>XML Path Language.</i> W3C
      Recommendation. See <a href="http://www.w3.org/TR/xpath">http://www.w3.org/TR/xpath</a>
         </dd>
      </dl>

</div>

<h3 id="section-Other-References" title="A.2 Other References">A.2 その他の参照文献</h3>
<div lang="en">
      <dl>
         <dt>
            <a id="CSS2">CSS2</a>
         </dt>
         <dd>World Wide Web Consortium.  <i>Cascading Style Sheets, level 2
      (CSS2)</i>.  W3C Recommendation.  See <a href="http://www.w3.org/TR/1998/REC-CSS2-19980512">http://www.w3.org/TR/1998/REC-CSS2-19980512</a>
         </dd>
         <dt>
            <a id="DSSSL">DSSSL</a>
         </dt>
         <dd>International Organization for Standardization, International
      Electrotechnical Commission. <i>ISO/IEC 10179:1996.  Document Style
      Semantics and Specification Language (DSSSL)</i>.  International
      Standard.</dd>
         <dt>
            <a id="HTML">HTML</a>
         </dt>
         <dd>World Wide Web Consortium. <i>HTML 4.0 specification</i>. W3C
      Recommendation. See <a href="http://www.w3.org/TR/REC-html40">http://www.w3.org/TR/REC-html40</a>
         </dd>
         <dt>
            <a id="IANA">IANA</a>
         </dt>
         <dd>Internet Assigned Numbers Authority. <i>Character Sets</i>. See <a href="ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets">ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets</a>.</dd>
         <dt>
            <a id="RFC2278">RFC2278</a>
         </dt>
         <dd>N. Freed, J. Postel.  <i>IANA Charset Registration Procedures</i>. 
      IETF RFC 2278. See <a href="http://www.ietf.org/rfc/rfc2278.txt">http://www.ietf.org/rfc/rfc2278.txt</a>.</dd>
         <dt>
            <a id="RFC2376">RFC2376</a>
         </dt>
         <dd>E. Whitehead, M. Murata.  <i>XML Media Types</i>. IETF RFC 2376. See
      <a href="http://www.ietf.org/rfc/rfc2376.txt">http://www.ietf.org/rfc/rfc2376.txt</a>.</dd>
         <dt>
            <a id="RFC2396">RFC2396</a>
         </dt>
         <dd>T. Berners-Lee, R. Fielding, and L. Masinter.  <i>Uniform Resource
      Identifiers (URI): Generic Syntax</i>. IETF RFC 2396. See <a href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a>.</dd>
         <dt>
            <a id="UNICODE-TR10">UNICODE TR10</a>
         </dt>
         <dd>Unicode Consortium. <i>Unicode Technical Report #10. Unicode
      Collation Algorithm</i>.  Unicode Technical Report.  See <a href="http://www.unicode.org/unicode/reports/tr10/index.html">http://www.unicode.org/unicode/reports/tr10/index.html</a>.</dd>
         <dt>
            <a id="XHTML">XHTML</a>
         </dt>
         <dd>World Wide Web Consortium. <i>XHTML 1.0: The Extensible HyperText
      Markup Language.</i> W3C Proposed Recommendation. See <a href="http://www.w3.org/TR/xhtml1">http://www.w3.org/TR/xhtml1</a>
         </dd>
         <dt>
            <a id="XPTR">XPointer</a>
         </dt>
         <dd>World Wide Web Consortium. <i>XML Pointer Language (XPointer).</i>
      W3C Working Draft. See <a href="http://www.w3.org/TR/xptr">http://www.w3.org/TR/xptr</a>
         </dd>
         <dt>
            <a id="XMLSTYLE">XML Stylesheet</a>
         </dt>
         <dd>World Wide Web Consortium. <i>Associating stylesheets with XML
      documents.</i> W3C Recommendation. See <a href="http://www.w3.org/TR/xml-stylesheet">http://www.w3.org/TR/xml-stylesheet</a>
         </dd>
         <dt>
            <a id="XSL">XSL</a>
         </dt>
         <dd>World Wide Web Consortium.  <i>Extensible Stylesheet Language
      (XSL).</i>  W3C Working Draft.  See <a href="http://www.w3.org/TR/WD-xsl">http://www.w3.org/TR/WD-xsl</a>
         </dd>
      </dl>
</div>

</section>
<section>

<h2 id="element-syntax-summary" title="B Element Syntax Summary">B 要素構文要約</h2>

      <pre class="element-syntax-summary">
&lt;!-- Category: instruction --&gt;
&lt;<a href="#element-apply-imports">xsl:apply-imports</a> /&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: instruction --&gt;
&lt;<a href="#element-apply-templates">xsl:apply-templates</a> 
  select = <var>node-set-expression</var> 
  mode = <var>qname</var>&gt;
  &lt;!-- Content: (<a href="#element-sort">xsl:sort</a> | <a href="#element-with-param">xsl:with-param</a>)* --&gt;
&lt;/xsl:apply-templates&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: instruction --&gt;
&lt;<a href="#element-attribute">xsl:attribute</a>
  <b>name</b> = { <var>qname</var> }
  namespace = { <var>uri-reference</var> }&gt;
  &lt;!-- Content: <var>template</var> --&gt;
&lt;/xsl:attribute&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: top-level-element --&gt;
&lt;<a href="#element-attribute-set">xsl:attribute-set</a>
  <b>name</b> = <var>qname</var> 
  use-attribute-sets = <var>qnames</var>&gt;
  &lt;!-- Content: <a href="#element-attribute">xsl:attribute</a>* --&gt;
&lt;/xsl:attribute-set&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: instruction --&gt;
&lt;<a href="#element-call-template">xsl:call-template</a>
  <b>name</b> = <var>qname</var>&gt;
  &lt;!-- Content: <a href="#element-with-param">xsl:with-param</a>* --&gt;
&lt;/xsl:call-template&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: instruction --&gt;
&lt;<a href="#element-choose">xsl:choose</a>&gt;
  &lt;!-- Content: (<a href="#element-when">xsl:when</a>+, <a href="#element-otherwise">xsl:otherwise</a>?) --&gt;
&lt;/xsl:choose&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: instruction --&gt;
&lt;<a href="#element-comment">xsl:comment</a>&gt;
  &lt;!-- Content: <var>template</var> --&gt;
&lt;/xsl:comment&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: instruction --&gt;
&lt;<a href="#element-copy">xsl:copy</a> 
  use-attribute-sets = <var>qnames</var>&gt;
  &lt;!-- Content: <var>template</var> --&gt;
&lt;/xsl:copy&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: instruction --&gt;
&lt;<a href="#element-copy-of">xsl:copy-of</a>
  <b>select</b> = <var>expression</var> /&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: top-level-element --&gt;
&lt;<a href="#element-decimal-format">xsl:decimal-format</a> 
  name = <var>qname</var> 
  decimal-separator = <var>char</var> 
  grouping-separator = <var>char</var> 
  infinity = <var>string</var> 
  minus-sign = <var>char</var> 
  NaN = <var>string</var> 
  percent = <var>char</var> 
  per-mille = <var>char</var> 
  zero-digit = <var>char</var> 
  digit = <var>char</var> 
  pattern-separator = <var>char</var> /&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: instruction --&gt;
&lt;<a href="#element-element">xsl:element</a>
  <b>name</b> = { <var>qname</var> }
  namespace = { <var>uri-reference</var> }
  use-attribute-sets = <var>qnames</var>&gt;
  &lt;!-- Content: <var>template</var> --&gt;
&lt;/xsl:element&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: instruction --&gt;
&lt;<a href="#element-fallback">xsl:fallback</a>&gt;
  &lt;!-- Content: <var>template</var> --&gt;
&lt;/xsl:fallback&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: instruction --&gt;
&lt;<a href="#element-for-each">xsl:for-each</a>
         <b>select</b> = <var>node-set-expression</var>&gt;
  &lt;!-- Content: (<a href="#element-sort">xsl:sort</a>*, <var>template</var>) --&gt;
&lt;/xsl:for-each&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: instruction --&gt;
&lt;<a href="#element-if">xsl:if</a>
         <b>test</b> = <var>boolean-expression</var>&gt;
  &lt;!-- Content: <var>template</var> --&gt;
&lt;/xsl:if&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;<a href="#element-import">xsl:import</a>
         <b>href</b> = <var>uri-reference</var> /&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: top-level-element --&gt;
&lt;<a href="#element-include">xsl:include</a>
         <b>href</b> = <var>uri-reference</var> /&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: top-level-element --&gt;
&lt;<a href="#element-key">xsl:key</a>
  <b>name</b> = <var>qname</var>
         <b>match</b> = <var>pattern</var>
         <b>use</b> = <var>expression</var> /&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: instruction --&gt;
&lt;<a href="#element-message">xsl:message</a> 
  terminate = "yes" | "no"&gt;
  &lt;!-- Content: <var>template</var> --&gt;
&lt;/xsl:message&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: top-level-element --&gt;
&lt;<a href="#element-namespace-alias">xsl:namespace-alias</a>
         <b>stylesheet-prefix</b> = <var>prefix</var> | "#default"
  <b>result-prefix</b> = <var>prefix</var> | "#default" /&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: instruction --&gt;
&lt;<a href="#element-number">xsl:number</a> 
  level = "single" | "multiple" | "any"
  count = <var>pattern</var> 
  from = <var>pattern</var> 
  value = <var>number-expression</var> 
  format = { <var>string</var> }
  lang = { <var>nmtoken</var> }
  letter-value = { "alphabetic" | "traditional" }
  grouping-separator = { <var>char</var> }
  grouping-size = { <var>number</var> } /&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;<a href="#element-otherwise">xsl:otherwise</a>&gt;
  &lt;!-- Content: <var>template</var> --&gt;
&lt;/xsl:otherwise&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: top-level-element --&gt;
&lt;<a href="#element-output">xsl:output</a> 
  method = "xml" | "html" | "text" | <var>qname-but-not-ncname</var> 
  version = <var>nmtoken</var> 
  encoding = <var>string</var> 
  omit-xml-declaration = "yes" | "no"
  standalone = "yes" | "no"
  doctype-public = <var>string</var> 
  doctype-system = <var>string</var> 
  cdata-section-elements = <var>qnames</var> 
  indent = "yes" | "no"
  media-type = <var>string</var> /&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: top-level-element --&gt;
&lt;<a href="#element-param">xsl:param</a>
  <b>name</b> = <var>qname</var> 
  select = <var>expression</var>&gt;
  &lt;!-- Content: <var>template</var> --&gt;
&lt;/xsl:param&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: top-level-element --&gt;
&lt;<a href="#element-preserve-space">xsl:preserve-space</a>
         <b>elements</b> = <var>tokens</var> /&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: instruction --&gt;
&lt;<a href="#element-processing-instruction">xsl:processing-instruction</a>
  <b>name</b> = { <var>ncname</var> }&gt;
  &lt;!-- Content: <var>template</var> --&gt;
&lt;/xsl:processing-instruction&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;<a href="#element-sort">xsl:sort</a> 
  select = <var>string-expression</var> 
  lang = { <var>nmtoken</var> }
  data-type = { "text" | "number" | <var>qname-but-not-ncname</var> }
  order = { "ascending" | "descending" }
  case-order = { "upper-first" | "lower-first" } /&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: top-level-element --&gt;
&lt;<a href="#element-strip-space">xsl:strip-space</a>
         <b>elements</b> = <var>tokens</var> /&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;<a href="#element-stylesheet">xsl:stylesheet</a> 
  id = <var>id</var> 
  extension-element-prefixes = <var>tokens</var> 
  exclude-result-prefixes = <var>tokens</var>
         <b>version</b> = <var>number</var>&gt;
  &lt;!-- Content: (<a href="#element-import">xsl:import</a>*, <var>top-level-elements</var>) --&gt;
&lt;/xsl:stylesheet&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: top-level-element --&gt;
&lt;<a href="#element-template">xsl:template</a> 
  match = <var>pattern</var> 
  name = <var>qname</var> 
  priority = <var>number</var> 
  mode = <var>qname</var>&gt;
  &lt;!-- Content: (<a href="#element-param">xsl:param</a>*, <var>template</var>) --&gt;
&lt;/xsl:template&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: instruction --&gt;
&lt;<a href="#element-text">xsl:text</a> 
  disable-output-escaping = "yes" | "no"&gt;
  &lt;!-- Content: #PCDATA --&gt;
&lt;/xsl:text&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;<a href="#element-transform">xsl:transform</a> 
  id = <var>id</var> 
  extension-element-prefixes = <var>tokens</var> 
  exclude-result-prefixes = <var>tokens</var>
         <b>version</b> = <var>number</var>&gt;
  &lt;!-- Content: (<a href="#element-import">xsl:import</a>*, <var>top-level-elements</var>) --&gt;
&lt;/xsl:transform&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: instruction --&gt;
&lt;<a href="#element-value-of">xsl:value-of</a>
         <b>select</b> = <var>string-expression</var> 
  disable-output-escaping = "yes" | "no" /&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;!-- Category: top-level-element --&gt;
&lt;!-- Category: instruction --&gt;
&lt;<a href="#element-variable">xsl:variable</a>
  <b>name</b> = <var>qname</var> 
  select = <var>expression</var>&gt;
  &lt;!-- Content: <var>template</var> --&gt;
&lt;/xsl:variable&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;<a href="#element-when">xsl:when</a>
         <b>test</b> = <var>boolean-expression</var>&gt;
  &lt;!-- Content: <var>template</var> --&gt;
&lt;/xsl:when&gt;
</pre>
      <pre class="element-syntax-summary">
&lt;<a href="#element-with-param">xsl:with-param</a>
  <b>name</b> = <var>qname</var> 
  select = <var>expression</var>&gt;
  &lt;!-- Content: <var>template</var> --&gt;
&lt;/xsl:with-param&gt;
</pre>

</section>
<section>

<h2 id="dtd" title="C DTD Fragment for XSLT Stylesheets (Non-Normative)">C XSLT スタイルシート用 DTD 素片（規定外）</h2>
      <blockquote>
<p>
<b>注記：</b>
この DTD 素片は、正式ではない。
理由は、 XML 1.0 の DTD は XML 名前空間をサポートしていないため, XSLT スタイルシートが許容する構造を正しく記述できないためである。
<span lang="en">
NOTE:This DTD Fragment is not normative because XML 1.0 DTDs do not support XML Namespaces and thus cannot correctly describe the allowed structure of an XSLT stylesheet.</span>
</p>
      </blockquote>
      <p>
下の実体を、特定の結果 DTD のインスタンスを生成する XSLT スタイルシート用の DTD の構築に利用できる。
この実体が参照される前に、スタイルシート用の DTD に結果において許容される要素を列挙する <code>result-elements</code> パラメタ実体が定義されなければならない。
例えば：
<span lang="en">
The following entity can be used to construct a DTD for XSLT stylesheets that create instances of a particular result DTD. Before referencing the entity, the stylesheet DTD must define a result-elements parameter entity listing the allowed result element types. For example:</span>
      </p>
      <pre>&lt;!ENTITY % result-elements "
  | fo:inline-sequence
  | fo:block
"&gt;</pre>
      <p>
このような結果要素は、属性として <code>xsl:use-attribute-sets</code> と <code>xsl:extension-element-prefixes</code> を持つことを宣言しておくべきである。
下の実体で、この目的に <code>result-element-atts</code> パラメタを宣言する。
XSLT が結果要素に許容する内容は、次の実体の中で内容モデル <code>%template;</code> を伴って宣言される XSLT の要素に対し許容される内容と同じである。
DTD では、結果 DTD にかけられる制約を反映させるため, <code>%template;</code> より制限が強い内容モデルを利用してもよい。
<span lang="en">
Such result elements should be declared to have xsl:use-attribute-sets and xsl:extension-element-prefixes attributes.
The following entity declares the result-element-atts parameter for this purpose.
The content that XSLT allows for result elements is the same as it allows for the XSLT elements that are declared in the following entity with a content model of %template;. 
The DTD may use a more restrictive content model than %template; to reflect the constraints of the result DTD.</span>
      </p>
      <p>
この DTD では、 XSLT 名前空間以外の名前空間から追加のトップレベル要素を許容するために <code>non-xsl-top-level</code> パラメタ実体を定義してもよい。
<span lang="en">
The DTD may define the non-xsl-top-level parameter entity to allow additional top-level elements from namespaces other than the XSLT namespace.</span>
      </p>
      <p>
この DTD は接頭辞 <code>xsl:</code> を利用しているが、 XSLT のスタイルシートでもこの接頭辞の利用が要求されるわけではない。

この DTD で宣言しているすべての要素は、この DTD で宣言される属性に加え, <code>xmlns:</code> から始まる名前の属性や名前が <code>xmlns</code> の属性を持ち得る。
<span lang="en">
The use of the xsl: prefix in this DTD does not imply that XSLT stylesheets are required to use this prefix.
Any of the elements declared in this DTD may have attributes whose name starts with xmlns: or is equal to xmlns in addition to the attributes declared in this DTD.</span>
      </p>
      <pre>&lt;!ENTITY % char-instructions "
  | xsl:apply-templates
  | xsl:call-template
  | xsl:apply-imports
  | xsl:for-each
  | xsl:value-of
  | xsl:copy-of
  | xsl:number
  | xsl:choose
  | xsl:if
  | xsl:text
  | xsl:copy
  | xsl:variable
  | xsl:message
  | xsl:fallback
"&gt;

&lt;!ENTITY % instructions "
  %char-instructions;
  | xsl:processing-instruction
  | xsl:comment
  | xsl:element
  | xsl:attribute
"&gt;

&lt;!ENTITY % char-template "
 (#PCDATA
  %char-instructions;)*
"&gt;

&lt;!ENTITY % template "
 (#PCDATA
  %instructions;
  %result-elements;)*
"&gt;

&lt;!-- Used for the type of an attribute value that is a URI reference.--&gt;
&lt;!ENTITY % URI "CDATA"&gt;

&lt;!-- Used for the type of an attribute value that is a pattern.--&gt;
&lt;!ENTITY % pattern "CDATA"&gt;

&lt;!-- Used for the type of an attribute value that is an
     attribute value template.--&gt;
&lt;!ENTITY % avt "CDATA"&gt;

&lt;!-- Used for the type of an attribute value that is a QName; the prefix
     gets expanded by the XSLT processor. --&gt;
&lt;!ENTITY % qname "NMTOKEN"&gt;

&lt;!-- Like qname but a whitespace-separated list of QNames. --&gt;
&lt;!ENTITY % qnames "NMTOKENS"&gt;

&lt;!-- Used for the type of an attribute value that is an expression.--&gt;
&lt;!ENTITY % expr "CDATA"&gt;

&lt;!-- Used for the type of an attribute value that consists
     of a single character.--&gt;
&lt;!ENTITY % char "CDATA"&gt;

&lt;!-- Used for the type of an attribute value that is a priority. --&gt;
&lt;!ENTITY % priority "NMTOKEN"&gt;

&lt;!ENTITY % space-att "xml:space (default|preserve) #IMPLIED"&gt;

&lt;!-- This may be overridden to customize the set of elements allowed
at the top-level. --&gt;

&lt;!ENTITY % non-xsl-top-level ""&gt;

&lt;!ENTITY % top-level "
 (xsl:import*,
  (xsl:include
  | xsl:strip-space
  | xsl:preserve-space
  | xsl:output
  | xsl:key
  | xsl:decimal-format
  | xsl:attribute-set
  | xsl:variable
  | xsl:param
  | xsl:template
  | xsl:namespace-alias
  %non-xsl-top-level;)*)
"&gt;

&lt;!ENTITY % top-level-atts '
  extension-element-prefixes CDATA #IMPLIED
  exclude-result-prefixes CDATA #IMPLIED
  id ID #IMPLIED
  version NMTOKEN #REQUIRED
  xmlns:xsl CDATA #FIXED "http://www.w3.org/1999/XSL/Transform"
  %space-att;
'&gt;

&lt;!-- This entity is defined for use in the ATTLIST declaration
for result elements. --&gt;

&lt;!ENTITY % result-element-atts '
  xsl:extension-element-prefixes CDATA #IMPLIED
  xsl:exclude-result-prefixes CDATA #IMPLIED
  xsl:use-attribute-sets %qnames; #IMPLIED
  xsl:version NMTOKEN #IMPLIED
'&gt;

&lt;!ELEMENT xsl:stylesheet %top-level;&gt;
&lt;!ATTLIST xsl:stylesheet %top-level-atts;&gt;

&lt;!ELEMENT xsl:transform %top-level;&gt;
&lt;!ATTLIST xsl:transform %top-level-atts;&gt;

&lt;!ELEMENT xsl:import EMPTY&gt;
&lt;!ATTLIST xsl:import href %URI; #REQUIRED&gt;

&lt;!ELEMENT xsl:include EMPTY&gt;
&lt;!ATTLIST xsl:include href %URI; #REQUIRED&gt;

&lt;!ELEMENT xsl:strip-space EMPTY&gt;
&lt;!ATTLIST xsl:strip-space elements CDATA #REQUIRED&gt;

&lt;!ELEMENT xsl:preserve-space EMPTY&gt;
&lt;!ATTLIST xsl:preserve-space elements CDATA #REQUIRED&gt;

&lt;!ELEMENT xsl:output EMPTY&gt;
&lt;!ATTLIST xsl:output
  method %qname; #IMPLIED
  version NMTOKEN #IMPLIED
  encoding CDATA #IMPLIED
  omit-xml-declaration (yes|no) #IMPLIED
  standalone (yes|no) #IMPLIED
  doctype-public CDATA #IMPLIED
  doctype-system CDATA #IMPLIED
  cdata-section-elements %qnames; #IMPLIED
  indent (yes|no) #IMPLIED
  media-type CDATA #IMPLIED
&gt;

&lt;!ELEMENT xsl:key EMPTY&gt;
&lt;!ATTLIST xsl:key
  name %qname; #REQUIRED
  match %pattern; #REQUIRED
  use %expr; #REQUIRED
&gt;

&lt;!ELEMENT xsl:decimal-format EMPTY&gt;
&lt;!ATTLIST xsl:decimal-format
  name %qname; #IMPLIED
  decimal-separator %char; "."
  grouping-separator %char; ","
  infinity CDATA "Infinity"
  minus-sign %char; "-"
  NaN CDATA "NaN"
  percent %char; "%"
  per-mille %char; "&amp;#x2030;"
  zero-digit %char; "0"
  digit %char; "#"
  pattern-separator %char; ";"
&gt;

&lt;!ELEMENT xsl:namespace-alias EMPTY&gt;
&lt;!ATTLIST xsl:namespace-alias
  stylesheet-prefix CDATA #REQUIRED
  result-prefix CDATA #REQUIRED
&gt;

&lt;!ELEMENT xsl:template
 (#PCDATA
  %instructions;
  %result-elements;
  | xsl:param)*
&gt;

&lt;!ATTLIST xsl:template
  match %pattern; #IMPLIED
  name %qname; #IMPLIED
  priority %priority; #IMPLIED
  mode %qname; #IMPLIED
  %space-att;
&gt;

&lt;!ELEMENT xsl:value-of EMPTY&gt;
&lt;!ATTLIST xsl:value-of
  select %expr; #REQUIRED
  disable-output-escaping (yes|no) "no"
&gt;

&lt;!ELEMENT xsl:copy-of EMPTY&gt;
&lt;!ATTLIST xsl:copy-of select %expr; #REQUIRED&gt;

&lt;!ELEMENT xsl:number EMPTY&gt;
&lt;!ATTLIST xsl:number
   level (single|multiple|any) "single"
   count %pattern; #IMPLIED
   from %pattern; #IMPLIED
   value %expr; #IMPLIED
   format %avt; '1'
   lang %avt; #IMPLIED
   letter-value %avt; #IMPLIED
   grouping-separator %avt; #IMPLIED
   grouping-size %avt; #IMPLIED
&gt;

&lt;!ELEMENT xsl:apply-templates (xsl:sort|xsl:with-param)*&gt;
&lt;!ATTLIST xsl:apply-templates
  select %expr; "node()"
  mode %qname; #IMPLIED
&gt;

&lt;!ELEMENT xsl:apply-imports EMPTY&gt;

&lt;!-- xsl:sort cannot occur after any other elements or
any non-whitespace character --&gt;

&lt;!ELEMENT xsl:for-each
 (#PCDATA
  %instructions;
  %result-elements;
  | xsl:sort)*
&gt;

&lt;!ATTLIST xsl:for-each
  select %expr; #REQUIRED
  %space-att;
&gt;

&lt;!ELEMENT xsl:sort EMPTY&gt;
&lt;!ATTLIST xsl:sort
  select %expr; "."
  lang %avt; #IMPLIED
  data-type %avt; "text"
  order %avt; "ascending"
  case-order %avt; #IMPLIED
&gt;

&lt;!ELEMENT xsl:if %template;&gt;
&lt;!ATTLIST xsl:if
  test %expr; #REQUIRED
  %space-att;
&gt;

&lt;!ELEMENT xsl:choose (xsl:when+, xsl:otherwise?)&gt;
&lt;!ATTLIST xsl:choose %space-att;&gt;

&lt;!ELEMENT xsl:when %template;&gt;
&lt;!ATTLIST xsl:when
  test %expr; #REQUIRED
  %space-att;
&gt;

&lt;!ELEMENT xsl:otherwise %template;&gt;
&lt;!ATTLIST xsl:otherwise %space-att;&gt;

&lt;!ELEMENT xsl:attribute-set (xsl:attribute)*&gt;
&lt;!ATTLIST xsl:attribute-set
  name %qname; #REQUIRED
  use-attribute-sets %qnames; #IMPLIED
&gt;

&lt;!ELEMENT xsl:call-template (xsl:with-param)*&gt;
&lt;!ATTLIST xsl:call-template
  name %qname; #REQUIRED
&gt;

&lt;!ELEMENT xsl:with-param %template;&gt;
&lt;!ATTLIST xsl:with-param
  name %qname; #REQUIRED
  select %expr; #IMPLIED
&gt;

&lt;!ELEMENT xsl:variable %template;&gt;
&lt;!ATTLIST xsl:variable 
  name %qname; #REQUIRED
  select %expr; #IMPLIED
&gt;

&lt;!ELEMENT xsl:param %template;&gt;
&lt;!ATTLIST xsl:param 
  name %qname; #REQUIRED
  select %expr; #IMPLIED
&gt;

&lt;!ELEMENT xsl:text (#PCDATA)&gt;
&lt;!ATTLIST xsl:text
  disable-output-escaping (yes|no) "no"
&gt;

&lt;!ELEMENT xsl:processing-instruction %char-template;&gt;
&lt;!ATTLIST xsl:processing-instruction 
  name %avt; #REQUIRED
  %space-att;
&gt;

&lt;!ELEMENT xsl:element %template;&gt;
&lt;!ATTLIST xsl:element 
  name %avt; #REQUIRED
  namespace %avt; #IMPLIED
  use-attribute-sets %qnames; #IMPLIED
  %space-att;
&gt;

&lt;!ELEMENT xsl:attribute %char-template;&gt;
&lt;!ATTLIST xsl:attribute 
  name %avt; #REQUIRED
  namespace %avt; #IMPLIED
  %space-att;
&gt;

&lt;!ELEMENT xsl:comment %char-template;&gt;
&lt;!ATTLIST xsl:comment %space-att;&gt;

&lt;!ELEMENT xsl:copy %template;&gt;
&lt;!ATTLIST xsl:copy
  %space-att;
  use-attribute-sets %qnames; #IMPLIED
&gt;

&lt;!ELEMENT xsl:message %template;&gt;
&lt;!ATTLIST xsl:message
  %space-att;
  terminate (yes|no) "no"
&gt;

&lt;!ELEMENT xsl:fallback %template;&gt;
&lt;!ATTLIST xsl:fallback %space-att;&gt;</pre>

</section>
<section>

<h2 id="section-Examples" title="D Examples (Non-Normative)">D 例（規定外）</h2>

<h3 id="section-Document-Example" title="D.1 Document Example">D.1 文書例</h3>
      <p>
この例は単純な DTD に適合する文書を XHTML 
<a href="#XHTML">[XHTML]</a>
へ変換するスタイルシートである。
DTD は：
<span lang="en">
This example is a stylesheet for transforming documents that conform to a simple DTD into XHTML [XHTML]. The DTD is:</span>
      </p>
      <pre>&lt;!ELEMENT doc (title, chapter*)&gt;
&lt;!ELEMENT chapter (title, (para|note)*, section*)&gt;
&lt;!ELEMENT section (title, (para|note)*)&gt;
&lt;!ELEMENT title (#PCDATA|emph)*&gt;
&lt;!ELEMENT para (#PCDATA|emph)*&gt;
&lt;!ELEMENT note (#PCDATA|emph)*&gt;
&lt;!ELEMENT emph (#PCDATA|emph)*&gt;</pre>
      <p>
スタイルシートは：
<span lang="en">
The stylesheet is:</span>
      </p>
      <pre>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/TR/xhtml1/strict"&gt;

&lt;xsl:strip-space elements="doc chapter section"/&gt;
&lt;xsl:output
   method="xml"
   indent="yes"
   encoding="iso-8859-1"
/&gt;

&lt;xsl:template match="doc"&gt;
 &lt;html&gt;
   &lt;head&gt;
     &lt;title&gt;
       &lt;xsl:value-of select="title"/&gt;
     &lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
     &lt;xsl:apply-templates/&gt;
   &lt;/body&gt;
 &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="doc/title"&gt;
  &lt;h1&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/h1&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="chapter/title"&gt;
  &lt;h2&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/h2&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="section/title"&gt;
  &lt;h3&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/h3&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="para"&gt;
  &lt;p&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="note"&gt;
  &lt;p class="note"&gt;
    &lt;b&gt;NOTE: &lt;/b&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="emph"&gt;
  &lt;em&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/em&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
      <p>
次の入力の文書：
<span lang="en">
With the following input document</span>
      </p>
      <pre>&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
&lt;title&gt;Document Title&lt;/title&gt;
&lt;chapter&gt;
&lt;title&gt;Chapter Title&lt;/title&gt;
&lt;section&gt;
&lt;title&gt;Section Title&lt;/title&gt;
&lt;para&gt;This is a test.&lt;/para&gt;
&lt;note&gt;This is a note.&lt;/note&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;title&gt;Another Section Title&lt;/title&gt;
&lt;para&gt;This is &lt;emph&gt;another&lt;/emph&gt; test.&lt;/para&gt;
&lt;note&gt;This is another note.&lt;/note&gt;
&lt;/section&gt;
&lt;/chapter&gt;
&lt;/doc&gt;</pre>
      <p>
から、次の結果が生成される：
<span lang="en">
it would produce the following result</span>
      </p>
      <pre>&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;html xmlns="http://www.w3.org/TR/xhtml1/strict"&gt;
&lt;head&gt;
&lt;title&gt;Document Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Document Title&lt;/h1&gt;
&lt;h2&gt;Chapter Title&lt;/h2&gt;
&lt;h3&gt;Section Title&lt;/h3&gt;
&lt;p&gt;This is a test.&lt;/p&gt;
&lt;p class="note"&gt;
&lt;b&gt;NOTE: &lt;/b&gt;This is a note.&lt;/p&gt;
&lt;h3&gt;Another Section Title&lt;/h3&gt;
&lt;p&gt;This is &lt;em&gt;another&lt;/em&gt; test.&lt;/p&gt;
&lt;p class="note"&gt;
&lt;b&gt;NOTE: &lt;/b&gt;This is another note.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

	</section>
	<section>

<h3 id="data-example" title="D.2 Data Example">D.2 データ例</h3>
      <p>
この節では XML で表現されているデータを異なる３つの XSLT スタイルシートを用いて変換し、異なる３つのデータ表現 HTML, SVG, VRML を生成する例を示す。
<span lang="en">
This is an example of transforming some data represented in XML using three different XSLT stylesheets to produce three different representations of the data, HTML, SVG and VRML.</span>
      </p>
      <p>
入力データは：
<span lang="en">
The input data is:</span>
      </p>
      <pre>&lt;sales&gt;

        &lt;division id="North"&gt;
                &lt;revenue&gt;10&lt;/revenue&gt;
                &lt;growth&gt;9&lt;/growth&gt;
                &lt;bonus&gt;7&lt;/bonus&gt;
        &lt;/division&gt;

        &lt;division id="South"&gt;
                &lt;revenue&gt;4&lt;/revenue&gt;
                &lt;growth&gt;3&lt;/growth&gt;
                &lt;bonus&gt;4&lt;/bonus&gt;
        &lt;/division&gt;

        &lt;division id="West"&gt;
                &lt;revenue&gt;6&lt;/revenue&gt;
                &lt;growth&gt;-1.5&lt;/growth&gt;
                &lt;bonus&gt;2&lt;/bonus&gt;
        &lt;/division&gt;

&lt;/sales&gt;</pre>
      <p>
次のスタイルシートは
<a href="#result-element-stylesheet">[<b>2.3 スタイルシートとしてのリテラル結果要素</b>]</a>
で述べられた簡略構文を用いてデータを HTML に変換する：
<span lang="en">
The following stylesheet, which uses the simplified syntax described in [2.3 Literal Result Element as Stylesheet], transforms the data into HTML:</span>
      </p>
      <pre>&lt;html xsl:version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      lang="en"&gt;
    &lt;head&gt;
        &lt;title&gt;Sales Results By Division&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;table border="1"&gt;
            &lt;tr&gt;
                &lt;th&gt;Division&lt;/th&gt;
                &lt;th&gt;Revenue&lt;/th&gt;
                &lt;th&gt;Growth&lt;/th&gt;
                &lt;th&gt;Bonus&lt;/th&gt;
            &lt;/tr&gt;
            &lt;xsl:for-each select="sales/division"&gt;
                &lt;!-- order the result by revenue --&gt;
                &lt;xsl:sort select="revenue"
                          data-type="number"
                          order="descending"/&gt;
                &lt;tr&gt;
                    &lt;td&gt;
                        &lt;em&gt;&lt;xsl:value-of select="@id"/&gt;&lt;/em&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;xsl:value-of select="revenue"/&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;!-- highlight negative growth in red --&gt;
                        &lt;xsl:if test="growth &amp;lt; 0"&gt;
                             &lt;xsl:attribute name="style"&gt;
                                 &lt;xsl:text&gt;color:red&lt;/xsl:text&gt;
                             &lt;/xsl:attribute&gt;
                        &lt;/xsl:if&gt;
                        &lt;xsl:value-of select="growth"/&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;xsl:value-of select="bonus"/&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/xsl:for-each&gt;
        &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>
      <p>
出力される HTML は：
<span lang="en">
The HTML output is:</span>
      </p>
      <pre>&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"&gt;
&lt;title&gt;Sales Results By Division&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table border="1"&gt;
&lt;tr&gt;
&lt;th&gt;Division&lt;/th&gt;&lt;th&gt;Revenue&lt;/th&gt;&lt;th&gt;Growth&lt;/th&gt;&lt;th&gt;Bonus&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;em&gt;North&lt;/em&gt;&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;9&lt;/td&gt;&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;em&gt;West&lt;/em&gt;&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td style="color:red"&gt;-1.5&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;em&gt;South&lt;/em&gt;&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
      <p>
次のスタイルシートはデータを SVG に変換する：
<span lang="en">
The following stylesheet transforms the data into SVG:</span>
      </p>
      <pre>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/Graphics/SVG/SVG-19990812.dtd"&gt;

&lt;xsl:output method="xml" indent="yes" media-type="image/svg"/&gt;

&lt;xsl:template match="/"&gt;

&lt;svg width = "3in" height="3in"&gt;
    &lt;g style = "stroke: #000000"&gt; 
        &lt;!-- draw the axes --&gt;
        &lt;line x1="0" x2="150" y1="150" y2="150"/&gt;
        &lt;line x1="0" x2="0" y1="0" y2="150"/&gt;
        &lt;text x="0" y="10"&gt;Revenue&lt;/text&gt;
        &lt;text x="150" y="165"&gt;Division&lt;/text&gt;
        &lt;xsl:for-each select="sales/division"&gt;
            &lt;!-- define some useful variables --&gt;

            &lt;!-- the bar's x position --&gt;
            &lt;xsl:variable name="pos"
                          select="(position()*40)-30"/&gt;

            &lt;!-- the bar's height --&gt;
            &lt;xsl:variable name="height"
                          select="revenue*10"/&gt;

            &lt;!-- the rectangle --&gt;
            &lt;rect x="{$pos}" y="{150-$height}"
                  width="20" height="{$height}"/&gt;

            &lt;!-- the text label --&gt;
            &lt;text x="{$pos}" y="165"&gt;
                &lt;xsl:value-of select="@id"/&gt;
            &lt;/text&gt; 

            &lt;!-- the bar value --&gt;
            &lt;text x="{$pos}" y="{145-$height}"&gt;
                &lt;xsl:value-of select="revenue"/&gt;
            &lt;/text&gt;
        &lt;/xsl:for-each&gt;
    &lt;/g&gt;
&lt;/svg&gt;

&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre>
      <p>
出力される SVG は：
<span lang="en">
The SVG output is:</span>
      </p>
      <pre>&lt;svg width="3in" height="3in"
     xmlns="http://www.w3.org/Graphics/SVG/svg-19990412.dtd"&gt;
    &lt;g style="stroke: #000000"&gt;
        &lt;line x1="0" x2="150" y1="150" y2="150"/&gt;
        &lt;line x1="0" x2="0" y1="0" y2="150"/&gt;
        &lt;text x="0" y="10"&gt;Revenue&lt;/text&gt;
        &lt;text x="150" y="165"&gt;Division&lt;/text&gt;
        &lt;rect x="10" y="50" width="20" height="100"/&gt;
        &lt;text x="10" y="165"&gt;North&lt;/text&gt;
        &lt;text x="10" y="45"&gt;10&lt;/text&gt;
        &lt;rect x="50" y="110" width="20" height="40"/&gt;
        &lt;text x="50" y="165"&gt;South&lt;/text&gt;
        &lt;text x="50" y="105"&gt;4&lt;/text&gt;
        &lt;rect x="90" y="90" width="20" height="60"/&gt;
        &lt;text x="90" y="165"&gt;West&lt;/text&gt;
        &lt;text x="90" y="85"&gt;6&lt;/text&gt;
    &lt;/g&gt;
&lt;/svg&gt;</pre>
      <p>
次のスタイルシートはデータを VRML に変換する：
<span lang="en">
The following stylesheet transforms the data into VRML:</span>
      </p>
      <pre>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;!-- generate text output as mime type model/vrml, using default charset --&gt;
&lt;xsl:output method="text" encoding="UTF-8" media-type="model/vrml"/&gt;  

        &lt;xsl:template match="/"&gt;#VRML V2.0 utf8 
 
# externproto definition of a single bar element 
EXTERNPROTO bar [ 
  field SFInt32 x  
  field SFInt32 y  
  field SFInt32 z  
  field SFString name  
  ] 
  "http://www.vrml.org/WorkingGroups/dbwork/barProto.wrl" 
 
# inline containing the graph axes 
Inline {  
        url "http://www.vrml.org/WorkingGroups/dbwork/barAxes.wrl" 
        } 
        
                &lt;xsl:for-each select="sales/division"&gt;
bar {
        x &lt;xsl:value-of select="revenue"/&gt;
        y &lt;xsl:value-of select="growth"/&gt;
        z &lt;xsl:value-of select="bonus"/&gt;
        name "&lt;xsl:value-of select="@id"/&gt;" 
        }
                &lt;/xsl:for-each&gt;
        
        &lt;/xsl:template&gt; 
 
&lt;/xsl:stylesheet&gt;</pre>
      <p>
出力される VRML は：
<span lang="en">
The VRML output is:</span>
      </p>
      <pre>#VRML V2.0 utf8 
 
# externproto definition of a single bar element 
EXTERNPROTO bar [ 
  field SFInt32 x  
  field SFInt32 y  
  field SFInt32 z  
  field SFString name  
  ] 
  "http://www.vrml.org/WorkingGroups/dbwork/barProto.wrl" 
 
# inline containing the graph axes 
Inline {  
        url "http://www.vrml.org/WorkingGroups/dbwork/barAxes.wrl" 
        } 
        
                
bar {
        x 10
        y 9
        z 7
        name "North" 
        }
                
bar {
        x 4
        y 3
        z 4
        name "South" 
        }
                
bar {
        x 6
        y -1.5
        z 2
        name "West" 
        }</pre>

</section>
<section>

<h2 id="section-Acknowledgements" title="E Acknowledgements (Non-Normative)">E 謝辞（規定外）</h2>

<div lang="en">
      <p>
The following have contributed to authoring this draft:
      </p>
      <ul>
         <li>Daniel Lipkin, Saba</li>
         <li>Jonathan Marsh, Microsoft</li>
         <li>Henry Thompson, University of Edinburgh</li>
         <li>Norman Walsh, Arbortext</li>
         <li>Steve Zilles, Adobe</li>
      </ul>
      <p>
This specification was developed and approved for publication by the W3C XSL Working Group (WG). WG approval of this specification does not necessarily imply that all WG members voted for its approval. The current members of the XSL WG are:
      </p>
<p>
Sharon Adler, IBM (Co-Chair); Anders Berglund, IBM; Perin Blanchard, Novell;
Scott Boag, Lotus; Larry Cable, Sun; Jeff Caruso, Bitstream; James Clark;
Peter Danielsen, Bell Labs; Don Day, IBM; Stephen Deach, Adobe; Dwayne Dicks,
SoftQuad; Andrew Greene, Bitstream; Paul Grosso, Arbortext; Eduardo Gutentag,
Sun; Juliane Harbarth, Software AG; Mickey Kimchi, Enigma; Chris Lilley, W3C;
Chris Maden, Exemplary Technologies; Jonathan Marsh, Microsoft; Alex
Milowski, Lexica; Steve Muench, Oracle; Scott Parnell, Xerox; Vincent Quint,
W3C; Dan Rapp, Novell; Gregg Reynolds, Datalogics; Jonathan Robie, Software
AG; Mark Scardina, Oracle; Henry Thompson, University of Edinburgh; Philip
Wadler, Bell Labs; Norman Walsh, Arbortext; Sanjiva Weerawarana, IBM; Steve
Zilles, Adobe (Co-Chair)
<ins class="errata">, Boris Moore, RivCom</ins><!-- E1 -->
</p>

</div>

</section>
<section>

<h2 id="section-Changes-from-Proposed-Recommendation" title="F Changes from Proposed Recommendation (Non-Normative)">F 勧告案からの変更点（規定外）</h2>

<div lang="en">
      <p>
The following are the changes since the Proposed Recommendation:
      </p>
      <ul>
         <li>
            <p>
The <code>xsl:version</code> attribute is required on a literal result element used as a stylesheet (see <a href="#result-element-stylesheet">[<b>2.3 Literal Result Element as Stylesheet</b>]</a>).
            </p>
         </li>
         <li>
            <p>
The <code>data-type</code> attribute on <code>xsl:sort</code> can use a prefixed name to specify a data-type not defined by XSLT (see <a href="#sorting">[<b>10 Sorting</b>]</a>).
            </p>
         </li>
      </ul>
</div>

</section>
<section>

<h2 id="section-Features-under-Consideration-for-Future-Versions-of-XSLT" title="G Features under Consideration for Future Versions of XSLT (Non-Normative)">G XSLT の将来版に検討中の機能（規定外）</h2>

<div lang="en">

      <p>
The following features are under consideration for versions of XSLT after XSLT 1.0:
      </p>
      <ul>
         <li>
            <p>
a conditional expression;
            </p>
         </li>
         <li>
            <p>
support for XML Schema datatypes and archetypes;
            </p>
         </li>
         <li>
            <p>
support for something like style rules in the original XSL submission;
            </p>
         </li>
         <li>
            <p>
an attribute to control the default namespace for names occurring in XSLT attributes;
            </p>
         </li>
         <li>
            <p>
support for entity references;
            </p>
         </li>
         <li>
            <p>
support for DTDs in the data model;
            </p>
         </li>
         <li>
            <p>
support for notations in the data model;
            </p>
         </li>
         <li>
            <p>
a way to get back from an element to the elements that reference it (e.g. by IDREF attributes);
            </p>
         </li>
         <li>
            <p>
an easier way to get an ID or key in another document;
            </p>
         </li>
         <li>
            <p>
support for regular expressions for matching against any or all of text nodes, attribute values, attribute names, element type names;
            </p>
         </li>
         <li>
            <p>
case-insensitive comparisons;
            </p>
         </li>
         <li>
            <p>
normalization of strings before comparison, for example for compatibility characters;
            </p>
         </li>
         <li>
            <p>
a function string resolve(node-set) function that treats the value of the argument as a relative URI and turns it into an absolute URI using the base URI of the node;
            </p>
         </li>
         <li>
            <p>
multiple result documents;
            </p>
         </li>
         <li>
            <p>
defaulting the select attribute on xsl:value-of to the current node;
            </p>
         </li>
         <li>
            <p>
an attribute on xsl:attribute to control how the attribute value is normalized;
            </p>
         </li>
         <li>
            <p>
additional attributes on xsl:sort to provide further control over sorting, such as relative order of scripts;
            </p>
         </li>
         <li>
            <p>
a way to put the text of a resource identified by a URI into the result tree;
            </p>
         </li>
         <li>
            <p>
allow unions in steps (e.g. foo/(bar|baz));
            </p>
         </li>
         <li>
            <p>
allow for result tree fragments all operations that are allowed for node-sets;
            </p>
         </li>
         <li>
            <p>
a way to group together consecutive nodes having duplicate subelements or attributes;
            </p>
         </li>
         <li>
            <p>
features to make handling of the HTML style attribute more convenient.
            </p>
         </li>
      </ul>
</div>

	</section>
</section>

<aside lang="en" class="trans-meta">

<h2 id="copyright-notice">W3C Document License</h2>

<p class="tPadding">
Public documents on the W3C site are provided by the copyright holders
under the following license.</p>

<h2>License</h2>
<p class="tPadding">
By using and/or copying this document, or the
W3C document from which this statement is linked, you (the licensee) agree
that you have read, understood, and will comply with the following terms and
conditions:</p>

<p>
Permission to copy, and distribute the contents of this document, or the
W3C document from which this statement is linked, in any medium for any
purpose and without fee or royalty is hereby granted, provided that you
include the following on <i>ALL</i> copies of the document, or portions
thereof, that you use:</p>
<ul class="show_items"><li>A link or URL to the original W3C document.</li><li>The pre-existing copyright notice of the original author, or if it
doesn't exist, a notice (hypertext is preferred, but a textual
representation is permitted) of the form: "Copyright ©
[$date-of-document] <a href="http://www.w3.org/">World Wide Web
Consortium</a>, (<a href="http://www.csail.mit.edu/">Massachusetts
Institute of Technology</a>, <a href="http://www.ercim.org/">European
Research Consortium for Informatics and Mathematics</a>, <a href="http://www.keio.ac.jp/">Keio University</a>). All Rights Reserved.
<a href="http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231">http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231</a>"</li><li>
<em>If it exists</em>, the STATUS of the W3C document.</li></ul>

<p>
When space permits, inclusion of the full text of this <b>NOTICE</b>
should be provided. We request that authorship attribution be provided in any
software, documents, or other items or products that you create pursuant to
the implementation of the contents of this document, or any portion
thereof.</p>

<p>
No right to create modifications or derivatives of W3C documents is
granted pursuant to this license. However, if additional requirements
(documented in the <a href="http://www.w3.org/Consortium/Legal/IPR-FAQ">Copyright FAQ</a>) are
satisfied, the right to create modifications or derivatives is sometimes
granted by the W3C to individuals complying with those requirements.</p>

<h2>Disclaimers</h2>
<p>
THIS DOCUMENT IS PROVIDED "AS IS," AND COPYRIGHT HOLDERS MAKE NO
REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED
TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
NON-INFRINGEMENT, OR TITLE; THAT THE CONTENTS OF THE DOCUMENT ARE SUITABLE
FOR ANY PURPOSE; NOR THAT THE IMPLEMENTATION OF SUCH CONTENTS WILL NOT
INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.</p>

<p>
COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE DOCUMENT OR THE
PERFORMANCE OR IMPLEMENTATION OF THE CONTENTS THEREOF.</p>

<p>
The name and trademarks of copyright holders may NOT be used in
advertising or publicity pertaining to this document or its contents without
specific, written prior permission. Title to copyright in this document will
at all times remain with copyright holders.</p>

<h2>Notes</h2>

<p>
This version: http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231</p>

<p>
This formulation of W3C's notice and license became active on December 31
2002. This version removes the copyright ownership notice such that this
license can be used with materials other than those owned by the W3C, moves
information on style sheets, DTDs, and schemas to the <a href="http://www.w3.org/Consortium/Legal/IPR-FAQ">Copyright FAQ</a>, reflects
that ERCIM is now a host of the W3C, includes references to this specific
dated version of the license, and removes the ambiguous grant of "use". See
the <a href="http://www.w3.org/Consortium/Legal/copyright-documents-19990405">older
formulation</a> for the policy prior to this date. Please see our <a href="http://www.w3.org/Consortium/Legal/IPR-FAQ">Copyright FAQ</a> for
common questions about using materials from our site, such as the translating
or annotating specifications. </p>

</aside>

<aside class="trans-meta" >

<h2 id="about-translation">XSLT 1.0 仕様 日本語訳についてのその他の情報</h2>
<p >
この訳には原文仕様に対する公式の
<a href="http://www.w3.org/1999/11/REC-xslt-19991116-errata" >修正</a>
も取り込まれています。
修正により削除される部分の訳は掲載せず、新たに挿入／修正された訳を掲載しています。
修正部分には原則的に ins, del タグによる<ins class="errata">挿入</ins>／<del class="errata">削除</del>のマークアップを施しています。
</p>

<p >
このページ自体には外部スタイルシート等の外部依存性はないのでページのみローカルに保存してオフラインで閲覧しても支障ありませんが、この仕様の基礎となる XPath 1.0 仕様へのリンクは拙訳による
<a href="https://triple-underscore.github.io/XML/xpath10-ja.html" >日本語訳</a>
への相対リンクになっていますのでそちらのページも併せて保存する必要があります。</p>
<p >
この文書のマークアップには HTML5, スタイル付けには CSS 2.1 の機能が利用されています。古いブラウザでは表示が崩れるかもしれません。
</p>
<p >
<span class="trans-note">訳注は【】で括り、この文と同じスタイル付けを施しています。
</span><br />
<span id="sample-source-style">原文にはこの文と同じスタイル付けを施しています。
</span>
</p>
<p >
この翻訳について誤訳等お気付きの点その他ありましたら、遠慮なく訳者までお知らせ願います（<a href="https://triple-underscore.github.io/about.html">連絡先</a>）。
</p>
<p>
公開日 <time>2010-05-22</time>
更新日 <time>2012-02-12</time><br />
更新日現在の URL ：<a href="https://triple-underscore.github.io/XML/xslt10-ja.html" >https://triple-underscore.github.io/XML/xslt10-ja.html</a>
</p>
</aside>



   </body>

</html>
